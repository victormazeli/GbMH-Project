// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgen

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/steebchen/keskin-api/prisma"
)

type AuthPayload interface {
	IsAuthPayload()
}

type IAppointmentReview interface {
	IsIAppointmentReview()
}

type ICustomer interface {
	IsICustomer()
}

type IEmployee interface {
	IsIEmployee()
}

type IManager interface {
	IsIManager()
}

type IProductReview interface {
	IsIProductReview()
}

type IServiceReview interface {
	IsIServiceReview()
}

// An object with an ID.
type Node interface {
	IsNode()
}

type OpeningHourBase interface {
	IsOpeningHourBase()
}

type WorkingHoursBase interface {
	IsWorkingHoursBase()
}

type ActivateAccountInput struct {
	Token string `json:"token"`
}

type ActivateAccountPayload struct {
	Status string `json:"status"`
}

type AdministratorConnection struct {
	Nodes []*prisma.Administrator `json:"nodes"`
}

type AppointmentConnection struct {
	Nodes []*prisma.Appointment `json:"nodes"`
}

type AppointmentInput struct {
	// Order by field and direction.
	Order *AppointmentOrderByInput `json:"order"`
	// Filter by status.
	Status []prisma.AppointmentStatus `json:"status"`
	Start  *DateFilter                `json:"start"`
	End    *DateFilter                `json:"end"`
}

type AppointmentOrderByInput struct {
	Field     AppointmentOrderByFields `json:"field"`
	Direction OrderByDirectionInput    `json:"direction"`
}

type AppointmentProduct struct {
	Item  *prisma.Product `json:"item"`
	Count int             `json:"count"`
}

type AppointmentReviewConnection struct {
	Nodes []*prisma.AppointmentReview `json:"nodes"`
}

type ApproveReviewPayload struct {
	Review prisma.IReview `json:"review"`
}

type BranchConnection struct {
	Nodes []*prisma.Branch `json:"nodes"`
}

type BranchImageSlot struct {
	ID         string         `json:"id"`
	CreatedAt  string         `json:"createdAt"`
	UpdatedAt  string         `json:"updatedAt"`
	SlotNumber int            `json:"slotNumber"`
	Branch     *prisma.Branch `json:"branch"`
	ImageURL   string         `json:"imageUrl"`
}

type BranchImageSlotInput struct {
	SlotNumber *int           `json:"slotNumber"`
	SlotID     *string        `json:"slotID"`
	BranchID   string         `json:"branchID"`
	NewImage   graphql.Upload `json:"newImage"`
	New        bool           `json:"new"`
}

type BranchesInput struct {
	// The company ID.
	Company *string `json:"company"`
}

type CancelAppointmentInput struct {
	ID string `json:"id"`
}

type CancelAppointmentPayload struct {
	Appointment *prisma.Appointment `json:"appointment"`
}

type CompanyConnection struct {
	Nodes []*prisma.Company `json:"nodes"`
}

type ConnectAppointmentProduct struct {
	ID    string `json:"id"`
	Count int    `json:"count"`
}

type ConnectAppointmentService struct {
	ID string `json:"id"`
}

type CreateAdministratorInput struct {
	User *CreateUserData `json:"user"`
}

type CreateAdministratorPayload struct {
	Administrator *prisma.Administrator `json:"administrator"`
}

type CreateAppointmentData struct {
	Start       time.Time                    `json:"start"`
	Desc        *string                      `json:"desc"`
	Services    []*ConnectAppointmentService `json:"services"`
	Products    []*ConnectAppointmentProduct `json:"products"`
	BeforeImage *graphql.Upload              `json:"beforeImage"`
}

type CreateAppointmentReviewInput struct {
	Appointment string            `json:"appointment"`
	Review      *CreateReviewData `json:"review"`
}

type CreateBranchData struct {
	Name               string                  `json:"name"`
	PhoneNumber        *string                 `json:"phoneNumber"`
	Address            *string                 `json:"address"`
	WelcomeMessage     *string                 `json:"welcomeMessage"`
	Images             []*graphql.Upload       `json:"images"`
	ImagesSlot         []*BranchImageSlotInput `json:"imagesSlot"`
	Logo               *graphql.Upload         `json:"logo"`
	AppTheme           *string                 `json:"appTheme"`
	FacebookLink       *string                 `json:"facebookLink"`
	TiktokLink         *string                 `json:"tiktokLink"`
	InstagramLink      *string                 `json:"instagramLink"`
	SMTPSendHost       *string                 `json:"smtpSendHost"`
	SMTPSendPort       *string                 `json:"smtpSendPort"`
	SMTPUsername       *string                 `json:"smtpUsername"`
	SMTPPassword       *string                 `json:"smtpPassword"`
	FromEmail          *string                 `json:"fromEmail"`
	WebsiteURL         string                  `json:"websiteUrl"`
	NavigationLink     *string                 `json:"navigationLink"`
	SharingRedirectURL *string                 `json:"sharingRedirectUrl"`
	MailchimpAPIKey    *string                 `json:"mailchimpApiKey"`
	MailchimpListID    *string                 `json:"mailchimpListId"`
	Imprint            string                  `json:"imprint"`
}

type CreateBranchInput struct {
	Company string            `json:"company"`
	Data    *CreateBranchData `json:"data"`
}

type CreateBranchPayload struct {
	Branch *prisma.Branch `json:"branch"`
}

type CreateCompanyData struct {
	Name               *string         `json:"name"`
	Aliases            []string        `json:"aliases"`
	CustomUrls         []string        `json:"customUrls"`
	SharingRedirectURL *string         `json:"sharingRedirectUrl"`
	Logo               *graphql.Upload `json:"logo"`
	AppTheme           *string         `json:"appTheme"`
	PwaShortName       string          `json:"pwaShortName"`
	PwaIcon            *graphql.Upload `json:"pwaIcon"`
	PwaThemeColor      string          `json:"pwaThemeColor"`
	PwaBackgroundColor string          `json:"pwaBackgroundColor"`
}

type CreateCompanyInput struct {
	Data *CreateCompanyData `json:"data"`
}

type CreateCompanyPayload struct {
	Company *prisma.Company `json:"company"`
}

type CreateCustomerData struct {
	Note               *string `json:"note"`
	AllowReviewSharing *bool   `json:"allowReviewSharing"`
}

type CreateCustomerInput struct {
	Company  string              `json:"company"`
	User     *CreateUserData     `json:"user"`
	Customer *CreateCustomerData `json:"customer"`
}

type CreateCustomerPayload struct {
	Customer *prisma.Customer `json:"customer"`
}

type CreateEmployeeData struct {
	WorkingHours []*WorkingHoursInput `json:"workingHours"`
}

type CreateEmployeeInput struct {
	Branch   string              `json:"branch"`
	Data     *CreateUserData     `json:"data"`
	Employee *CreateEmployeeData `json:"employee"`
}

type CreateEmployeePayload struct {
	Employee *prisma.Employee `json:"employee"`
}

type CreateFavoriteData struct {
	Product *string `json:"product"`
	Service *string `json:"service"`
}

type CreateFavoriteInput struct {
	Data *CreateFavoriteData `json:"data"`
}

type CreateFavoritePayload struct {
	Favorite *prisma.Favorite `json:"favorite"`
}

type CreateManagerData struct {
	WorkingHours []*WorkingHoursInput `json:"workingHours"`
}

type CreateManagerInput struct {
	Company string             `json:"company"`
	User    *CreateUserData    `json:"user"`
	Manager *CreateManagerData `json:"manager"`
}

type CreateManagerPayload struct {
	Manager *prisma.Manager `json:"manager"`
}

type CreateNewsData struct {
	Title *string         `json:"title"`
	Image *graphql.Upload `json:"image"`
}

type CreateNewsInput struct {
	Branch string          `json:"branch"`
	Data   *CreateNewsData `json:"data"`
}

type CreateNewsPayload struct {
	News *prisma.News `json:"news"`
}

type CreateProductCategoryData struct {
	Name *string `json:"name"`
}

type CreateProductCategoryInput struct {
	Data *CreateProductCategoryData `json:"data"`
}

type CreateProductCategoryPayload struct {
	Category *prisma.ProductCategory `json:"category"`
}

type CreateProductData struct {
	Name        string                          `json:"name"`
	Desc        *string                         `json:"desc"`
	Price       float64                         `json:"price"`
	Capacity    *string                         `json:"capacity"`
	Category    string                          `json:"category"`
	Subcategory string                          `json:"subcategory"`
	Image       *graphql.Upload                 `json:"image"`
	Attributes  []*ProductServiceAttributeInput `json:"attributes"`
}

type CreateProductInput struct {
	Branch string             `json:"branch"`
	Data   *CreateProductData `json:"data"`
}

type CreateProductPayload struct {
	Product *prisma.Product `json:"product"`
}

type CreateProductReviewInput struct {
	Product string            `json:"product"`
	Review  *CreateReviewData `json:"review"`
}

type CreateProductSubCategoryData struct {
	ProductCategoryID string  `json:"productCategoryId"`
	Name              *string `json:"name"`
}

type CreateProductSubCategoryInput struct {
	Data *CreateProductSubCategoryData `json:"data"`
}

type CreateProductSubCategoryPayload struct {
	SubCategory *prisma.ProductSubCategory `json:"subCategory"`
}

type CreateReviewData struct {
	Stars float64 `json:"stars"`
	Title string  `json:"title"`
	Text  string  `json:"text"`
}

type CreateServiceCategoryData struct {
	Name *string `json:"name"`
}

type CreateServiceCategoryInput struct {
	Data *CreateServiceCategoryData `json:"data"`
}

type CreateServiceCategoryPayload struct {
	Category *prisma.ServiceCategory `json:"category"`
}

type CreateServiceData struct {
	Name  string  `json:"name"`
	Desc  *string `json:"desc"`
	Price float64 `json:"price"`
	// The duration of this service in minutes.
	Duration     int                             `json:"duration"`
	Category     string                          `json:"category"`
	Subcategory  string                          `json:"subcategory"`
	GenderTarget prisma.GenderTarget             `json:"genderTarget"`
	Image        *graphql.Upload                 `json:"image"`
	Attributes   []*ProductServiceAttributeInput `json:"attributes"`
}

type CreateServiceInput struct {
	Branch string             `json:"branch"`
	Data   *CreateServiceData `json:"data"`
}

type CreateServicePayload struct {
	Service *prisma.Service `json:"service"`
}

type CreateServiceReviewInput struct {
	Service string            `json:"service"`
	Review  *CreateReviewData `json:"review"`
}

type CreateServiceSubCategoryData struct {
	CategoryID string  `json:"categoryId"`
	Name       *string `json:"name"`
}

type CreateServiceSubCategoryInput struct {
	Data *CreateServiceSubCategoryData `json:"data"`
}

type CreateServiceSubCategoryPayload struct {
	SubCategory *prisma.ServiceSubCategory `json:"subCategory"`
}

type CreateUserData struct {
	Email       string        `json:"email"`
	FirstName   string        `json:"firstName"`
	LastName    string        `json:"lastName"`
	Gender      prisma.Gender `json:"gender"`
	PhoneNumber *string       `json:"phoneNumber"`
	ZipCode     *string       `json:"zipCode"`
	Street      *string       `json:"street"`
	City        *string       `json:"city"`
	Birthday    *string       `json:"birthday"`
}

type CustomerConnection struct {
	Nodes []*prisma.Customer `json:"nodes"`
}

type CustomerInput struct {
	// Returns all customers from a given branch.
	Branch *string `json:"branch"`
	// Returns all customers from a given company.
	Company *string               `json:"company"`
	Order   *CustomerOrderByInput `json:"order"`
}

type CustomerOrderByInput struct {
	Field     CustomerOrderByFields `json:"field"`
	Direction OrderByDirectionInput `json:"direction"`
}

type CustomerRequestAppointmentInput struct {
	// The branch.
	Branch string `json:"branch"`
	// The employee. When unspecified, the next best employee will be automatically choosen.
	Employee *string                `json:"employee"`
	Data     *CreateAppointmentData `json:"data"`
}

type CustomerRequestAppointmentPayload struct {
	Message *string `json:"message"`
}

type CustomerReviewConnection struct {
	Nodes []prisma.IReview `json:"nodes"`
}

type DateFilter struct {
	Gt  *time.Time `json:"gt"`
	Gte *time.Time `json:"gte"`
	Lt  *time.Time `json:"lt"`
	Lte *time.Time `json:"lte"`
}

type DeleteAdministratorInput struct {
	ID string `json:"id"`
}

type DeleteAdministratorPayload struct {
	Administrator *prisma.Administrator `json:"administrator"`
}

type DeleteBranchImageInput struct {
	SlotID   string `json:"slotID"`
	BranchID string `json:"branchID"`
}

type DeleteBranchInput struct {
	ID string `json:"id"`
}

type DeleteBranchPayload struct {
	Branch *prisma.Branch `json:"branch"`
}

type DeleteCompanyInput struct {
	ID string `json:"id"`
}

type DeleteCompanyPayload struct {
	Company *prisma.Company `json:"company"`
}

type DeleteCustomerInput struct {
	ID string `json:"id"`
}

type DeleteCustomerPayload struct {
	Customer *prisma.Customer `json:"customer"`
}

type DeleteEmployeeInput struct {
	ID string `json:"id"`
}

type DeleteEmployeePayload struct {
	Employee *prisma.Employee `json:"employee"`
}

type DeleteFavoriteInput struct {
	ID string `json:"id"`
}

type DeleteFavoritePayload struct {
	Favorite *prisma.Favorite `json:"favorite"`
}

type DeleteManagerInput struct {
	ID string `json:"id"`
}

type DeleteManagerPayload struct {
	Manager *prisma.Manager `json:"manager"`
}

type DeleteNewsInput struct {
	ID string `json:"id"`
}

type DeleteNewsPayload struct {
	News *prisma.News `json:"news"`
}

type DeleteProductCategoryInput struct {
	ID string `json:"id"`
}

type DeleteProductCategoryPayload struct {
	Category *prisma.ProductCategory `json:"category"`
}

type DeleteProductInput struct {
	ID string `json:"id"`
}

type DeleteProductPayload struct {
	Product *prisma.Product `json:"product"`
}

type DeleteProductSubCategoryInput struct {
	ID string `json:"id"`
}

type DeleteProductSubCategoryPayload struct {
	SubCategory *prisma.ProductSubCategory `json:"subCategory"`
}

type DeleteReviewPayload struct {
	Review prisma.IReview `json:"review"`
}

type DeleteServiceCategoryInput struct {
	ID string `json:"id"`
}

type DeleteServiceCategoryPayload struct {
	Category *prisma.ServiceCategory `json:"category"`
}

type DeleteServiceInput struct {
	ID string `json:"id"`
}

type DeleteServicePayload struct {
	Service *prisma.Service `json:"service"`
}

type DeleteServiceSubCategoryInput struct {
	ID string `json:"id"`
}

type DeleteServiceSubCategoryPayload struct {
	SubCategory *prisma.ServiceSubCategory `json:"subCategory"`
}

type EditEmployeeAvailabilityInput struct {
	StartDate  time.Time          `json:"startDate"`
	EndDate    time.Time          `json:"endDate"`
	EmployeeID string             `json:"employeeID"`
	Status     AvailabilityStatus `json:"status"`
}

type EditEmployeeAvailabilityPayload struct {
	Employee *prisma.Employee `json:"employee"`
}

type EmailTemplateInput struct {
	ID   *string `json:"id"`
	Name *string `json:"name"`
}

type EmailTemplateQueryPayload struct {
	Template *prisma.EmailTemplate `json:"template"`
}

type EmailTemplatesQueryPayload struct {
	Templates []*prisma.EmailTemplate `json:"templates"`
}

type EmployeeConnection struct {
	Nodes []*prisma.Employee `json:"nodes"`
}

type EmployeeInput struct {
	// Returns all employees from a given branch.
	Branch *string `json:"branch"`
	// Returns all employees from a given company.
	Company *string `json:"company"`
}

type FavoritesPayload struct {
	Products *ProductConnection `json:"products"`
	Services *ServiceConnection `json:"services"`
}

type ForceAppointmentNotificationInput struct {
	Appointment string `json:"appointment"`
}

// A human-formatted array to display opening hours. Equal days are summarized.
type FormattedOpeningHour struct {
	// The day key, e.g. `MO` or `MO-FR`
	Key      string `json:"key"`
	Closed   bool   `json:"closed"`
	Break    bool   `json:"break"`
	ShortDay string `json:"shortDay"`
	FullDay  string `json:"fullDay"`
	// A formatted value containing either the opening time for that day or a translated 'closed' message.
	Value string `json:"value"`
}

func (FormattedOpeningHour) IsOpeningHourBase() {}

// A human-formatted array to display working hours. Equal days are summarized.
type FormattedWorkingHours struct {
	// The day key, e.g. `MO` or `MO-FR`
	Key        string `json:"key"`
	NotWorking bool   `json:"notWorking"`
	Break      bool   `json:"break"`
	ShortDay   string `json:"shortDay"`
	FullDay    string `json:"fullDay"`
	// A formatted value containing either the working time for that day or a translated 'not working' message.
	Value string `json:"value"`
}

func (FormattedWorkingHours) IsWorkingHoursBase() {}

type Image struct {
	ID  string `json:"id"`
	URL string `json:"url"`
}

type IsValidPasswordTokenPayload struct {
	Valid bool `json:"valid"`
}

type LoginInput struct {
	Email    string  `json:"email"`
	Password string  `json:"password"`
	Company  *string `json:"company"`
}

type LoginPayload struct {
	Session *prisma.Session `json:"session"`
	User    prisma.IUser    `json:"user"`
}

func (LoginPayload) IsAuthPayload() {}

type LogoutPayload struct {
	// Session is always nil, this is useful for automatically clearing the session out of the GraphQL store.
	Session *prisma.Session `json:"session"`
}

type ManagerConnection struct {
	Nodes []*prisma.Manager `json:"nodes"`
}

type NewsConnection struct {
	Nodes []*prisma.News `json:"nodes"`
}

type NotificationPayload struct {
	UserID string `json:"userId"`
	Result string `json:"result"`
}

type NotificationsPayload struct {
	Payloads []*NotificationPayload `json:"payloads"`
}

type NotifyAllCustomersInput struct {
	Title   string  `json:"title"`
	Text    string  `json:"text"`
	Company *string `json:"company"`
}

// A wrapper for an opening hour.
type OpeningHours struct {
	Formatted []*FormattedOpeningHour `json:"formatted"`
	Raw       []*RawOpeningHour       `json:"raw"`
}

type OrderHistoryPayload struct {
	Products *ProductConnection `json:"products"`
	Services *ServiceConnection `json:"services"`
}

// PageInfo contains info about the current page.
type PageInfo struct {
	// Indicates whether a next page exists. Defaults to false if not navigating forward.
	HasNextPage bool `json:"hasNextPage"`
}

// PaginationInput is an input solely used for cursor-based, relay-like pagination.
type PaginationInput struct {
	// Only return results after specified cursor.
	After *string `json:"after"`
	// Limit the result to a given value. Value defaults to 10 and can be between 1 and 100.
	Limit *int `json:"limit"`
}

// A phoneNumber object, providing fields for raw usage and for the a-tag for HTML usage.
type PhoneNumber struct {
	Href string `json:"href"`
	Raw  string `json:"raw"`
}

type Price struct {
	Value        float64 `json:"value"`
	DisplayValue string  `json:"displayValue"`
}

type ProductConnection struct {
	Nodes []*prisma.Product `json:"nodes"`
}

type ProductInput struct {
	// Returns all products from a given branch.
	Branch *string `json:"branch"`
	// Returns all products from a given company.
	Company *string `json:"company"`
	// Order by field and direction.
	Order *ProductOrderByInput `json:"order"`
}

type ProductOrderByInput struct {
	Field     ProductOrderByFields  `json:"field"`
	Direction OrderByDirectionInput `json:"direction"`
}

type ProductReviewConnection struct {
	Nodes []*prisma.ProductReview `json:"nodes"`
}

type ProductServiceAttributeInput struct {
	Key   string  `json:"key"`
	Name  *string `json:"name"`
	Value *string `json:"value"`
}

type PublicStaffMemberConnection struct {
	Nodes []prisma.IPublicStaff `json:"nodes"`
}

// A raw array to display opening hours by day.
type RawOpeningHour struct {
	Day       prisma.DayOfWeek `json:"day"`
	Closed    bool             `json:"closed"`
	Break     bool             `json:"break"`
	ShortDay  string           `json:"shortDay"`
	FullDay   string           `json:"fullDay"`
	Forenoon  *Timerange       `json:"forenoon"`
	Afternoon *Timerange       `json:"afternoon"`
}

func (RawOpeningHour) IsOpeningHourBase() {}

// A raw array to display working hours by day.
type RawWorkingHours struct {
	Day        prisma.DayOfWeek `json:"day"`
	NotWorking bool             `json:"notWorking"`
	Break      bool             `json:"break"`
	ShortDay   string           `json:"shortDay"`
	FullDay    string           `json:"fullDay"`
	Forenoon   *Timerange       `json:"forenoon"`
	Afternoon  *Timerange       `json:"afternoon"`
}

func (RawWorkingHours) IsWorkingHoursBase() {}

type RegisterInput struct {
	Email       string        `json:"email"`
	Password    string        `json:"password"`
	FirstName   string        `json:"firstName"`
	LastName    string        `json:"lastName"`
	PhoneNumber string        `json:"phoneNumber"`
	Gender      prisma.Gender `json:"gender"`
	Birthday    *string       `json:"birthday"`
	Company     *string       `json:"company"`
}

type RegisterPayload struct {
	Status string `json:"status"`
}

type RelatedCompanies struct {
	Companies []*prisma.Company `json:"companies"`
	IsAdmin   bool              `json:"isAdmin"`
}

type RemoveViewerProfilePicturePayload struct {
	Image *Image       `json:"image"`
	User  prisma.IUser `json:"user"`
}

type ReplaceExistingProductInput struct {
	CategoryID    string   `json:"categoryID"`
	SubCategoryID string   `json:"subCategoryID"`
	Products      []string `json:"products"`
}

type ReplaceExistingProductsPayload struct {
	ProductSubCategory *prisma.ProductSubCategory `json:"productSubCategory"`
}

type ReplaceExistingServiceInput struct {
	CategoryID    string   `json:"categoryID"`
	SubCategoryID string   `json:"subCategoryID"`
	Services      []string `json:"services"`
}

type ReplaceExistingServicePayload struct {
	ServiceSubCategory *prisma.ServiceSubCategory `json:"serviceSubCategory"`
}

type RequestActivationLinkInput struct {
	Email   string  `json:"email"`
	Company *string `json:"company"`
}

type RequestActivationLinkPayload struct {
	Status string `json:"status"`
}

type RequestPasswordResetInput struct {
	Email   string  `json:"email"`
	Company *string `json:"company"`
}

type RequestPasswordResetPayload struct {
	Status string `json:"status"`
}

type RescheduleAppointmentInput struct {
	ID         string    `json:"id"`
	NewDate    time.Time `json:"newDate"`
	EmployeeID *string   `json:"employeeID"`
}

type RescheduleAppointmentPayload struct {
	Appointment *prisma.Appointment `json:"appointment"`
}

type ResetPasswordInput struct {
	Token    string `json:"token"`
	Password string `json:"password"`
}

type ResetPasswordPayload struct {
	Status string `json:"status"`
}

// A reviewAggregations object, providing aggregated metrics for reviews.
type ReviewAggregations struct {
	TotalCount    int     `json:"totalCount"`
	AverageRating float64 `json:"averageRating"`
	CountPerStar  []int   `json:"countPerStar"`
}

type ReviewConnection struct {
	Nodes []prisma.IReview `json:"nodes"`
}

type ReviewInput struct {
	// Returns all reviews from a given customer. By default returns reviews for viewer.
	Customer *string               `json:"customer"`
	Status   []prisma.ReviewStatus `json:"status"`
	Type     []prisma.ReviewType   `json:"type"`
	Order    *ReviewOrderByInput   `json:"order"`
	Company  *string               `json:"company"`
}

type ReviewOrderByInput struct {
	Field     ReviewOrderByFields   `json:"field"`
	Direction OrderByDirectionInput `json:"direction"`
}

type SendEmailPayload struct {
	Status string `json:"status"`
}

type SendInviteEmailInput struct {
	Email  string        `json:"email"`
	Name   string        `json:"name"`
	Gender prisma.Gender `json:"gender"`
	Branch string        `json:"branch"`
}

type SendUserNotificationInput struct {
	Title string   `json:"title"`
	Text  string   `json:"text"`
	Users []string `json:"users"`
}

type ServiceConnection struct {
	Nodes []*prisma.Service `json:"nodes"`
}

type ServiceInput struct {
	// Returns all services from a given branch.
	Branch *string `json:"branch"`
	// Returns all services from a given company.
	Company *string `json:"company"`
	// Order by field and direction.
	Order *ServiceOrderByInput `json:"order"`
	// Only return services for a specific gender. If omitted, return any.
	GenderTarget *prisma.GenderTarget `json:"genderTarget"`
}

type ServiceOrderByInput struct {
	Field     ServiceOrderByFields  `json:"field"`
	Direction OrderByDirectionInput `json:"direction"`
}

type ServiceReviewConnection struct {
	Nodes []*prisma.ServiceReview `json:"nodes"`
}

type SetProductActiveInput struct {
	Active    bool   `json:"active"`
	ProductID string `json:"productID"`
}

type SetProductActivePayload struct {
	Product *prisma.Product `json:"product"`
}

type SetServiceActiveInput struct {
	Active    bool   `json:"active"`
	ServiceID string `json:"serviceID"`
}

type SetServiceActivePayload struct {
	Service *prisma.Service `json:"service"`
}

type StaffApproveAppointmentInput struct {
	// The appointment ID.
	ID    string                        `json:"id"`
	Patch *StaffApproveAppointmentPatch `json:"patch"`
}

type StaffApproveAppointmentPatch struct {
	// Optionally override the existing description.
	Desc *string `json:"desc"`
	// Optionally set a note.
	Note *string `json:"note"`
}

type StaffApproveAppointmentPayload struct {
	Appointment *prisma.Appointment `json:"appointment"`
}

type StaffCreateAppointmentInput struct {
	// The branch.
	Branch string `json:"branch"`
	// The customer.
	Customer string `json:"customer"`
	// The employee. When unspecified, defaults to the viewer.
	Employee *string                `json:"employee"`
	Data     *CreateAppointmentData `json:"data"`
}

type StaffCreateAppointmentPayload struct {
	Appointment *prisma.Appointment `json:"appointment"`
}

type StaffMemberConnection struct {
	Nodes []prisma.IStaff `json:"nodes"`
}

type StaffMemberInput struct {
	// Returns all staff members from a given branch.
	Branch *string `json:"branch"`
	// Returns all staff members from a given company.
	Company *string `json:"company"`
}

type StaffUpdateAppointmentInput struct {
	// The appointment ID.
	ID    string                       `json:"id"`
	Patch *StaffUpdateAppointmentPatch `json:"patch"`
}

type StaffUpdateAppointmentPatch struct {
	Note *string `json:"note"`
	Desc *string `json:"desc"`
}

type StaffUpdateAppointmentPayload struct {
	Appointment *prisma.Appointment `json:"appointment"`
}

type SubscribeNewsletterPayload struct {
	ID            *string `json:"id"`
	UniqueEmailID *string `json:"uniqueEmailID"`
}

type Timerange struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type TimerangeInput struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type TimeslotInput struct {
	Branch string `json:"branch"`
	// If an employee is provided, time slots only show for the given employee.
	Employee *string `json:"employee"`
	// An optional start date which defaults to today. The time part is ignored.
	Start    *time.Time                   `json:"start"`
	Services []*ConnectAppointmentService `json:"services"`
	Products []*ConnectAppointmentProduct `json:"products"`
}

type TimeslotRange struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type Timeslots struct {
	// The calculated duration in minutes.
	Duration int `json:"duration"`
	// The calculated total price, including services and products.
	Price *Price `json:"price"`
	// All timeslot ranges. Returns an empty array if none available.
	Ranges []*TimeslotRange `json:"ranges"`
}

type UpdateAdministratorInput struct {
	ID    string           `json:"id"`
	Patch *UpdateUserPatch `json:"patch"`
}

type UpdateAdministratorPayload struct {
	Administrator *prisma.Administrator `json:"administrator"`
}

type UpdateAppointmentImageInput struct {
	Appointment string         `json:"appointment"`
	Image       graphql.Upload `json:"image"`
}

type UpdateAppointmentImagePayload struct {
	Appointment *prisma.Appointment `json:"appointment"`
}

type UpdateBranchInput struct {
	ID    string             `json:"id"`
	Patch *UpdateBranchPatch `json:"patch"`
}

type UpdateBranchPatch struct {
	Name               *string                 `json:"name"`
	PhoneNumber        *string                 `json:"phoneNumber"`
	Address            *string                 `json:"address"`
	WelcomeMessage     *string                 `json:"welcomeMessage"`
	Images             []*graphql.Upload       `json:"images"`
	ImagesSlot         []*BranchImageSlotInput `json:"imagesSlot"`
	Logo               *graphql.Upload         `json:"logo"`
	AppTheme           *string                 `json:"appTheme"`
	FacebookLink       *string                 `json:"facebookLink"`
	TiktokLink         *string                 `json:"tiktokLink"`
	InstagramLink      *string                 `json:"instagramLink"`
	SMTPSendHost       *string                 `json:"smtpSendHost"`
	SMTPSendPort       *string                 `json:"smtpSendPort"`
	SMTPUsername       *string                 `json:"smtpUsername"`
	SMTPPassword       *string                 `json:"smtpPassword"`
	FromEmail          *string                 `json:"fromEmail"`
	WebsiteURL         *string                 `json:"websiteUrl"`
	NavigationLink     *string                 `json:"navigationLink"`
	SharingRedirectURL *string                 `json:"sharingRedirectUrl"`
	MailchimpAPIKey    *string                 `json:"mailchimpApiKey"`
	MailchimpListID    *string                 `json:"mailchimpListId"`
	Imprint            *string                 `json:"imprint"`
}

type UpdateBranchPayload struct {
	Branch *prisma.Branch `json:"branch"`
}

type UpdateCompanyData struct {
	Name               *string         `json:"name"`
	Aliases            []string        `json:"aliases"`
	CustomUrls         []string        `json:"customUrls"`
	SharingRedirectURL *string         `json:"sharingRedirectUrl"`
	Logo               *graphql.Upload `json:"logo"`
	AppTheme           *string         `json:"appTheme"`
	PwaShortName       *string         `json:"pwaShortName"`
	PwaIcon            *graphql.Upload `json:"pwaIcon"`
	PwaThemeColor      *string         `json:"pwaThemeColor"`
	PwaBackgroundColor *string         `json:"pwaBackgroundColor"`
}

type UpdateCompanyInput struct {
	ID    string             `json:"id"`
	Patch *UpdateCompanyData `json:"patch"`
}

type UpdateCompanyPayload struct {
	Company *prisma.Company `json:"company"`
}

type UpdateCustomerInput struct {
	ID            string               `json:"id"`
	PatchUser     *UpdateUserPatch     `json:"patchUser"`
	PatchCustomer *UpdateCustomerPatch `json:"patchCustomer"`
}

type UpdateCustomerPatch struct {
	Note               *string `json:"note"`
	AllowReviewSharing *bool   `json:"allowReviewSharing"`
}

type UpdateCustomerPayload struct {
	Customer *prisma.Customer `json:"customer"`
}

type UpdateEmailTemplateInput struct {
	ID    string                    `json:"id"`
	Patch *UpdateEmailTemplatePatch `json:"patch"`
}

type UpdateEmailTemplatePatch struct {
	Title   *string `json:"title"`
	Content *string `json:"content"`
}

type UpdateEmailTemplatePayload struct {
	Template *prisma.EmailTemplate `json:"template"`
}

type UpdateEmployeeInput struct {
	ID            string               `json:"id"`
	Patch         *UpdateUserPatch     `json:"patch"`
	PatchEmployee *UpdateEmployeePatch `json:"patchEmployee"`
}

type UpdateEmployeePatch struct {
	WorkingHours []*WorkingHoursInput `json:"workingHours"`
}

type UpdateEmployeePayload struct {
	Employee *prisma.Employee `json:"employee"`
}

type UpdateManagerInput struct {
	ID           string              `json:"id"`
	Patch        *UpdateUserPatch    `json:"patch"`
	PatchManager *UpdateManagerPatch `json:"patchManager"`
}

type UpdateManagerPatch struct {
	WorkingHours []*WorkingHoursInput `json:"workingHours"`
}

type UpdateManagerPayload struct {
	Manager *prisma.Manager `json:"manager"`
}

type UpdateNewsInput struct {
	ID    string           `json:"id"`
	Patch *UpdateNewsPatch `json:"patch"`
}

type UpdateNewsPatch struct {
	Title *string         `json:"title"`
	Image *graphql.Upload `json:"image"`
}

type UpdateNewsPayload struct {
	News *prisma.News `json:"news"`
}

type UpdateNotificationTokenInput struct {
	Token string `json:"token"`
}

type UpdateProductCategoryData struct {
	Name *string `json:"name"`
}

type UpdateProductCategoryInput struct {
	ID    string                     `json:"id"`
	Patch *UpdateProductCategoryData `json:"patch"`
}

type UpdateProductCategoryPayload struct {
	Category *prisma.ProductCategory `json:"category"`
}

type UpdateProductInput struct {
	ID    string              `json:"id"`
	Patch *UpdateProductPatch `json:"patch"`
}

type UpdateProductPatch struct {
	Name             *string                         `json:"name"`
	Desc             *string                         `json:"desc"`
	Price            *float64                        `json:"price"`
	Capacity         *string                         `json:"capacity"`
	Category         *string                         `json:"category"`
	SubCategory      *string                         `json:"subCategory"`
	Image            *graphql.Upload                 `json:"image"`
	Attributes       []*ProductServiceAttributeInput `json:"attributes"`
	RemoveAttributes []string                        `json:"removeAttributes"`
}

type UpdateProductPayload struct {
	Product *prisma.Product `json:"product"`
}

type UpdateProductSubCategoryData struct {
	Name *string `json:"name"`
}

type UpdateProductSubCategoryInput struct {
	ID    string                        `json:"id"`
	Patch *UpdateProductSubCategoryData `json:"patch"`
}

type UpdateProductSubCategoryPayload struct {
	SubCategory *prisma.ProductSubCategory `json:"subCategory"`
}

type UpdateReviewPatch struct {
	Stars  *float64             `json:"stars"`
	Title  *string              `json:"title"`
	Text   *string              `json:"text"`
	Status *prisma.ReviewStatus `json:"status"`
}

type UpdateServiceCategoryData struct {
	Name *string `json:"name"`
}

type UpdateServiceCategoryInput struct {
	ID    string                     `json:"id"`
	Patch *UpdateServiceCategoryData `json:"patch"`
}

type UpdateServiceCategoryPayload struct {
	Category *prisma.ServiceCategory `json:"category"`
}

type UpdateServiceInput struct {
	ID    string              `json:"id"`
	Patch *UpdateServicePatch `json:"patch"`
}

type UpdateServicePatch struct {
	Name  *string  `json:"name"`
	Desc  *string  `json:"desc"`
	Price *float64 `json:"price"`
	// The duration of this service in minutes.
	Duration         *int                            `json:"duration"`
	GenderTarget     *prisma.GenderTarget            `json:"genderTarget"`
	Category         *string                         `json:"category"`
	Subcategory      *string                         `json:"subcategory"`
	Image            *graphql.Upload                 `json:"image"`
	Attributes       []*ProductServiceAttributeInput `json:"attributes"`
	RemoveAttributes []string                        `json:"removeAttributes"`
}

type UpdateServicePayload struct {
	Service *prisma.Service `json:"service"`
}

type UpdateServiceSubCategoryData struct {
	Name *string `json:"name"`
}

type UpdateServiceSubCategoryInput struct {
	ID    string                        `json:"id"`
	Patch *UpdateServiceSubCategoryData `json:"patch"`
}

type UpdateServiceSubCategoryPayload struct {
	SubCategory *prisma.ServiceSubCategory `json:"subCategory"`
}

type UpdateUserPatch struct {
	Email       *string        `json:"email"`
	FirstName   *string        `json:"firstName"`
	LastName    *string        `json:"lastName"`
	Gender      *prisma.Gender `json:"gender"`
	PhoneNumber *string        `json:"phoneNumber"`
	ZipCode     *string        `json:"zipCode"`
	Street      *string        `json:"street"`
	City        *string        `json:"city"`
	Birthday    *string        `json:"birthday"`
}

type UpdateViewerInput struct {
	Patch              *UpdateUserPatch `json:"patch"`
	AllowReviewSharing *bool            `json:"allowReviewSharing"`
	Password           *string          `json:"password"`
}

type UpdateViewerPayload struct {
	User prisma.IUser `json:"user"`
}

type UploadViewerProfilePicturePayload struct {
	Image *Image       `json:"image"`
	User  prisma.IUser `json:"user"`
}

type UpsertBranchOpeningHourInput struct {
	// The branch which should be updated.
	Branch string                        `json:"branch"`
	Patch  *UpsertBranchOpeningHourPatch `json:"patch"`
}

type UpsertBranchOpeningHourPatch struct {
	Day       prisma.DayOfWeek `json:"day"`
	Closed    bool             `json:"closed"`
	Break     bool             `json:"break"`
	Forenoon  *TimerangeInput  `json:"forenoon"`
	Afternoon *TimerangeInput  `json:"afternoon"`
}

type UpsertBranchOpeningHourPayload struct {
	Branch *prisma.Branch `json:"branch"`
}

type UpsertReviewInput struct {
	Appointment *string            `json:"appointment"`
	Product     *string            `json:"product"`
	Service     *string            `json:"service"`
	Review      *string            `json:"review"`
	Data        *UpdateReviewPatch `json:"data"`
}

type UpsertReviewPayload struct {
	Review prisma.IReview `json:"review"`
}

// A wrapper for working hours.
type WorkingHours struct {
	Formatted []*FormattedWorkingHours `json:"formatted"`
	Raw       []*RawWorkingHours       `json:"raw"`
}

type WorkingHoursInput struct {
	Day        prisma.DayOfWeek `json:"day"`
	NotWorking bool             `json:"notWorking"`
	Break      bool             `json:"break"`
	Forenoon   *TimerangeInput  `json:"forenoon"`
	Afternoon  *TimerangeInput  `json:"afternoon"`
}

type AppointmentOrderByFields string

const (
	AppointmentOrderByFieldsCreatedAt AppointmentOrderByFields = "createdAt"
	AppointmentOrderByFieldsUpdatedAt AppointmentOrderByFields = "updatedAt"
	AppointmentOrderByFieldsStart     AppointmentOrderByFields = "start"
	AppointmentOrderByFieldsPrice     AppointmentOrderByFields = "price"
	AppointmentOrderByFieldsStatus    AppointmentOrderByFields = "status"
)

var AllAppointmentOrderByFields = []AppointmentOrderByFields{
	AppointmentOrderByFieldsCreatedAt,
	AppointmentOrderByFieldsUpdatedAt,
	AppointmentOrderByFieldsStart,
	AppointmentOrderByFieldsPrice,
	AppointmentOrderByFieldsStatus,
}

func (e AppointmentOrderByFields) IsValid() bool {
	switch e {
	case AppointmentOrderByFieldsCreatedAt, AppointmentOrderByFieldsUpdatedAt, AppointmentOrderByFieldsStart, AppointmentOrderByFieldsPrice, AppointmentOrderByFieldsStatus:
		return true
	}
	return false
}

func (e AppointmentOrderByFields) String() string {
	return string(e)
}

func (e *AppointmentOrderByFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppointmentOrderByFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AppointmentOrderByFields", str)
	}
	return nil
}

func (e AppointmentOrderByFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AvailabilityStatus string

const (
	AvailabilityStatusAvailable   AvailabilityStatus = "AVAILABLE"
	AvailabilityStatusBooked      AvailabilityStatus = "BOOKED"
	AvailabilityStatusBreak       AvailabilityStatus = "BREAK"
	AvailabilityStatusHoliday     AvailabilityStatus = "HOLIDAY"
	AvailabilityStatusUnavailable AvailabilityStatus = "UNAVAILABLE"
)

var AllAvailabilityStatus = []AvailabilityStatus{
	AvailabilityStatusAvailable,
	AvailabilityStatusBooked,
	AvailabilityStatusBreak,
	AvailabilityStatusHoliday,
	AvailabilityStatusUnavailable,
}

func (e AvailabilityStatus) IsValid() bool {
	switch e {
	case AvailabilityStatusAvailable, AvailabilityStatusBooked, AvailabilityStatusBreak, AvailabilityStatusHoliday, AvailabilityStatusUnavailable:
		return true
	}
	return false
}

func (e AvailabilityStatus) String() string {
	return string(e)
}

func (e *AvailabilityStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AvailabilityStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AvailabilityStatus", str)
	}
	return nil
}

func (e AvailabilityStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sub Categories Are Dynamic
type CategoryEnum string

const (
	CategoryEnumMale     CategoryEnum = "MALE"
	CategoryEnumFemale   CategoryEnum = "FEMALE"
	CategoryEnumChildren CategoryEnum = "CHILDREN"
	CategoryEnumAny      CategoryEnum = "ANY"
)

var AllCategoryEnum = []CategoryEnum{
	CategoryEnumMale,
	CategoryEnumFemale,
	CategoryEnumChildren,
	CategoryEnumAny,
}

func (e CategoryEnum) IsValid() bool {
	switch e {
	case CategoryEnumMale, CategoryEnumFemale, CategoryEnumChildren, CategoryEnumAny:
		return true
	}
	return false
}

func (e CategoryEnum) String() string {
	return string(e)
}

func (e *CategoryEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategoryEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategoryEnum", str)
	}
	return nil
}

func (e CategoryEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CustomerOrderByFields string

const (
	CustomerOrderByFieldsCreatedAt CustomerOrderByFields = "createdAt"
	CustomerOrderByFieldsUpdatedAt CustomerOrderByFields = "updatedAt"
	CustomerOrderByFieldsFirstName CustomerOrderByFields = "firstName"
	CustomerOrderByFieldsLastName  CustomerOrderByFields = "lastName"
	CustomerOrderByFieldsGender    CustomerOrderByFields = "gender"
	CustomerOrderByFieldsBirthday  CustomerOrderByFields = "birthday"
	CustomerOrderByFieldsCity      CustomerOrderByFields = "city"
	CustomerOrderByFieldsZipCode   CustomerOrderByFields = "zipCode"
)

var AllCustomerOrderByFields = []CustomerOrderByFields{
	CustomerOrderByFieldsCreatedAt,
	CustomerOrderByFieldsUpdatedAt,
	CustomerOrderByFieldsFirstName,
	CustomerOrderByFieldsLastName,
	CustomerOrderByFieldsGender,
	CustomerOrderByFieldsBirthday,
	CustomerOrderByFieldsCity,
	CustomerOrderByFieldsZipCode,
}

func (e CustomerOrderByFields) IsValid() bool {
	switch e {
	case CustomerOrderByFieldsCreatedAt, CustomerOrderByFieldsUpdatedAt, CustomerOrderByFieldsFirstName, CustomerOrderByFieldsLastName, CustomerOrderByFieldsGender, CustomerOrderByFieldsBirthday, CustomerOrderByFieldsCity, CustomerOrderByFieldsZipCode:
		return true
	}
	return false
}

func (e CustomerOrderByFields) String() string {
	return string(e)
}

func (e *CustomerOrderByFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomerOrderByFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomerOrderByFields", str)
	}
	return nil
}

func (e CustomerOrderByFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order nodes by a given direction.
type OrderByDirectionInput string

const (
	// Ascending.
	// For example: `1, 2, 3, 4`.
	// Date example: `yesterday, today, tomorrow`.
	OrderByDirectionInputAsc OrderByDirectionInput = "ASC"
	// Descending.
	// For example: `4, 3, 2, 1`.
	// Date example: `today, yesterday, 2 days ago, 3 days ago`.
	OrderByDirectionInputDesc OrderByDirectionInput = "DESC"
)

var AllOrderByDirectionInput = []OrderByDirectionInput{
	OrderByDirectionInputAsc,
	OrderByDirectionInputDesc,
}

func (e OrderByDirectionInput) IsValid() bool {
	switch e {
	case OrderByDirectionInputAsc, OrderByDirectionInputDesc:
		return true
	}
	return false
}

func (e OrderByDirectionInput) String() string {
	return string(e)
}

func (e *OrderByDirectionInput) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderByDirectionInput(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderByDirectionInput", str)
	}
	return nil
}

func (e OrderByDirectionInput) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductOrderByFields string

const (
	ProductOrderByFieldsCreatedAt ProductOrderByFields = "createdAt"
	ProductOrderByFieldsUpdatedAt ProductOrderByFields = "updatedAt"
	ProductOrderByFieldsName      ProductOrderByFields = "name"
	ProductOrderByFieldsPrice     ProductOrderByFields = "price"
)

var AllProductOrderByFields = []ProductOrderByFields{
	ProductOrderByFieldsCreatedAt,
	ProductOrderByFieldsUpdatedAt,
	ProductOrderByFieldsName,
	ProductOrderByFieldsPrice,
}

func (e ProductOrderByFields) IsValid() bool {
	switch e {
	case ProductOrderByFieldsCreatedAt, ProductOrderByFieldsUpdatedAt, ProductOrderByFieldsName, ProductOrderByFieldsPrice:
		return true
	}
	return false
}

func (e ProductOrderByFields) String() string {
	return string(e)
}

func (e *ProductOrderByFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductOrderByFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductOrderByFields", str)
	}
	return nil
}

func (e ProductOrderByFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReviewOrderByFields string

const (
	ReviewOrderByFieldsCreatedAt ReviewOrderByFields = "createdAt"
	ReviewOrderByFieldsUpdatedAt ReviewOrderByFields = "updatedAt"
	ReviewOrderByFieldsStars     ReviewOrderByFields = "stars"
	ReviewOrderByFieldsTitle     ReviewOrderByFields = "title"
)

var AllReviewOrderByFields = []ReviewOrderByFields{
	ReviewOrderByFieldsCreatedAt,
	ReviewOrderByFieldsUpdatedAt,
	ReviewOrderByFieldsStars,
	ReviewOrderByFieldsTitle,
}

func (e ReviewOrderByFields) IsValid() bool {
	switch e {
	case ReviewOrderByFieldsCreatedAt, ReviewOrderByFieldsUpdatedAt, ReviewOrderByFieldsStars, ReviewOrderByFieldsTitle:
		return true
	}
	return false
}

func (e ReviewOrderByFields) String() string {
	return string(e)
}

func (e *ReviewOrderByFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReviewOrderByFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReviewOrderByFields", str)
	}
	return nil
}

func (e ReviewOrderByFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceOrderByFields string

const (
	ServiceOrderByFieldsCreatedAt    ServiceOrderByFields = "createdAt"
	ServiceOrderByFieldsUpdatedAt    ServiceOrderByFields = "updatedAt"
	ServiceOrderByFieldsName         ServiceOrderByFields = "name"
	ServiceOrderByFieldsGenderTarget ServiceOrderByFields = "genderTarget"
	ServiceOrderByFieldsPrice        ServiceOrderByFields = "price"
)

var AllServiceOrderByFields = []ServiceOrderByFields{
	ServiceOrderByFieldsCreatedAt,
	ServiceOrderByFieldsUpdatedAt,
	ServiceOrderByFieldsName,
	ServiceOrderByFieldsGenderTarget,
	ServiceOrderByFieldsPrice,
}

func (e ServiceOrderByFields) IsValid() bool {
	switch e {
	case ServiceOrderByFieldsCreatedAt, ServiceOrderByFieldsUpdatedAt, ServiceOrderByFieldsName, ServiceOrderByFieldsGenderTarget, ServiceOrderByFieldsPrice:
		return true
	}
	return false
}

func (e ServiceOrderByFields) String() string {
	return string(e)
}

func (e *ServiceOrderByFields) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceOrderByFields(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceOrderByFields", str)
	}
	return nil
}

func (e ServiceOrderByFields) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
