// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466/keskin/dev"
var Secret = ""

func (client *Client) Alias(params AliasWhereUniqueInput) *AliasExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AliasWhereUniqueInput!", "Alias"},
		"alias",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

type AliasesParams struct {
	Where   *AliasWhereInput   `json:"where,omitempty"`
	OrderBy *AliasOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Aliases(params *AliasesParams) *AliasExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AliasWhereInput", "AliasOrderByInput", "Alias"},
		"aliases",
		[]string{"id", "value"})

	return &AliasExecArray{ret}
}

type AliasesConnectionParams struct {
	Where   *AliasWhereInput   `json:"where,omitempty"`
	OrderBy *AliasOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AliasConnection) Nodes() []Alias {
	var nodes []Alias
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AliasConnection) NodesPtr() []*Alias {
	var nodes []*Alias
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AliasesConnection(params *AliasesConnectionParams) *AliasConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AliasWhereInput", "AliasOrderByInput", "Alias"},
		"aliasesConnection",
		[]string{"edges", "pageInfo"})

	return &AliasConnectionExec{ret}
}

func (client *Client) Appointment(params AppointmentWhereUniqueInput) *AppointmentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AppointmentWhereUniqueInput!", "Appointment"},
		"appointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

type AppointmentsParams struct {
	Where   *AppointmentWhereInput   `json:"where,omitempty"`
	OrderBy *AppointmentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) Appointments(params *AppointmentsParams) *AppointmentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppointmentWhereInput", "AppointmentOrderByInput", "Appointment"},
		"appointments",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExecArray{ret}
}

type AppointmentsConnectionParams struct {
	Where   *AppointmentWhereInput   `json:"where,omitempty"`
	OrderBy *AppointmentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AppointmentConnection) Nodes() []Appointment {
	var nodes []Appointment
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AppointmentConnection) NodesPtr() []*Appointment {
	var nodes []*Appointment
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AppointmentsConnection(params *AppointmentsConnectionParams) *AppointmentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppointmentWhereInput", "AppointmentOrderByInput", "Appointment"},
		"appointmentsConnection",
		[]string{"edges", "pageInfo"})

	return &AppointmentConnectionExec{ret}
}

func (client *Client) AppointmentProductLink(params AppointmentProductLinkWhereUniqueInput) *AppointmentProductLinkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AppointmentProductLinkWhereUniqueInput!", "AppointmentProductLink"},
		"appointmentProductLink",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

type AppointmentProductLinksParams struct {
	Where   *AppointmentProductLinkWhereInput   `json:"where,omitempty"`
	OrderBy *AppointmentProductLinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) AppointmentProductLinks(params *AppointmentProductLinksParams) *AppointmentProductLinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppointmentProductLinkWhereInput", "AppointmentProductLinkOrderByInput", "AppointmentProductLink"},
		"appointmentProductLinks",
		[]string{"id", "count"})

	return &AppointmentProductLinkExecArray{ret}
}

type AppointmentProductLinksConnectionParams struct {
	Where   *AppointmentProductLinkWhereInput   `json:"where,omitempty"`
	OrderBy *AppointmentProductLinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AppointmentProductLinkConnection) Nodes() []AppointmentProductLink {
	var nodes []AppointmentProductLink
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AppointmentProductLinkConnection) NodesPtr() []*AppointmentProductLink {
	var nodes []*AppointmentProductLink
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AppointmentProductLinksConnection(params *AppointmentProductLinksConnectionParams) *AppointmentProductLinkConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppointmentProductLinkWhereInput", "AppointmentProductLinkOrderByInput", "AppointmentProductLink"},
		"appointmentProductLinksConnection",
		[]string{"edges", "pageInfo"})

	return &AppointmentProductLinkConnectionExec{ret}
}

func (client *Client) AppointmentServiceLink(params AppointmentServiceLinkWhereUniqueInput) *AppointmentServiceLinkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AppointmentServiceLinkWhereUniqueInput!", "AppointmentServiceLink"},
		"appointmentServiceLink",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

type AppointmentServiceLinksParams struct {
	Where   *AppointmentServiceLinkWhereInput   `json:"where,omitempty"`
	OrderBy *AppointmentServiceLinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) AppointmentServiceLinks(params *AppointmentServiceLinksParams) *AppointmentServiceLinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppointmentServiceLinkWhereInput", "AppointmentServiceLinkOrderByInput", "AppointmentServiceLink"},
		"appointmentServiceLinks",
		[]string{"id"})

	return &AppointmentServiceLinkExecArray{ret}
}

type AppointmentServiceLinksConnectionParams struct {
	Where   *AppointmentServiceLinkWhereInput   `json:"where,omitempty"`
	OrderBy *AppointmentServiceLinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AppointmentServiceLinkConnection) Nodes() []AppointmentServiceLink {
	var nodes []AppointmentServiceLink
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AppointmentServiceLinkConnection) NodesPtr() []*AppointmentServiceLink {
	var nodes []*AppointmentServiceLink
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AppointmentServiceLinksConnection(params *AppointmentServiceLinksConnectionParams) *AppointmentServiceLinkConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppointmentServiceLinkWhereInput", "AppointmentServiceLinkOrderByInput", "AppointmentServiceLink"},
		"appointmentServiceLinksConnection",
		[]string{"edges", "pageInfo"})

	return &AppointmentServiceLinkConnectionExec{ret}
}

func (client *Client) Branch(params BranchWhereUniqueInput) *BranchExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BranchWhereUniqueInput!", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

type BranchesParams struct {
	Where   *BranchWhereInput   `json:"where,omitempty"`
	OrderBy *BranchOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Branches(params *BranchesParams) *BranchExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BranchWhereInput", "BranchOrderByInput", "Branch"},
		"branches",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExecArray{ret}
}

type BranchesConnectionParams struct {
	Where   *BranchWhereInput   `json:"where,omitempty"`
	OrderBy *BranchOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BranchConnection) Nodes() []Branch {
	var nodes []Branch
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BranchConnection) NodesPtr() []*Branch {
	var nodes []*Branch
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BranchesConnection(params *BranchesConnectionParams) *BranchConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BranchWhereInput", "BranchOrderByInput", "Branch"},
		"branchesConnection",
		[]string{"edges", "pageInfo"})

	return &BranchConnectionExec{ret}
}

func (client *Client) BranchImageSlot(params BranchImageSlotWhereUniqueInput) *BranchImageSlotExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BranchImageSlotWhereUniqueInput!", "BranchImageSlot"},
		"branchImageSlot",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

type BranchImageSlotsParams struct {
	Where   *BranchImageSlotWhereInput   `json:"where,omitempty"`
	OrderBy *BranchImageSlotOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) BranchImageSlots(params *BranchImageSlotsParams) *BranchImageSlotExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BranchImageSlotWhereInput", "BranchImageSlotOrderByInput", "BranchImageSlot"},
		"branchImageSlots",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExecArray{ret}
}

type BranchImageSlotsConnectionParams struct {
	Where   *BranchImageSlotWhereInput   `json:"where,omitempty"`
	OrderBy *BranchImageSlotOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BranchImageSlotConnection) Nodes() []BranchImageSlot {
	var nodes []BranchImageSlot
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BranchImageSlotConnection) NodesPtr() []*BranchImageSlot {
	var nodes []*BranchImageSlot
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BranchImageSlotsConnection(params *BranchImageSlotsConnectionParams) *BranchImageSlotConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BranchImageSlotWhereInput", "BranchImageSlotOrderByInput", "BranchImageSlot"},
		"branchImageSlotsConnection",
		[]string{"edges", "pageInfo"})

	return &BranchImageSlotConnectionExec{ret}
}

func (client *Client) BranchOpeningHour(params BranchOpeningHourWhereUniqueInput) *BranchOpeningHourExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BranchOpeningHourWhereUniqueInput!", "BranchOpeningHour"},
		"branchOpeningHour",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

type BranchOpeningHoursParams struct {
	Where   *BranchOpeningHourWhereInput   `json:"where,omitempty"`
	OrderBy *BranchOpeningHourOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) BranchOpeningHours(params *BranchOpeningHoursParams) *BranchOpeningHourExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BranchOpeningHourWhereInput", "BranchOpeningHourOrderByInput", "BranchOpeningHour"},
		"branchOpeningHours",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExecArray{ret}
}

type BranchOpeningHoursConnectionParams struct {
	Where   *BranchOpeningHourWhereInput   `json:"where,omitempty"`
	OrderBy *BranchOpeningHourOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BranchOpeningHourConnection) Nodes() []BranchOpeningHour {
	var nodes []BranchOpeningHour
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BranchOpeningHourConnection) NodesPtr() []*BranchOpeningHour {
	var nodes []*BranchOpeningHour
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BranchOpeningHoursConnection(params *BranchOpeningHoursConnectionParams) *BranchOpeningHourConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BranchOpeningHourWhereInput", "BranchOpeningHourOrderByInput", "BranchOpeningHour"},
		"branchOpeningHoursConnection",
		[]string{"edges", "pageInfo"})

	return &BranchOpeningHourConnectionExec{ret}
}

func (client *Client) Company(params CompanyWhereUniqueInput) *CompanyExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CompanyWhereUniqueInput!", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

type CompaniesParams struct {
	Where   *CompanyWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Companies(params *CompaniesParams) *CompanyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyWhereInput", "CompanyOrderByInput", "Company"},
		"companies",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExecArray{ret}
}

type CompaniesConnectionParams struct {
	Where   *CompanyWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CompanyConnection) Nodes() []Company {
	var nodes []Company
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CompanyConnection) NodesPtr() []*Company {
	var nodes []*Company
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CompaniesConnection(params *CompaniesConnectionParams) *CompanyConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyWhereInput", "CompanyOrderByInput", "Company"},
		"companiesConnection",
		[]string{"edges", "pageInfo"})

	return &CompanyConnectionExec{ret}
}

func (client *Client) CustomUrl(params CustomUrlWhereUniqueInput) *CustomUrlExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CustomUrlWhereUniqueInput!", "CustomUrl"},
		"customUrl",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

type CustomUrlsParams struct {
	Where   *CustomUrlWhereInput   `json:"where,omitempty"`
	OrderBy *CustomUrlOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) CustomUrls(params *CustomUrlsParams) *CustomUrlExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CustomUrlWhereInput", "CustomUrlOrderByInput", "CustomUrl"},
		"customUrls",
		[]string{"id", "value"})

	return &CustomUrlExecArray{ret}
}

type CustomUrlsConnectionParams struct {
	Where   *CustomUrlWhereInput   `json:"where,omitempty"`
	OrderBy *CustomUrlOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CustomUrlConnection) Nodes() []CustomUrl {
	var nodes []CustomUrl
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CustomUrlConnection) NodesPtr() []*CustomUrl {
	var nodes []*CustomUrl
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CustomUrlsConnection(params *CustomUrlsConnectionParams) *CustomUrlConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CustomUrlWhereInput", "CustomUrlOrderByInput", "CustomUrl"},
		"customUrlsConnection",
		[]string{"edges", "pageInfo"})

	return &CustomUrlConnectionExec{ret}
}

func (client *Client) EmailTemplate(params EmailTemplateWhereUniqueInput) *EmailTemplateExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EmailTemplateWhereUniqueInput!", "EmailTemplate"},
		"emailTemplate",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

type EmailTemplatesParams struct {
	Where   *EmailTemplateWhereInput   `json:"where,omitempty"`
	OrderBy *EmailTemplateOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) EmailTemplates(params *EmailTemplatesParams) *EmailTemplateExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailTemplateWhereInput", "EmailTemplateOrderByInput", "EmailTemplate"},
		"emailTemplates",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExecArray{ret}
}

type EmailTemplatesConnectionParams struct {
	Where   *EmailTemplateWhereInput   `json:"where,omitempty"`
	OrderBy *EmailTemplateOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *EmailTemplateConnection) Nodes() []EmailTemplate {
	var nodes []EmailTemplate
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *EmailTemplateConnection) NodesPtr() []*EmailTemplate {
	var nodes []*EmailTemplate
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) EmailTemplatesConnection(params *EmailTemplatesConnectionParams) *EmailTemplateConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailTemplateWhereInput", "EmailTemplateOrderByInput", "EmailTemplate"},
		"emailTemplatesConnection",
		[]string{"edges", "pageInfo"})

	return &EmailTemplateConnectionExec{ret}
}

func (client *Client) Favorite(params FavoriteWhereUniqueInput) *FavoriteExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FavoriteWhereUniqueInput!", "Favorite"},
		"favorite",
		[]string{"id"})

	return &FavoriteExec{ret}
}

type FavoritesParams struct {
	Where   *FavoriteWhereInput   `json:"where,omitempty"`
	OrderBy *FavoriteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Favorites(params *FavoritesParams) *FavoriteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FavoriteWhereInput", "FavoriteOrderByInput", "Favorite"},
		"favorites",
		[]string{"id"})

	return &FavoriteExecArray{ret}
}

type FavoritesConnectionParams struct {
	Where   *FavoriteWhereInput   `json:"where,omitempty"`
	OrderBy *FavoriteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *FavoriteConnection) Nodes() []Favorite {
	var nodes []Favorite
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *FavoriteConnection) NodesPtr() []*Favorite {
	var nodes []*Favorite
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) FavoritesConnection(params *FavoritesConnectionParams) *FavoriteConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FavoriteWhereInput", "FavoriteOrderByInput", "Favorite"},
		"favoritesConnection",
		[]string{"edges", "pageInfo"})

	return &FavoriteConnectionExec{ret}
}

func (client *Client) LocalizedString(params LocalizedStringWhereUniqueInput) *LocalizedStringExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LocalizedStringWhereUniqueInput!", "LocalizedString"},
		"localizedString",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

type LocalizedStringsParams struct {
	Where   *LocalizedStringWhereInput   `json:"where,omitempty"`
	OrderBy *LocalizedStringOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) LocalizedStrings(params *LocalizedStringsParams) *LocalizedStringExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LocalizedStringWhereInput", "LocalizedStringOrderByInput", "LocalizedString"},
		"localizedStrings",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExecArray{ret}
}

type LocalizedStringsConnectionParams struct {
	Where   *LocalizedStringWhereInput   `json:"where,omitempty"`
	OrderBy *LocalizedStringOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *LocalizedStringConnection) Nodes() []LocalizedString {
	var nodes []LocalizedString
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *LocalizedStringConnection) NodesPtr() []*LocalizedString {
	var nodes []*LocalizedString
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) LocalizedStringsConnection(params *LocalizedStringsConnectionParams) *LocalizedStringConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LocalizedStringWhereInput", "LocalizedStringOrderByInput", "LocalizedString"},
		"localizedStringsConnection",
		[]string{"edges", "pageInfo"})

	return &LocalizedStringConnectionExec{ret}
}

func (client *Client) News(params NewsWhereUniqueInput) *NewsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"NewsWhereUniqueInput!", "News"},
		"news",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

type NewsesParams struct {
	Where   *NewsWhereInput   `json:"where,omitempty"`
	OrderBy *NewsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Newses(params *NewsesParams) *NewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NewsWhereInput", "NewsOrderByInput", "News"},
		"newses",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExecArray{ret}
}

type NewsesConnectionParams struct {
	Where   *NewsWhereInput   `json:"where,omitempty"`
	OrderBy *NewsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *NewsConnection) Nodes() []News {
	var nodes []News
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *NewsConnection) NodesPtr() []*News {
	var nodes []*News
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) NewsesConnection(params *NewsesConnectionParams) *NewsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NewsWhereInput", "NewsOrderByInput", "News"},
		"newsesConnection",
		[]string{"edges", "pageInfo"})

	return &NewsConnectionExec{ret}
}

func (client *Client) PasswordToken(params PasswordTokenWhereUniqueInput) *PasswordTokenExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PasswordTokenWhereUniqueInput!", "PasswordToken"},
		"passwordToken",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

type PasswordTokensParams struct {
	Where   *PasswordTokenWhereInput   `json:"where,omitempty"`
	OrderBy *PasswordTokenOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PasswordTokens(params *PasswordTokensParams) *PasswordTokenExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PasswordTokenWhereInput", "PasswordTokenOrderByInput", "PasswordToken"},
		"passwordTokens",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExecArray{ret}
}

type PasswordTokensConnectionParams struct {
	Where   *PasswordTokenWhereInput   `json:"where,omitempty"`
	OrderBy *PasswordTokenOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PasswordTokenConnection) Nodes() []PasswordToken {
	var nodes []PasswordToken
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PasswordTokenConnection) NodesPtr() []*PasswordToken {
	var nodes []*PasswordToken
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PasswordTokensConnection(params *PasswordTokensConnectionParams) *PasswordTokenConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PasswordTokenWhereInput", "PasswordTokenOrderByInput", "PasswordToken"},
		"passwordTokensConnection",
		[]string{"edges", "pageInfo"})

	return &PasswordTokenConnectionExec{ret}
}

func (client *Client) Product(params ProductWhereUniqueInput) *ProductExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProductWhereUniqueInput!", "Product"},
		"product",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

type ProductsParams struct {
	Where   *ProductWhereInput   `json:"where,omitempty"`
	OrderBy *ProductOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Products(params *ProductsParams) *ProductExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "Product"},
		"products",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExecArray{ret}
}

type ProductsConnectionParams struct {
	Where   *ProductWhereInput   `json:"where,omitempty"`
	OrderBy *ProductOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ProductConnection) Nodes() []Product {
	var nodes []Product
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ProductConnection) NodesPtr() []*Product {
	var nodes []*Product
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ProductsConnection(params *ProductsConnectionParams) *ProductConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "Product"},
		"productsConnection",
		[]string{"edges", "pageInfo"})

	return &ProductConnectionExec{ret}
}

func (client *Client) ProductCategory(params ProductCategoryWhereUniqueInput) *ProductCategoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProductCategoryWhereUniqueInput!", "ProductCategory"},
		"productCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

type ProductCategoriesParams struct {
	Where   *ProductCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ProductCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) ProductCategories(params *ProductCategoriesParams) *ProductCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductCategoryWhereInput", "ProductCategoryOrderByInput", "ProductCategory"},
		"productCategories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExecArray{ret}
}

type ProductCategoriesConnectionParams struct {
	Where   *ProductCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ProductCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ProductCategoryConnection) Nodes() []ProductCategory {
	var nodes []ProductCategory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ProductCategoryConnection) NodesPtr() []*ProductCategory {
	var nodes []*ProductCategory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ProductCategoriesConnection(params *ProductCategoriesConnectionParams) *ProductCategoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductCategoryWhereInput", "ProductCategoryOrderByInput", "ProductCategory"},
		"productCategoriesConnection",
		[]string{"edges", "pageInfo"})

	return &ProductCategoryConnectionExec{ret}
}

func (client *Client) ProductServiceAttribute(params ProductServiceAttributeWhereUniqueInput) *ProductServiceAttributeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProductServiceAttributeWhereUniqueInput!", "ProductServiceAttribute"},
		"productServiceAttribute",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

type ProductServiceAttributesParams struct {
	Where   *ProductServiceAttributeWhereInput   `json:"where,omitempty"`
	OrderBy *ProductServiceAttributeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

func (client *Client) ProductServiceAttributes(params *ProductServiceAttributesParams) *ProductServiceAttributeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductServiceAttributeWhereInput", "ProductServiceAttributeOrderByInput", "ProductServiceAttribute"},
		"productServiceAttributes",
		[]string{"id", "key"})

	return &ProductServiceAttributeExecArray{ret}
}

type ProductServiceAttributesConnectionParams struct {
	Where   *ProductServiceAttributeWhereInput   `json:"where,omitempty"`
	OrderBy *ProductServiceAttributeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ProductServiceAttributeConnection) Nodes() []ProductServiceAttribute {
	var nodes []ProductServiceAttribute
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ProductServiceAttributeConnection) NodesPtr() []*ProductServiceAttribute {
	var nodes []*ProductServiceAttribute
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ProductServiceAttributesConnection(params *ProductServiceAttributesConnectionParams) *ProductServiceAttributeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductServiceAttributeWhereInput", "ProductServiceAttributeOrderByInput", "ProductServiceAttribute"},
		"productServiceAttributesConnection",
		[]string{"edges", "pageInfo"})

	return &ProductServiceAttributeConnectionExec{ret}
}

func (client *Client) ProductSubCategory(params ProductSubCategoryWhereUniqueInput) *ProductSubCategoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProductSubCategoryWhereUniqueInput!", "ProductSubCategory"},
		"productSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

type ProductSubCategoriesParams struct {
	Where   *ProductSubCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ProductSubCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                          `json:"skip,omitempty"`
	After   *string                         `json:"after,omitempty"`
	Before  *string                         `json:"before,omitempty"`
	First   *int32                          `json:"first,omitempty"`
	Last    *int32                          `json:"last,omitempty"`
}

func (client *Client) ProductSubCategories(params *ProductSubCategoriesParams) *ProductSubCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductSubCategoryWhereInput", "ProductSubCategoryOrderByInput", "ProductSubCategory"},
		"productSubCategories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExecArray{ret}
}

type ProductSubCategoriesConnectionParams struct {
	Where   *ProductSubCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ProductSubCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                          `json:"skip,omitempty"`
	After   *string                         `json:"after,omitempty"`
	Before  *string                         `json:"before,omitempty"`
	First   *int32                          `json:"first,omitempty"`
	Last    *int32                          `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ProductSubCategoryConnection) Nodes() []ProductSubCategory {
	var nodes []ProductSubCategory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ProductSubCategoryConnection) NodesPtr() []*ProductSubCategory {
	var nodes []*ProductSubCategory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ProductSubCategoriesConnection(params *ProductSubCategoriesConnectionParams) *ProductSubCategoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductSubCategoryWhereInput", "ProductSubCategoryOrderByInput", "ProductSubCategory"},
		"productSubCategoriesConnection",
		[]string{"edges", "pageInfo"})

	return &ProductSubCategoryConnectionExec{ret}
}

func (client *Client) Review(params ReviewWhereUniqueInput) *ReviewExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewWhereUniqueInput!", "Review"},
		"review",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

type ReviewsParams struct {
	Where   *ReviewWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Reviews(params *ReviewsParams) *ReviewExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewWhereInput", "ReviewOrderByInput", "Review"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExecArray{ret}
}

type ReviewsConnectionParams struct {
	Where   *ReviewWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewConnection) Nodes() []Review {
	var nodes []Review
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewConnection) NodesPtr() []*Review {
	var nodes []*Review
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewsConnection(params *ReviewsConnectionParams) *ReviewConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewWhereInput", "ReviewOrderByInput", "Review"},
		"reviewsConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewConnectionExec{ret}
}

func (client *Client) Service(params ServiceWhereUniqueInput) *ServiceExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ServiceWhereUniqueInput!", "Service"},
		"service",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

type ServicesParams struct {
	Where   *ServiceWhereInput   `json:"where,omitempty"`
	OrderBy *ServiceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Services(params *ServicesParams) *ServiceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ServiceWhereInput", "ServiceOrderByInput", "Service"},
		"services",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExecArray{ret}
}

type ServicesConnectionParams struct {
	Where   *ServiceWhereInput   `json:"where,omitempty"`
	OrderBy *ServiceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ServiceConnection) Nodes() []Service {
	var nodes []Service
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ServiceConnection) NodesPtr() []*Service {
	var nodes []*Service
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ServicesConnection(params *ServicesConnectionParams) *ServiceConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ServiceWhereInput", "ServiceOrderByInput", "Service"},
		"servicesConnection",
		[]string{"edges", "pageInfo"})

	return &ServiceConnectionExec{ret}
}

func (client *Client) ServiceCategory(params ServiceCategoryWhereUniqueInput) *ServiceCategoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ServiceCategoryWhereUniqueInput!", "ServiceCategory"},
		"serviceCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

type ServiceCategoriesParams struct {
	Where   *ServiceCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ServiceCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) ServiceCategories(params *ServiceCategoriesParams) *ServiceCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ServiceCategoryWhereInput", "ServiceCategoryOrderByInput", "ServiceCategory"},
		"serviceCategories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExecArray{ret}
}

type ServiceCategoriesConnectionParams struct {
	Where   *ServiceCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ServiceCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ServiceCategoryConnection) Nodes() []ServiceCategory {
	var nodes []ServiceCategory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ServiceCategoryConnection) NodesPtr() []*ServiceCategory {
	var nodes []*ServiceCategory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ServiceCategoriesConnection(params *ServiceCategoriesConnectionParams) *ServiceCategoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ServiceCategoryWhereInput", "ServiceCategoryOrderByInput", "ServiceCategory"},
		"serviceCategoriesConnection",
		[]string{"edges", "pageInfo"})

	return &ServiceCategoryConnectionExec{ret}
}

func (client *Client) ServiceSubCategory(params ServiceSubCategoryWhereUniqueInput) *ServiceSubCategoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ServiceSubCategoryWhereUniqueInput!", "ServiceSubCategory"},
		"serviceSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

type ServiceSubCategoriesParams struct {
	Where   *ServiceSubCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ServiceSubCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                          `json:"skip,omitempty"`
	After   *string                         `json:"after,omitempty"`
	Before  *string                         `json:"before,omitempty"`
	First   *int32                          `json:"first,omitempty"`
	Last    *int32                          `json:"last,omitempty"`
}

func (client *Client) ServiceSubCategories(params *ServiceSubCategoriesParams) *ServiceSubCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ServiceSubCategoryWhereInput", "ServiceSubCategoryOrderByInput", "ServiceSubCategory"},
		"serviceSubCategories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExecArray{ret}
}

type ServiceSubCategoriesConnectionParams struct {
	Where   *ServiceSubCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ServiceSubCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                          `json:"skip,omitempty"`
	After   *string                         `json:"after,omitempty"`
	Before  *string                         `json:"before,omitempty"`
	First   *int32                          `json:"first,omitempty"`
	Last    *int32                          `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ServiceSubCategoryConnection) Nodes() []ServiceSubCategory {
	var nodes []ServiceSubCategory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ServiceSubCategoryConnection) NodesPtr() []*ServiceSubCategory {
	var nodes []*ServiceSubCategory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ServiceSubCategoriesConnection(params *ServiceSubCategoriesConnectionParams) *ServiceSubCategoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ServiceSubCategoryWhereInput", "ServiceSubCategoryOrderByInput", "ServiceSubCategory"},
		"serviceSubCategoriesConnection",
		[]string{"edges", "pageInfo"})

	return &ServiceSubCategoryConnectionExec{ret}
}

func (client *Client) Session(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"session",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

type SessionsParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Sessions(params *SessionsParams) *SessionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessions",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExecArray{ret}
}

type SessionsConnectionParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *SessionConnection) Nodes() []Session {
	var nodes []Session
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *SessionConnection) NodesPtr() []*Session {
	var nodes []*Session
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) SessionsConnection(params *SessionsConnectionParams) *SessionConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessionsConnection",
		[]string{"edges", "pageInfo"})

	return &SessionConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) WorkingHours(params WorkingHoursWhereUniqueInput) *WorkingHoursExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WorkingHoursWhereUniqueInput!", "WorkingHours"},
		"workingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

type WorkingHoursesParams struct {
	Where   *WorkingHoursWhereInput   `json:"where,omitempty"`
	OrderBy *WorkingHoursOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) WorkingHourses(params *WorkingHoursesParams) *WorkingHoursExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkingHoursWhereInput", "WorkingHoursOrderByInput", "WorkingHours"},
		"workingHourses",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExecArray{ret}
}

type WorkingHoursesConnectionParams struct {
	Where   *WorkingHoursWhereInput   `json:"where,omitempty"`
	OrderBy *WorkingHoursOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *WorkingHoursConnection) Nodes() []WorkingHours {
	var nodes []WorkingHours
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *WorkingHoursConnection) NodesPtr() []*WorkingHours {
	var nodes []*WorkingHours
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) WorkingHoursesConnection(params *WorkingHoursesConnectionParams) *WorkingHoursConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WorkingHoursWhereInput", "WorkingHoursOrderByInput", "WorkingHours"},
		"workingHoursesConnection",
		[]string{"edges", "pageInfo"})

	return &WorkingHoursConnectionExec{ret}
}

func (client *Client) CreateAlias(params AliasCreateInput) *AliasExec {
	ret := client.Client.Create(
		params,
		[2]string{"AliasCreateInput!", "Alias"},
		"createAlias",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

type AliasUpdateParams struct {
	Data  AliasUpdateInput      `json:"data"`
	Where AliasWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAlias(params AliasUpdateParams) *AliasExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AliasUpdateInput!", "AliasWhereUniqueInput!", "Alias"},
		"updateAlias",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

type AliasUpdateManyParams struct {
	Data  AliasUpdateManyMutationInput `json:"data"`
	Where *AliasWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAliases(params AliasUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AliasUpdateManyMutationInput!", "AliasWhereInput"},
		"updateManyAliases")
	return &BatchPayloadExec{exec}
}

type AliasUpsertParams struct {
	Where  AliasWhereUniqueInput `json:"where"`
	Create AliasCreateInput      `json:"create"`
	Update AliasUpdateInput      `json:"update"`
}

func (client *Client) UpsertAlias(params AliasUpsertParams) *AliasExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AliasWhereUniqueInput!", "AliasCreateInput!", "AliasUpdateInput!", "Alias"},
		"upsertAlias",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

func (client *Client) DeleteAlias(params AliasWhereUniqueInput) *AliasExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AliasWhereUniqueInput!", "Alias"},
		"deleteAlias",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

func (client *Client) DeleteManyAliases(params *AliasWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AliasWhereInput", "deleteManyAliases")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAppointment(params AppointmentCreateInput) *AppointmentExec {
	ret := client.Client.Create(
		params,
		[2]string{"AppointmentCreateInput!", "Appointment"},
		"createAppointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

type AppointmentUpdateParams struct {
	Data  AppointmentUpdateInput      `json:"data"`
	Where AppointmentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAppointment(params AppointmentUpdateParams) *AppointmentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AppointmentUpdateInput!", "AppointmentWhereUniqueInput!", "Appointment"},
		"updateAppointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

type AppointmentUpdateManyParams struct {
	Data  AppointmentUpdateManyMutationInput `json:"data"`
	Where *AppointmentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAppointments(params AppointmentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AppointmentUpdateManyMutationInput!", "AppointmentWhereInput"},
		"updateManyAppointments")
	return &BatchPayloadExec{exec}
}

type AppointmentUpsertParams struct {
	Where  AppointmentWhereUniqueInput `json:"where"`
	Create AppointmentCreateInput      `json:"create"`
	Update AppointmentUpdateInput      `json:"update"`
}

func (client *Client) UpsertAppointment(params AppointmentUpsertParams) *AppointmentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AppointmentWhereUniqueInput!", "AppointmentCreateInput!", "AppointmentUpdateInput!", "Appointment"},
		"upsertAppointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (client *Client) DeleteAppointment(params AppointmentWhereUniqueInput) *AppointmentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AppointmentWhereUniqueInput!", "Appointment"},
		"deleteAppointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (client *Client) DeleteManyAppointments(params *AppointmentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AppointmentWhereInput", "deleteManyAppointments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAppointmentProductLink(params AppointmentProductLinkCreateInput) *AppointmentProductLinkExec {
	ret := client.Client.Create(
		params,
		[2]string{"AppointmentProductLinkCreateInput!", "AppointmentProductLink"},
		"createAppointmentProductLink",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

type AppointmentProductLinkUpdateParams struct {
	Data  AppointmentProductLinkUpdateInput      `json:"data"`
	Where AppointmentProductLinkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAppointmentProductLink(params AppointmentProductLinkUpdateParams) *AppointmentProductLinkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AppointmentProductLinkUpdateInput!", "AppointmentProductLinkWhereUniqueInput!", "AppointmentProductLink"},
		"updateAppointmentProductLink",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

type AppointmentProductLinkUpdateManyParams struct {
	Data  AppointmentProductLinkUpdateManyMutationInput `json:"data"`
	Where *AppointmentProductLinkWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAppointmentProductLinks(params AppointmentProductLinkUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AppointmentProductLinkUpdateManyMutationInput!", "AppointmentProductLinkWhereInput"},
		"updateManyAppointmentProductLinks")
	return &BatchPayloadExec{exec}
}

type AppointmentProductLinkUpsertParams struct {
	Where  AppointmentProductLinkWhereUniqueInput `json:"where"`
	Create AppointmentProductLinkCreateInput      `json:"create"`
	Update AppointmentProductLinkUpdateInput      `json:"update"`
}

func (client *Client) UpsertAppointmentProductLink(params AppointmentProductLinkUpsertParams) *AppointmentProductLinkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AppointmentProductLinkWhereUniqueInput!", "AppointmentProductLinkCreateInput!", "AppointmentProductLinkUpdateInput!", "AppointmentProductLink"},
		"upsertAppointmentProductLink",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

func (client *Client) DeleteAppointmentProductLink(params AppointmentProductLinkWhereUniqueInput) *AppointmentProductLinkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AppointmentProductLinkWhereUniqueInput!", "AppointmentProductLink"},
		"deleteAppointmentProductLink",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

func (client *Client) DeleteManyAppointmentProductLinks(params *AppointmentProductLinkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AppointmentProductLinkWhereInput", "deleteManyAppointmentProductLinks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAppointmentServiceLink(params AppointmentServiceLinkCreateInput) *AppointmentServiceLinkExec {
	ret := client.Client.Create(
		params,
		[2]string{"AppointmentServiceLinkCreateInput!", "AppointmentServiceLink"},
		"createAppointmentServiceLink",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

type AppointmentServiceLinkUpdateParams struct {
	Data  AppointmentServiceLinkUpdateInput      `json:"data"`
	Where AppointmentServiceLinkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAppointmentServiceLink(params AppointmentServiceLinkUpdateParams) *AppointmentServiceLinkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AppointmentServiceLinkUpdateInput!", "AppointmentServiceLinkWhereUniqueInput!", "AppointmentServiceLink"},
		"updateAppointmentServiceLink",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

type AppointmentServiceLinkUpsertParams struct {
	Where  AppointmentServiceLinkWhereUniqueInput `json:"where"`
	Create AppointmentServiceLinkCreateInput      `json:"create"`
	Update AppointmentServiceLinkUpdateInput      `json:"update"`
}

func (client *Client) UpsertAppointmentServiceLink(params AppointmentServiceLinkUpsertParams) *AppointmentServiceLinkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AppointmentServiceLinkWhereUniqueInput!", "AppointmentServiceLinkCreateInput!", "AppointmentServiceLinkUpdateInput!", "AppointmentServiceLink"},
		"upsertAppointmentServiceLink",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

func (client *Client) DeleteAppointmentServiceLink(params AppointmentServiceLinkWhereUniqueInput) *AppointmentServiceLinkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AppointmentServiceLinkWhereUniqueInput!", "AppointmentServiceLink"},
		"deleteAppointmentServiceLink",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

func (client *Client) DeleteManyAppointmentServiceLinks(params *AppointmentServiceLinkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AppointmentServiceLinkWhereInput", "deleteManyAppointmentServiceLinks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBranch(params BranchCreateInput) *BranchExec {
	ret := client.Client.Create(
		params,
		[2]string{"BranchCreateInput!", "Branch"},
		"createBranch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

type BranchUpdateParams struct {
	Data  BranchUpdateInput      `json:"data"`
	Where BranchWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBranch(params BranchUpdateParams) *BranchExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BranchUpdateInput!", "BranchWhereUniqueInput!", "Branch"},
		"updateBranch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

type BranchUpdateManyParams struct {
	Data  BranchUpdateManyMutationInput `json:"data"`
	Where *BranchWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBranches(params BranchUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BranchUpdateManyMutationInput!", "BranchWhereInput"},
		"updateManyBranches")
	return &BatchPayloadExec{exec}
}

type BranchUpsertParams struct {
	Where  BranchWhereUniqueInput `json:"where"`
	Create BranchCreateInput      `json:"create"`
	Update BranchUpdateInput      `json:"update"`
}

func (client *Client) UpsertBranch(params BranchUpsertParams) *BranchExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BranchWhereUniqueInput!", "BranchCreateInput!", "BranchUpdateInput!", "Branch"},
		"upsertBranch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (client *Client) DeleteBranch(params BranchWhereUniqueInput) *BranchExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BranchWhereUniqueInput!", "Branch"},
		"deleteBranch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (client *Client) DeleteManyBranches(params *BranchWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BranchWhereInput", "deleteManyBranches")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBranchImageSlot(params BranchImageSlotCreateInput) *BranchImageSlotExec {
	ret := client.Client.Create(
		params,
		[2]string{"BranchImageSlotCreateInput!", "BranchImageSlot"},
		"createBranchImageSlot",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

type BranchImageSlotUpdateParams struct {
	Data  BranchImageSlotUpdateInput      `json:"data"`
	Where BranchImageSlotWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBranchImageSlot(params BranchImageSlotUpdateParams) *BranchImageSlotExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BranchImageSlotUpdateInput!", "BranchImageSlotWhereUniqueInput!", "BranchImageSlot"},
		"updateBranchImageSlot",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

type BranchImageSlotUpdateManyParams struct {
	Data  BranchImageSlotUpdateManyMutationInput `json:"data"`
	Where *BranchImageSlotWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBranchImageSlots(params BranchImageSlotUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BranchImageSlotUpdateManyMutationInput!", "BranchImageSlotWhereInput"},
		"updateManyBranchImageSlots")
	return &BatchPayloadExec{exec}
}

type BranchImageSlotUpsertParams struct {
	Where  BranchImageSlotWhereUniqueInput `json:"where"`
	Create BranchImageSlotCreateInput      `json:"create"`
	Update BranchImageSlotUpdateInput      `json:"update"`
}

func (client *Client) UpsertBranchImageSlot(params BranchImageSlotUpsertParams) *BranchImageSlotExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BranchImageSlotWhereUniqueInput!", "BranchImageSlotCreateInput!", "BranchImageSlotUpdateInput!", "BranchImageSlot"},
		"upsertBranchImageSlot",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

func (client *Client) DeleteBranchImageSlot(params BranchImageSlotWhereUniqueInput) *BranchImageSlotExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BranchImageSlotWhereUniqueInput!", "BranchImageSlot"},
		"deleteBranchImageSlot",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

func (client *Client) DeleteManyBranchImageSlots(params *BranchImageSlotWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BranchImageSlotWhereInput", "deleteManyBranchImageSlots")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBranchOpeningHour(params BranchOpeningHourCreateInput) *BranchOpeningHourExec {
	ret := client.Client.Create(
		params,
		[2]string{"BranchOpeningHourCreateInput!", "BranchOpeningHour"},
		"createBranchOpeningHour",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

type BranchOpeningHourUpdateParams struct {
	Data  BranchOpeningHourUpdateInput      `json:"data"`
	Where BranchOpeningHourWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBranchOpeningHour(params BranchOpeningHourUpdateParams) *BranchOpeningHourExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BranchOpeningHourUpdateInput!", "BranchOpeningHourWhereUniqueInput!", "BranchOpeningHour"},
		"updateBranchOpeningHour",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

type BranchOpeningHourUpdateManyParams struct {
	Data  BranchOpeningHourUpdateManyMutationInput `json:"data"`
	Where *BranchOpeningHourWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBranchOpeningHours(params BranchOpeningHourUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BranchOpeningHourUpdateManyMutationInput!", "BranchOpeningHourWhereInput"},
		"updateManyBranchOpeningHours")
	return &BatchPayloadExec{exec}
}

type BranchOpeningHourUpsertParams struct {
	Where  BranchOpeningHourWhereUniqueInput `json:"where"`
	Create BranchOpeningHourCreateInput      `json:"create"`
	Update BranchOpeningHourUpdateInput      `json:"update"`
}

func (client *Client) UpsertBranchOpeningHour(params BranchOpeningHourUpsertParams) *BranchOpeningHourExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BranchOpeningHourWhereUniqueInput!", "BranchOpeningHourCreateInput!", "BranchOpeningHourUpdateInput!", "BranchOpeningHour"},
		"upsertBranchOpeningHour",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

func (client *Client) DeleteBranchOpeningHour(params BranchOpeningHourWhereUniqueInput) *BranchOpeningHourExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BranchOpeningHourWhereUniqueInput!", "BranchOpeningHour"},
		"deleteBranchOpeningHour",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

func (client *Client) DeleteManyBranchOpeningHours(params *BranchOpeningHourWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BranchOpeningHourWhereInput", "deleteManyBranchOpeningHours")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCompany(params CompanyCreateInput) *CompanyExec {
	ret := client.Client.Create(
		params,
		[2]string{"CompanyCreateInput!", "Company"},
		"createCompany",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

type CompanyUpdateParams struct {
	Data  CompanyUpdateInput      `json:"data"`
	Where CompanyWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCompany(params CompanyUpdateParams) *CompanyExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CompanyUpdateInput!", "CompanyWhereUniqueInput!", "Company"},
		"updateCompany",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

type CompanyUpdateManyParams struct {
	Data  CompanyUpdateManyMutationInput `json:"data"`
	Where *CompanyWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCompanies(params CompanyUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CompanyUpdateManyMutationInput!", "CompanyWhereInput"},
		"updateManyCompanies")
	return &BatchPayloadExec{exec}
}

type CompanyUpsertParams struct {
	Where  CompanyWhereUniqueInput `json:"where"`
	Create CompanyCreateInput      `json:"create"`
	Update CompanyUpdateInput      `json:"update"`
}

func (client *Client) UpsertCompany(params CompanyUpsertParams) *CompanyExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CompanyWhereUniqueInput!", "CompanyCreateInput!", "CompanyUpdateInput!", "Company"},
		"upsertCompany",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (client *Client) DeleteCompany(params CompanyWhereUniqueInput) *CompanyExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CompanyWhereUniqueInput!", "Company"},
		"deleteCompany",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (client *Client) DeleteManyCompanies(params *CompanyWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CompanyWhereInput", "deleteManyCompanies")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCustomUrl(params CustomUrlCreateInput) *CustomUrlExec {
	ret := client.Client.Create(
		params,
		[2]string{"CustomUrlCreateInput!", "CustomUrl"},
		"createCustomUrl",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

type CustomUrlUpdateParams struct {
	Data  CustomUrlUpdateInput      `json:"data"`
	Where CustomUrlWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCustomUrl(params CustomUrlUpdateParams) *CustomUrlExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CustomUrlUpdateInput!", "CustomUrlWhereUniqueInput!", "CustomUrl"},
		"updateCustomUrl",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

type CustomUrlUpdateManyParams struct {
	Data  CustomUrlUpdateManyMutationInput `json:"data"`
	Where *CustomUrlWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCustomUrls(params CustomUrlUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CustomUrlUpdateManyMutationInput!", "CustomUrlWhereInput"},
		"updateManyCustomUrls")
	return &BatchPayloadExec{exec}
}

type CustomUrlUpsertParams struct {
	Where  CustomUrlWhereUniqueInput `json:"where"`
	Create CustomUrlCreateInput      `json:"create"`
	Update CustomUrlUpdateInput      `json:"update"`
}

func (client *Client) UpsertCustomUrl(params CustomUrlUpsertParams) *CustomUrlExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CustomUrlWhereUniqueInput!", "CustomUrlCreateInput!", "CustomUrlUpdateInput!", "CustomUrl"},
		"upsertCustomUrl",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

func (client *Client) DeleteCustomUrl(params CustomUrlWhereUniqueInput) *CustomUrlExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CustomUrlWhereUniqueInput!", "CustomUrl"},
		"deleteCustomUrl",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

func (client *Client) DeleteManyCustomUrls(params *CustomUrlWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CustomUrlWhereInput", "deleteManyCustomUrls")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEmailTemplate(params EmailTemplateCreateInput) *EmailTemplateExec {
	ret := client.Client.Create(
		params,
		[2]string{"EmailTemplateCreateInput!", "EmailTemplate"},
		"createEmailTemplate",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

type EmailTemplateUpdateParams struct {
	Data  EmailTemplateUpdateInput      `json:"data"`
	Where EmailTemplateWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEmailTemplate(params EmailTemplateUpdateParams) *EmailTemplateExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EmailTemplateUpdateInput!", "EmailTemplateWhereUniqueInput!", "EmailTemplate"},
		"updateEmailTemplate",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

type EmailTemplateUpdateManyParams struct {
	Data  EmailTemplateUpdateManyMutationInput `json:"data"`
	Where *EmailTemplateWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEmailTemplates(params EmailTemplateUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EmailTemplateUpdateManyMutationInput!", "EmailTemplateWhereInput"},
		"updateManyEmailTemplates")
	return &BatchPayloadExec{exec}
}

type EmailTemplateUpsertParams struct {
	Where  EmailTemplateWhereUniqueInput `json:"where"`
	Create EmailTemplateCreateInput      `json:"create"`
	Update EmailTemplateUpdateInput      `json:"update"`
}

func (client *Client) UpsertEmailTemplate(params EmailTemplateUpsertParams) *EmailTemplateExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EmailTemplateWhereUniqueInput!", "EmailTemplateCreateInput!", "EmailTemplateUpdateInput!", "EmailTemplate"},
		"upsertEmailTemplate",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

func (client *Client) DeleteEmailTemplate(params EmailTemplateWhereUniqueInput) *EmailTemplateExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EmailTemplateWhereUniqueInput!", "EmailTemplate"},
		"deleteEmailTemplate",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

func (client *Client) DeleteManyEmailTemplates(params *EmailTemplateWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EmailTemplateWhereInput", "deleteManyEmailTemplates")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFavorite(params FavoriteCreateInput) *FavoriteExec {
	ret := client.Client.Create(
		params,
		[2]string{"FavoriteCreateInput!", "Favorite"},
		"createFavorite",
		[]string{"id"})

	return &FavoriteExec{ret}
}

type FavoriteUpdateParams struct {
	Data  FavoriteUpdateInput      `json:"data"`
	Where FavoriteWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFavorite(params FavoriteUpdateParams) *FavoriteExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FavoriteUpdateInput!", "FavoriteWhereUniqueInput!", "Favorite"},
		"updateFavorite",
		[]string{"id"})

	return &FavoriteExec{ret}
}

type FavoriteUpsertParams struct {
	Where  FavoriteWhereUniqueInput `json:"where"`
	Create FavoriteCreateInput      `json:"create"`
	Update FavoriteUpdateInput      `json:"update"`
}

func (client *Client) UpsertFavorite(params FavoriteUpsertParams) *FavoriteExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FavoriteWhereUniqueInput!", "FavoriteCreateInput!", "FavoriteUpdateInput!", "Favorite"},
		"upsertFavorite",
		[]string{"id"})

	return &FavoriteExec{ret}
}

func (client *Client) DeleteFavorite(params FavoriteWhereUniqueInput) *FavoriteExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FavoriteWhereUniqueInput!", "Favorite"},
		"deleteFavorite",
		[]string{"id"})

	return &FavoriteExec{ret}
}

func (client *Client) DeleteManyFavorites(params *FavoriteWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FavoriteWhereInput", "deleteManyFavorites")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLocalizedString(params LocalizedStringCreateInput) *LocalizedStringExec {
	ret := client.Client.Create(
		params,
		[2]string{"LocalizedStringCreateInput!", "LocalizedString"},
		"createLocalizedString",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

type LocalizedStringUpdateParams struct {
	Data  LocalizedStringUpdateInput      `json:"data"`
	Where LocalizedStringWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLocalizedString(params LocalizedStringUpdateParams) *LocalizedStringExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LocalizedStringUpdateInput!", "LocalizedStringWhereUniqueInput!", "LocalizedString"},
		"updateLocalizedString",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

type LocalizedStringUpdateManyParams struct {
	Data  LocalizedStringUpdateManyMutationInput `json:"data"`
	Where *LocalizedStringWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLocalizedStrings(params LocalizedStringUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LocalizedStringUpdateManyMutationInput!", "LocalizedStringWhereInput"},
		"updateManyLocalizedStrings")
	return &BatchPayloadExec{exec}
}

type LocalizedStringUpsertParams struct {
	Where  LocalizedStringWhereUniqueInput `json:"where"`
	Create LocalizedStringCreateInput      `json:"create"`
	Update LocalizedStringUpdateInput      `json:"update"`
}

func (client *Client) UpsertLocalizedString(params LocalizedStringUpsertParams) *LocalizedStringExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LocalizedStringWhereUniqueInput!", "LocalizedStringCreateInput!", "LocalizedStringUpdateInput!", "LocalizedString"},
		"upsertLocalizedString",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (client *Client) DeleteLocalizedString(params LocalizedStringWhereUniqueInput) *LocalizedStringExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LocalizedStringWhereUniqueInput!", "LocalizedString"},
		"deleteLocalizedString",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (client *Client) DeleteManyLocalizedStrings(params *LocalizedStringWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LocalizedStringWhereInput", "deleteManyLocalizedStrings")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateNews(params NewsCreateInput) *NewsExec {
	ret := client.Client.Create(
		params,
		[2]string{"NewsCreateInput!", "News"},
		"createNews",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

type NewsUpdateParams struct {
	Data  NewsUpdateInput      `json:"data"`
	Where NewsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateNews(params NewsUpdateParams) *NewsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"NewsUpdateInput!", "NewsWhereUniqueInput!", "News"},
		"updateNews",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

type NewsUpdateManyParams struct {
	Data  NewsUpdateManyMutationInput `json:"data"`
	Where *NewsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyNewses(params NewsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"NewsUpdateManyMutationInput!", "NewsWhereInput"},
		"updateManyNewses")
	return &BatchPayloadExec{exec}
}

type NewsUpsertParams struct {
	Where  NewsWhereUniqueInput `json:"where"`
	Create NewsCreateInput      `json:"create"`
	Update NewsUpdateInput      `json:"update"`
}

func (client *Client) UpsertNews(params NewsUpsertParams) *NewsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"NewsWhereUniqueInput!", "NewsCreateInput!", "NewsUpdateInput!", "News"},
		"upsertNews",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

func (client *Client) DeleteNews(params NewsWhereUniqueInput) *NewsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"NewsWhereUniqueInput!", "News"},
		"deleteNews",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

func (client *Client) DeleteManyNewses(params *NewsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "NewsWhereInput", "deleteManyNewses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePasswordToken(params PasswordTokenCreateInput) *PasswordTokenExec {
	ret := client.Client.Create(
		params,
		[2]string{"PasswordTokenCreateInput!", "PasswordToken"},
		"createPasswordToken",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

type PasswordTokenUpdateParams struct {
	Data  PasswordTokenUpdateInput      `json:"data"`
	Where PasswordTokenWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePasswordToken(params PasswordTokenUpdateParams) *PasswordTokenExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PasswordTokenUpdateInput!", "PasswordTokenWhereUniqueInput!", "PasswordToken"},
		"updatePasswordToken",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

type PasswordTokenUpdateManyParams struct {
	Data  PasswordTokenUpdateManyMutationInput `json:"data"`
	Where *PasswordTokenWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPasswordTokens(params PasswordTokenUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PasswordTokenUpdateManyMutationInput!", "PasswordTokenWhereInput"},
		"updateManyPasswordTokens")
	return &BatchPayloadExec{exec}
}

type PasswordTokenUpsertParams struct {
	Where  PasswordTokenWhereUniqueInput `json:"where"`
	Create PasswordTokenCreateInput      `json:"create"`
	Update PasswordTokenUpdateInput      `json:"update"`
}

func (client *Client) UpsertPasswordToken(params PasswordTokenUpsertParams) *PasswordTokenExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PasswordTokenWhereUniqueInput!", "PasswordTokenCreateInput!", "PasswordTokenUpdateInput!", "PasswordToken"},
		"upsertPasswordToken",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

func (client *Client) DeletePasswordToken(params PasswordTokenWhereUniqueInput) *PasswordTokenExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PasswordTokenWhereUniqueInput!", "PasswordToken"},
		"deletePasswordToken",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

func (client *Client) DeleteManyPasswordTokens(params *PasswordTokenWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PasswordTokenWhereInput", "deleteManyPasswordTokens")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProduct(params ProductCreateInput) *ProductExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProductCreateInput!", "Product"},
		"createProduct",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

type ProductUpdateParams struct {
	Data  ProductUpdateInput      `json:"data"`
	Where ProductWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProduct(params ProductUpdateParams) *ProductExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProductUpdateInput!", "ProductWhereUniqueInput!", "Product"},
		"updateProduct",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

type ProductUpdateManyParams struct {
	Data  ProductUpdateManyMutationInput `json:"data"`
	Where *ProductWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProducts(params ProductUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProductUpdateManyMutationInput!", "ProductWhereInput"},
		"updateManyProducts")
	return &BatchPayloadExec{exec}
}

type ProductUpsertParams struct {
	Where  ProductWhereUniqueInput `json:"where"`
	Create ProductCreateInput      `json:"create"`
	Update ProductUpdateInput      `json:"update"`
}

func (client *Client) UpsertProduct(params ProductUpsertParams) *ProductExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProductWhereUniqueInput!", "ProductCreateInput!", "ProductUpdateInput!", "Product"},
		"upsertProduct",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (client *Client) DeleteProduct(params ProductWhereUniqueInput) *ProductExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProductWhereUniqueInput!", "Product"},
		"deleteProduct",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (client *Client) DeleteManyProducts(params *ProductWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProductWhereInput", "deleteManyProducts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProductCategory(params ProductCategoryCreateInput) *ProductCategoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProductCategoryCreateInput!", "ProductCategory"},
		"createProductCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

type ProductCategoryUpdateParams struct {
	Data  ProductCategoryUpdateInput      `json:"data"`
	Where ProductCategoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProductCategory(params ProductCategoryUpdateParams) *ProductCategoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProductCategoryUpdateInput!", "ProductCategoryWhereUniqueInput!", "ProductCategory"},
		"updateProductCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

type ProductCategoryUpdateManyParams struct {
	Data  ProductCategoryUpdateManyMutationInput `json:"data"`
	Where *ProductCategoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProductCategories(params ProductCategoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProductCategoryUpdateManyMutationInput!", "ProductCategoryWhereInput"},
		"updateManyProductCategories")
	return &BatchPayloadExec{exec}
}

type ProductCategoryUpsertParams struct {
	Where  ProductCategoryWhereUniqueInput `json:"where"`
	Create ProductCategoryCreateInput      `json:"create"`
	Update ProductCategoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertProductCategory(params ProductCategoryUpsertParams) *ProductCategoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProductCategoryWhereUniqueInput!", "ProductCategoryCreateInput!", "ProductCategoryUpdateInput!", "ProductCategory"},
		"upsertProductCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

func (client *Client) DeleteProductCategory(params ProductCategoryWhereUniqueInput) *ProductCategoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProductCategoryWhereUniqueInput!", "ProductCategory"},
		"deleteProductCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

func (client *Client) DeleteManyProductCategories(params *ProductCategoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProductCategoryWhereInput", "deleteManyProductCategories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProductServiceAttribute(params ProductServiceAttributeCreateInput) *ProductServiceAttributeExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProductServiceAttributeCreateInput!", "ProductServiceAttribute"},
		"createProductServiceAttribute",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

type ProductServiceAttributeUpdateParams struct {
	Data  ProductServiceAttributeUpdateInput      `json:"data"`
	Where ProductServiceAttributeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProductServiceAttribute(params ProductServiceAttributeUpdateParams) *ProductServiceAttributeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProductServiceAttributeUpdateInput!", "ProductServiceAttributeWhereUniqueInput!", "ProductServiceAttribute"},
		"updateProductServiceAttribute",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

type ProductServiceAttributeUpdateManyParams struct {
	Data  ProductServiceAttributeUpdateManyMutationInput `json:"data"`
	Where *ProductServiceAttributeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProductServiceAttributes(params ProductServiceAttributeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProductServiceAttributeUpdateManyMutationInput!", "ProductServiceAttributeWhereInput"},
		"updateManyProductServiceAttributes")
	return &BatchPayloadExec{exec}
}

type ProductServiceAttributeUpsertParams struct {
	Where  ProductServiceAttributeWhereUniqueInput `json:"where"`
	Create ProductServiceAttributeCreateInput      `json:"create"`
	Update ProductServiceAttributeUpdateInput      `json:"update"`
}

func (client *Client) UpsertProductServiceAttribute(params ProductServiceAttributeUpsertParams) *ProductServiceAttributeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProductServiceAttributeWhereUniqueInput!", "ProductServiceAttributeCreateInput!", "ProductServiceAttributeUpdateInput!", "ProductServiceAttribute"},
		"upsertProductServiceAttribute",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

func (client *Client) DeleteProductServiceAttribute(params ProductServiceAttributeWhereUniqueInput) *ProductServiceAttributeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProductServiceAttributeWhereUniqueInput!", "ProductServiceAttribute"},
		"deleteProductServiceAttribute",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

func (client *Client) DeleteManyProductServiceAttributes(params *ProductServiceAttributeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProductServiceAttributeWhereInput", "deleteManyProductServiceAttributes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProductSubCategory(params ProductSubCategoryCreateInput) *ProductSubCategoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProductSubCategoryCreateInput!", "ProductSubCategory"},
		"createProductSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

type ProductSubCategoryUpdateParams struct {
	Data  ProductSubCategoryUpdateInput      `json:"data"`
	Where ProductSubCategoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProductSubCategory(params ProductSubCategoryUpdateParams) *ProductSubCategoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProductSubCategoryUpdateInput!", "ProductSubCategoryWhereUniqueInput!", "ProductSubCategory"},
		"updateProductSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

type ProductSubCategoryUpdateManyParams struct {
	Data  ProductSubCategoryUpdateManyMutationInput `json:"data"`
	Where *ProductSubCategoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProductSubCategories(params ProductSubCategoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProductSubCategoryUpdateManyMutationInput!", "ProductSubCategoryWhereInput"},
		"updateManyProductSubCategories")
	return &BatchPayloadExec{exec}
}

type ProductSubCategoryUpsertParams struct {
	Where  ProductSubCategoryWhereUniqueInput `json:"where"`
	Create ProductSubCategoryCreateInput      `json:"create"`
	Update ProductSubCategoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertProductSubCategory(params ProductSubCategoryUpsertParams) *ProductSubCategoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProductSubCategoryWhereUniqueInput!", "ProductSubCategoryCreateInput!", "ProductSubCategoryUpdateInput!", "ProductSubCategory"},
		"upsertProductSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

func (client *Client) DeleteProductSubCategory(params ProductSubCategoryWhereUniqueInput) *ProductSubCategoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProductSubCategoryWhereUniqueInput!", "ProductSubCategory"},
		"deleteProductSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

func (client *Client) DeleteManyProductSubCategories(params *ProductSubCategoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProductSubCategoryWhereInput", "deleteManyProductSubCategories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReview(params ReviewCreateInput) *ReviewExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewCreateInput!", "Review"},
		"createReview",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

type ReviewUpdateParams struct {
	Data  ReviewUpdateInput      `json:"data"`
	Where ReviewWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReview(params ReviewUpdateParams) *ReviewExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewUpdateInput!", "ReviewWhereUniqueInput!", "Review"},
		"updateReview",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

type ReviewUpdateManyParams struct {
	Data  ReviewUpdateManyMutationInput `json:"data"`
	Where *ReviewWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviews(params ReviewUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewUpdateManyMutationInput!", "ReviewWhereInput"},
		"updateManyReviews")
	return &BatchPayloadExec{exec}
}

type ReviewUpsertParams struct {
	Where  ReviewWhereUniqueInput `json:"where"`
	Create ReviewCreateInput      `json:"create"`
	Update ReviewUpdateInput      `json:"update"`
}

func (client *Client) UpsertReview(params ReviewUpsertParams) *ReviewExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewWhereUniqueInput!", "ReviewCreateInput!", "ReviewUpdateInput!", "Review"},
		"upsertReview",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

func (client *Client) DeleteReview(params ReviewWhereUniqueInput) *ReviewExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewWhereUniqueInput!", "Review"},
		"deleteReview",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

func (client *Client) DeleteManyReviews(params *ReviewWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewWhereInput", "deleteManyReviews")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateService(params ServiceCreateInput) *ServiceExec {
	ret := client.Client.Create(
		params,
		[2]string{"ServiceCreateInput!", "Service"},
		"createService",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

type ServiceUpdateParams struct {
	Data  ServiceUpdateInput      `json:"data"`
	Where ServiceWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateService(params ServiceUpdateParams) *ServiceExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ServiceUpdateInput!", "ServiceWhereUniqueInput!", "Service"},
		"updateService",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

type ServiceUpdateManyParams struct {
	Data  ServiceUpdateManyMutationInput `json:"data"`
	Where *ServiceWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyServices(params ServiceUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ServiceUpdateManyMutationInput!", "ServiceWhereInput"},
		"updateManyServices")
	return &BatchPayloadExec{exec}
}

type ServiceUpsertParams struct {
	Where  ServiceWhereUniqueInput `json:"where"`
	Create ServiceCreateInput      `json:"create"`
	Update ServiceUpdateInput      `json:"update"`
}

func (client *Client) UpsertService(params ServiceUpsertParams) *ServiceExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ServiceWhereUniqueInput!", "ServiceCreateInput!", "ServiceUpdateInput!", "Service"},
		"upsertService",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (client *Client) DeleteService(params ServiceWhereUniqueInput) *ServiceExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ServiceWhereUniqueInput!", "Service"},
		"deleteService",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (client *Client) DeleteManyServices(params *ServiceWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ServiceWhereInput", "deleteManyServices")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateServiceCategory(params ServiceCategoryCreateInput) *ServiceCategoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"ServiceCategoryCreateInput!", "ServiceCategory"},
		"createServiceCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

type ServiceCategoryUpdateParams struct {
	Data  ServiceCategoryUpdateInput      `json:"data"`
	Where ServiceCategoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateServiceCategory(params ServiceCategoryUpdateParams) *ServiceCategoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ServiceCategoryUpdateInput!", "ServiceCategoryWhereUniqueInput!", "ServiceCategory"},
		"updateServiceCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

type ServiceCategoryUpdateManyParams struct {
	Data  ServiceCategoryUpdateManyMutationInput `json:"data"`
	Where *ServiceCategoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyServiceCategories(params ServiceCategoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ServiceCategoryUpdateManyMutationInput!", "ServiceCategoryWhereInput"},
		"updateManyServiceCategories")
	return &BatchPayloadExec{exec}
}

type ServiceCategoryUpsertParams struct {
	Where  ServiceCategoryWhereUniqueInput `json:"where"`
	Create ServiceCategoryCreateInput      `json:"create"`
	Update ServiceCategoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertServiceCategory(params ServiceCategoryUpsertParams) *ServiceCategoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ServiceCategoryWhereUniqueInput!", "ServiceCategoryCreateInput!", "ServiceCategoryUpdateInput!", "ServiceCategory"},
		"upsertServiceCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

func (client *Client) DeleteServiceCategory(params ServiceCategoryWhereUniqueInput) *ServiceCategoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ServiceCategoryWhereUniqueInput!", "ServiceCategory"},
		"deleteServiceCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

func (client *Client) DeleteManyServiceCategories(params *ServiceCategoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ServiceCategoryWhereInput", "deleteManyServiceCategories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateServiceSubCategory(params ServiceSubCategoryCreateInput) *ServiceSubCategoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"ServiceSubCategoryCreateInput!", "ServiceSubCategory"},
		"createServiceSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

type ServiceSubCategoryUpdateParams struct {
	Data  ServiceSubCategoryUpdateInput      `json:"data"`
	Where ServiceSubCategoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateServiceSubCategory(params ServiceSubCategoryUpdateParams) *ServiceSubCategoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ServiceSubCategoryUpdateInput!", "ServiceSubCategoryWhereUniqueInput!", "ServiceSubCategory"},
		"updateServiceSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

type ServiceSubCategoryUpdateManyParams struct {
	Data  ServiceSubCategoryUpdateManyMutationInput `json:"data"`
	Where *ServiceSubCategoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyServiceSubCategories(params ServiceSubCategoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ServiceSubCategoryUpdateManyMutationInput!", "ServiceSubCategoryWhereInput"},
		"updateManyServiceSubCategories")
	return &BatchPayloadExec{exec}
}

type ServiceSubCategoryUpsertParams struct {
	Where  ServiceSubCategoryWhereUniqueInput `json:"where"`
	Create ServiceSubCategoryCreateInput      `json:"create"`
	Update ServiceSubCategoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertServiceSubCategory(params ServiceSubCategoryUpsertParams) *ServiceSubCategoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ServiceSubCategoryWhereUniqueInput!", "ServiceSubCategoryCreateInput!", "ServiceSubCategoryUpdateInput!", "ServiceSubCategory"},
		"upsertServiceSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

func (client *Client) DeleteServiceSubCategory(params ServiceSubCategoryWhereUniqueInput) *ServiceSubCategoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ServiceSubCategoryWhereUniqueInput!", "ServiceSubCategory"},
		"deleteServiceSubCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

func (client *Client) DeleteManyServiceSubCategories(params *ServiceSubCategoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ServiceSubCategoryWhereInput", "deleteManyServiceSubCategories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateSession(params SessionCreateInput) *SessionExec {
	ret := client.Client.Create(
		params,
		[2]string{"SessionCreateInput!", "Session"},
		"createSession",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

type SessionUpdateParams struct {
	Data  SessionUpdateInput      `json:"data"`
	Where SessionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSession(params SessionUpdateParams) *SessionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SessionUpdateInput!", "SessionWhereUniqueInput!", "Session"},
		"updateSession",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

type SessionUpdateManyParams struct {
	Data  SessionUpdateManyMutationInput `json:"data"`
	Where *SessionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManySessions(params SessionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"SessionUpdateManyMutationInput!", "SessionWhereInput"},
		"updateManySessions")
	return &BatchPayloadExec{exec}
}

type SessionUpsertParams struct {
	Where  SessionWhereUniqueInput `json:"where"`
	Create SessionCreateInput      `json:"create"`
	Update SessionUpdateInput      `json:"update"`
}

func (client *Client) UpsertSession(params SessionUpsertParams) *SessionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SessionWhereUniqueInput!", "SessionCreateInput!", "SessionUpdateInput!", "Session"},
		"upsertSession",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

func (client *Client) DeleteSession(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"deleteSession",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

func (client *Client) DeleteManySessions(params *SessionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SessionWhereInput", "deleteManySessions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWorkingHours(params WorkingHoursCreateInput) *WorkingHoursExec {
	ret := client.Client.Create(
		params,
		[2]string{"WorkingHoursCreateInput!", "WorkingHours"},
		"createWorkingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

type WorkingHoursUpdateParams struct {
	Data  WorkingHoursUpdateInput      `json:"data"`
	Where WorkingHoursWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWorkingHours(params WorkingHoursUpdateParams) *WorkingHoursExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WorkingHoursUpdateInput!", "WorkingHoursWhereUniqueInput!", "WorkingHours"},
		"updateWorkingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

type WorkingHoursUpdateManyParams struct {
	Data  WorkingHoursUpdateManyMutationInput `json:"data"`
	Where *WorkingHoursWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWorkingHourses(params WorkingHoursUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WorkingHoursUpdateManyMutationInput!", "WorkingHoursWhereInput"},
		"updateManyWorkingHourses")
	return &BatchPayloadExec{exec}
}

type WorkingHoursUpsertParams struct {
	Where  WorkingHoursWhereUniqueInput `json:"where"`
	Create WorkingHoursCreateInput      `json:"create"`
	Update WorkingHoursUpdateInput      `json:"update"`
}

func (client *Client) UpsertWorkingHours(params WorkingHoursUpsertParams) *WorkingHoursExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WorkingHoursWhereUniqueInput!", "WorkingHoursCreateInput!", "WorkingHoursUpdateInput!", "WorkingHours"},
		"upsertWorkingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

func (client *Client) DeleteWorkingHours(params WorkingHoursWhereUniqueInput) *WorkingHoursExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WorkingHoursWhereUniqueInput!", "WorkingHours"},
		"deleteWorkingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

func (client *Client) DeleteManyWorkingHourses(params *WorkingHoursWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WorkingHoursWhereInput", "deleteManyWorkingHourses")
	return &BatchPayloadExec{exec}
}

type UserType string

const (
	UserTypeCustomer      UserType = "CUSTOMER"
	UserTypeEmployee      UserType = "EMPLOYEE"
	UserTypeManager       UserType = "MANAGER"
	UserTypeAdministrator UserType = "ADMINISTRATOR"
)

type Gender string

const (
	GenderMale         Gender = "MALE"
	GenderFemale       Gender = "FEMALE"
	GenderDiverse      Gender = "DIVERSE"
	GenderDoNotMention Gender = "DO_NOT_MENTION"
)

type ReviewType string

const (
	ReviewTypeProduct     ReviewType = "PRODUCT"
	ReviewTypeService     ReviewType = "SERVICE"
	ReviewTypeAppointment ReviewType = "APPOINTMENT"
)

type ReviewStatus string

const (
	ReviewStatusPending  ReviewStatus = "PENDING"
	ReviewStatusApproved ReviewStatus = "APPROVED"
	ReviewStatusRejected ReviewStatus = "REJECTED"
)

type GenderTarget string

const (
	GenderTargetMale    GenderTarget = "MALE"
	GenderTargetFemale  GenderTarget = "FEMALE"
	GenderTargetDiverse GenderTarget = "DIVERSE"
	GenderTargetAny     GenderTarget = "ANY"
)

type DayOfWeek string

const (
	DayOfWeekMo DayOfWeek = "MO"
	DayOfWeekTu DayOfWeek = "TU"
	DayOfWeekWe DayOfWeek = "WE"
	DayOfWeekTh DayOfWeek = "TH"
	DayOfWeekFr DayOfWeek = "FR"
	DayOfWeekSa DayOfWeek = "SA"
	DayOfWeekSu DayOfWeek = "SU"
)

type AppointmentStatus string

const (
	AppointmentStatusRequested AppointmentStatus = "REQUESTED"
	AppointmentStatusApproved  AppointmentStatus = "APPROVED"
	AppointmentStatusCanceled  AppointmentStatus = "CANCELED"
)

type AvailabilityStatus string

const (
	AvailabilityStatusAvailable   AvailabilityStatus = "AVAILABLE"
	AvailabilityStatusBooked      AvailabilityStatus = "BOOKED"
	AvailabilityStatusBreak       AvailabilityStatus = "BREAK"
	AvailabilityStatusHoliday     AvailabilityStatus = "HOLIDAY"
	AvailabilityStatusUnavailable AvailabilityStatus = "UNAVAILABLE"
)

type CustomUrlOrderByInput string

const (
	CustomUrlOrderByInputIDAsc     CustomUrlOrderByInput = "id_ASC"
	CustomUrlOrderByInputIDDesc    CustomUrlOrderByInput = "id_DESC"
	CustomUrlOrderByInputValueAsc  CustomUrlOrderByInput = "value_ASC"
	CustomUrlOrderByInputValueDesc CustomUrlOrderByInput = "value_DESC"
)

type AliasOrderByInput string

const (
	AliasOrderByInputIDAsc     AliasOrderByInput = "id_ASC"
	AliasOrderByInputIDDesc    AliasOrderByInput = "id_DESC"
	AliasOrderByInputValueAsc  AliasOrderByInput = "value_ASC"
	AliasOrderByInputValueDesc AliasOrderByInput = "value_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc                  UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc                 UserOrderByInput = "id_DESC"
	UserOrderByInputCreatedAtAsc           UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc          UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc           UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc          UserOrderByInput = "updatedAt_DESC"
	UserOrderByInputTypeAsc                UserOrderByInput = "type_ASC"
	UserOrderByInputTypeDesc               UserOrderByInput = "type_DESC"
	UserOrderByInputEmailAsc               UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc              UserOrderByInput = "email_DESC"
	UserOrderByInputPasswordHashAsc        UserOrderByInput = "passwordHash_ASC"
	UserOrderByInputPasswordHashDesc       UserOrderByInput = "passwordHash_DESC"
	UserOrderByInputFirstNameAsc           UserOrderByInput = "firstName_ASC"
	UserOrderByInputFirstNameDesc          UserOrderByInput = "firstName_DESC"
	UserOrderByInputLastNameAsc            UserOrderByInput = "lastName_ASC"
	UserOrderByInputLastNameDesc           UserOrderByInput = "lastName_DESC"
	UserOrderByInputGenderAsc              UserOrderByInput = "gender_ASC"
	UserOrderByInputGenderDesc             UserOrderByInput = "gender_DESC"
	UserOrderByInputZipCodeAsc             UserOrderByInput = "zipCode_ASC"
	UserOrderByInputZipCodeDesc            UserOrderByInput = "zipCode_DESC"
	UserOrderByInputStreetAsc              UserOrderByInput = "street_ASC"
	UserOrderByInputStreetDesc             UserOrderByInput = "street_DESC"
	UserOrderByInputCityAsc                UserOrderByInput = "city_ASC"
	UserOrderByInputCityDesc               UserOrderByInput = "city_DESC"
	UserOrderByInputBirthdayAsc            UserOrderByInput = "birthday_ASC"
	UserOrderByInputBirthdayDesc           UserOrderByInput = "birthday_DESC"
	UserOrderByInputBirthdateAsc           UserOrderByInput = "birthdate_ASC"
	UserOrderByInputBirthdateDesc          UserOrderByInput = "birthdate_DESC"
	UserOrderByInputPhoneNumberAsc         UserOrderByInput = "phoneNumber_ASC"
	UserOrderByInputPhoneNumberDesc        UserOrderByInput = "phoneNumber_DESC"
	UserOrderByInputImageAsc               UserOrderByInput = "image_ASC"
	UserOrderByInputImageDesc              UserOrderByInput = "image_DESC"
	UserOrderByInputNoteAsc                UserOrderByInput = "note_ASC"
	UserOrderByInputNoteDesc               UserOrderByInput = "note_DESC"
	UserOrderByInputAllowReviewSharingAsc  UserOrderByInput = "allowReviewSharing_ASC"
	UserOrderByInputAllowReviewSharingDesc UserOrderByInput = "allowReviewSharing_DESC"
	UserOrderByInputNotificationTokenAsc   UserOrderByInput = "notificationToken_ASC"
	UserOrderByInputNotificationTokenDesc  UserOrderByInput = "notificationToken_DESC"
	UserOrderByInputLanguageAsc            UserOrderByInput = "language_ASC"
	UserOrderByInputLanguageDesc           UserOrderByInput = "language_DESC"
	UserOrderByInputDeletedAsc             UserOrderByInput = "deleted_ASC"
	UserOrderByInputDeletedDesc            UserOrderByInput = "deleted_DESC"
	UserOrderByInputActivatedAsc           UserOrderByInput = "activated_ASC"
	UserOrderByInputActivatedDesc          UserOrderByInput = "activated_DESC"
	UserOrderByInputActivateTokenAsc       UserOrderByInput = "activateToken_ASC"
	UserOrderByInputActivateTokenDesc      UserOrderByInput = "activateToken_DESC"
)

type ReviewOrderByInput string

const (
	ReviewOrderByInputIDAsc         ReviewOrderByInput = "id_ASC"
	ReviewOrderByInputIDDesc        ReviewOrderByInput = "id_DESC"
	ReviewOrderByInputCreatedAtAsc  ReviewOrderByInput = "createdAt_ASC"
	ReviewOrderByInputCreatedAtDesc ReviewOrderByInput = "createdAt_DESC"
	ReviewOrderByInputUpdatedAtAsc  ReviewOrderByInput = "updatedAt_ASC"
	ReviewOrderByInputUpdatedAtDesc ReviewOrderByInput = "updatedAt_DESC"
	ReviewOrderByInputTypeAsc       ReviewOrderByInput = "type_ASC"
	ReviewOrderByInputTypeDesc      ReviewOrderByInput = "type_DESC"
	ReviewOrderByInputStarsAsc      ReviewOrderByInput = "stars_ASC"
	ReviewOrderByInputStarsDesc     ReviewOrderByInput = "stars_DESC"
	ReviewOrderByInputTitleAsc      ReviewOrderByInput = "title_ASC"
	ReviewOrderByInputTitleDesc     ReviewOrderByInput = "title_DESC"
	ReviewOrderByInputTextAsc       ReviewOrderByInput = "text_ASC"
	ReviewOrderByInputTextDesc      ReviewOrderByInput = "text_DESC"
	ReviewOrderByInputStatusAsc     ReviewOrderByInput = "status_ASC"
	ReviewOrderByInputStatusDesc    ReviewOrderByInput = "status_DESC"
)

type ProductSubCategoryOrderByInput string

const (
	ProductSubCategoryOrderByInputIDAsc         ProductSubCategoryOrderByInput = "id_ASC"
	ProductSubCategoryOrderByInputIDDesc        ProductSubCategoryOrderByInput = "id_DESC"
	ProductSubCategoryOrderByInputCreatedAtAsc  ProductSubCategoryOrderByInput = "createdAt_ASC"
	ProductSubCategoryOrderByInputCreatedAtDesc ProductSubCategoryOrderByInput = "createdAt_DESC"
	ProductSubCategoryOrderByInputUpdatedAtAsc  ProductSubCategoryOrderByInput = "updatedAt_ASC"
	ProductSubCategoryOrderByInputUpdatedAtDesc ProductSubCategoryOrderByInput = "updatedAt_DESC"
	ProductSubCategoryOrderByInputNameAsc       ProductSubCategoryOrderByInput = "name_ASC"
	ProductSubCategoryOrderByInputNameDesc      ProductSubCategoryOrderByInput = "name_DESC"
)

type ProductOrderByInput string

const (
	ProductOrderByInputIDAsc         ProductOrderByInput = "id_ASC"
	ProductOrderByInputIDDesc        ProductOrderByInput = "id_DESC"
	ProductOrderByInputCreatedAtAsc  ProductOrderByInput = "createdAt_ASC"
	ProductOrderByInputCreatedAtDesc ProductOrderByInput = "createdAt_DESC"
	ProductOrderByInputUpdatedAtAsc  ProductOrderByInput = "updatedAt_ASC"
	ProductOrderByInputUpdatedAtDesc ProductOrderByInput = "updatedAt_DESC"
	ProductOrderByInputPriceAsc      ProductOrderByInput = "price_ASC"
	ProductOrderByInputPriceDesc     ProductOrderByInput = "price_DESC"
	ProductOrderByInputCapacityAsc   ProductOrderByInput = "capacity_ASC"
	ProductOrderByInputCapacityDesc  ProductOrderByInput = "capacity_DESC"
	ProductOrderByInputImageAsc      ProductOrderByInput = "image_ASC"
	ProductOrderByInputImageDesc     ProductOrderByInput = "image_DESC"
	ProductOrderByInputDeletedAsc    ProductOrderByInput = "deleted_ASC"
	ProductOrderByInputDeletedDesc   ProductOrderByInput = "deleted_DESC"
	ProductOrderByInputActiveAsc     ProductOrderByInput = "active_ASC"
	ProductOrderByInputActiveDesc    ProductOrderByInput = "active_DESC"
)

type ProductServiceAttributeOrderByInput string

const (
	ProductServiceAttributeOrderByInputIDAsc   ProductServiceAttributeOrderByInput = "id_ASC"
	ProductServiceAttributeOrderByInputIDDesc  ProductServiceAttributeOrderByInput = "id_DESC"
	ProductServiceAttributeOrderByInputKeyAsc  ProductServiceAttributeOrderByInput = "key_ASC"
	ProductServiceAttributeOrderByInputKeyDesc ProductServiceAttributeOrderByInput = "key_DESC"
)

type ServiceSubCategoryOrderByInput string

const (
	ServiceSubCategoryOrderByInputIDAsc         ServiceSubCategoryOrderByInput = "id_ASC"
	ServiceSubCategoryOrderByInputIDDesc        ServiceSubCategoryOrderByInput = "id_DESC"
	ServiceSubCategoryOrderByInputCreatedAtAsc  ServiceSubCategoryOrderByInput = "createdAt_ASC"
	ServiceSubCategoryOrderByInputCreatedAtDesc ServiceSubCategoryOrderByInput = "createdAt_DESC"
	ServiceSubCategoryOrderByInputUpdatedAtAsc  ServiceSubCategoryOrderByInput = "updatedAt_ASC"
	ServiceSubCategoryOrderByInputUpdatedAtDesc ServiceSubCategoryOrderByInput = "updatedAt_DESC"
	ServiceSubCategoryOrderByInputNameAsc       ServiceSubCategoryOrderByInput = "name_ASC"
	ServiceSubCategoryOrderByInputNameDesc      ServiceSubCategoryOrderByInput = "name_DESC"
)

type ServiceOrderByInput string

const (
	ServiceOrderByInputIDAsc            ServiceOrderByInput = "id_ASC"
	ServiceOrderByInputIDDesc           ServiceOrderByInput = "id_DESC"
	ServiceOrderByInputCreatedAtAsc     ServiceOrderByInput = "createdAt_ASC"
	ServiceOrderByInputCreatedAtDesc    ServiceOrderByInput = "createdAt_DESC"
	ServiceOrderByInputUpdatedAtAsc     ServiceOrderByInput = "updatedAt_ASC"
	ServiceOrderByInputUpdatedAtDesc    ServiceOrderByInput = "updatedAt_DESC"
	ServiceOrderByInputPriceAsc         ServiceOrderByInput = "price_ASC"
	ServiceOrderByInputPriceDesc        ServiceOrderByInput = "price_DESC"
	ServiceOrderByInputDurationAsc      ServiceOrderByInput = "duration_ASC"
	ServiceOrderByInputDurationDesc     ServiceOrderByInput = "duration_DESC"
	ServiceOrderByInputImageAsc         ServiceOrderByInput = "image_ASC"
	ServiceOrderByInputImageDesc        ServiceOrderByInput = "image_DESC"
	ServiceOrderByInputGenderTargetAsc  ServiceOrderByInput = "genderTarget_ASC"
	ServiceOrderByInputGenderTargetDesc ServiceOrderByInput = "genderTarget_DESC"
	ServiceOrderByInputDeletedAsc       ServiceOrderByInput = "deleted_ASC"
	ServiceOrderByInputDeletedDesc      ServiceOrderByInput = "deleted_DESC"
	ServiceOrderByInputActiveAsc        ServiceOrderByInput = "active_ASC"
	ServiceOrderByInputActiveDesc       ServiceOrderByInput = "active_DESC"
)

type BranchOpeningHourOrderByInput string

const (
	BranchOpeningHourOrderByInputIDAsc              BranchOpeningHourOrderByInput = "id_ASC"
	BranchOpeningHourOrderByInputIDDesc             BranchOpeningHourOrderByInput = "id_DESC"
	BranchOpeningHourOrderByInputCreatedAtAsc       BranchOpeningHourOrderByInput = "createdAt_ASC"
	BranchOpeningHourOrderByInputCreatedAtDesc      BranchOpeningHourOrderByInput = "createdAt_DESC"
	BranchOpeningHourOrderByInputUpdatedAtAsc       BranchOpeningHourOrderByInput = "updatedAt_ASC"
	BranchOpeningHourOrderByInputUpdatedAtDesc      BranchOpeningHourOrderByInput = "updatedAt_DESC"
	BranchOpeningHourOrderByInputDayAsc             BranchOpeningHourOrderByInput = "day_ASC"
	BranchOpeningHourOrderByInputDayDesc            BranchOpeningHourOrderByInput = "day_DESC"
	BranchOpeningHourOrderByInputClosedAsc          BranchOpeningHourOrderByInput = "closed_ASC"
	BranchOpeningHourOrderByInputClosedDesc         BranchOpeningHourOrderByInput = "closed_DESC"
	BranchOpeningHourOrderByInputBreakAsc           BranchOpeningHourOrderByInput = "break_ASC"
	BranchOpeningHourOrderByInputBreakDesc          BranchOpeningHourOrderByInput = "break_DESC"
	BranchOpeningHourOrderByInputStartForenoonAsc   BranchOpeningHourOrderByInput = "startForenoon_ASC"
	BranchOpeningHourOrderByInputStartForenoonDesc  BranchOpeningHourOrderByInput = "startForenoon_DESC"
	BranchOpeningHourOrderByInputEndForenoonAsc     BranchOpeningHourOrderByInput = "endForenoon_ASC"
	BranchOpeningHourOrderByInputEndForenoonDesc    BranchOpeningHourOrderByInput = "endForenoon_DESC"
	BranchOpeningHourOrderByInputStartAfternoonAsc  BranchOpeningHourOrderByInput = "startAfternoon_ASC"
	BranchOpeningHourOrderByInputStartAfternoonDesc BranchOpeningHourOrderByInput = "startAfternoon_DESC"
	BranchOpeningHourOrderByInputEndAfternoonAsc    BranchOpeningHourOrderByInput = "endAfternoon_ASC"
	BranchOpeningHourOrderByInputEndAfternoonDesc   BranchOpeningHourOrderByInput = "endAfternoon_DESC"
)

type NewsOrderByInput string

const (
	NewsOrderByInputIDAsc         NewsOrderByInput = "id_ASC"
	NewsOrderByInputIDDesc        NewsOrderByInput = "id_DESC"
	NewsOrderByInputCreatedAtAsc  NewsOrderByInput = "createdAt_ASC"
	NewsOrderByInputCreatedAtDesc NewsOrderByInput = "createdAt_DESC"
	NewsOrderByInputUpdatedAtAsc  NewsOrderByInput = "updatedAt_ASC"
	NewsOrderByInputUpdatedAtDesc NewsOrderByInput = "updatedAt_DESC"
	NewsOrderByInputImageAsc      NewsOrderByInput = "image_ASC"
	NewsOrderByInputImageDesc     NewsOrderByInput = "image_DESC"
)

type BranchImageSlotOrderByInput string

const (
	BranchImageSlotOrderByInputIDAsc          BranchImageSlotOrderByInput = "id_ASC"
	BranchImageSlotOrderByInputIDDesc         BranchImageSlotOrderByInput = "id_DESC"
	BranchImageSlotOrderByInputCreatedAtAsc   BranchImageSlotOrderByInput = "createdAt_ASC"
	BranchImageSlotOrderByInputCreatedAtDesc  BranchImageSlotOrderByInput = "createdAt_DESC"
	BranchImageSlotOrderByInputUpdatedAtAsc   BranchImageSlotOrderByInput = "updatedAt_ASC"
	BranchImageSlotOrderByInputUpdatedAtDesc  BranchImageSlotOrderByInput = "updatedAt_DESC"
	BranchImageSlotOrderByInputSlotNumberAsc  BranchImageSlotOrderByInput = "slotNumber_ASC"
	BranchImageSlotOrderByInputSlotNumberDesc BranchImageSlotOrderByInput = "slotNumber_DESC"
	BranchImageSlotOrderByInputImageUrlAsc    BranchImageSlotOrderByInput = "imageUrl_ASC"
	BranchImageSlotOrderByInputImageUrlDesc   BranchImageSlotOrderByInput = "imageUrl_DESC"
)

type AppointmentProductLinkOrderByInput string

const (
	AppointmentProductLinkOrderByInputIDAsc     AppointmentProductLinkOrderByInput = "id_ASC"
	AppointmentProductLinkOrderByInputIDDesc    AppointmentProductLinkOrderByInput = "id_DESC"
	AppointmentProductLinkOrderByInputCountAsc  AppointmentProductLinkOrderByInput = "count_ASC"
	AppointmentProductLinkOrderByInputCountDesc AppointmentProductLinkOrderByInput = "count_DESC"
)

type AppointmentServiceLinkOrderByInput string

const (
	AppointmentServiceLinkOrderByInputIDAsc  AppointmentServiceLinkOrderByInput = "id_ASC"
	AppointmentServiceLinkOrderByInputIDDesc AppointmentServiceLinkOrderByInput = "id_DESC"
)

type WorkingHoursOrderByInput string

const (
	WorkingHoursOrderByInputIDAsc              WorkingHoursOrderByInput = "id_ASC"
	WorkingHoursOrderByInputIDDesc             WorkingHoursOrderByInput = "id_DESC"
	WorkingHoursOrderByInputCreatedAtAsc       WorkingHoursOrderByInput = "createdAt_ASC"
	WorkingHoursOrderByInputCreatedAtDesc      WorkingHoursOrderByInput = "createdAt_DESC"
	WorkingHoursOrderByInputUpdatedAtAsc       WorkingHoursOrderByInput = "updatedAt_ASC"
	WorkingHoursOrderByInputUpdatedAtDesc      WorkingHoursOrderByInput = "updatedAt_DESC"
	WorkingHoursOrderByInputDayAsc             WorkingHoursOrderByInput = "day_ASC"
	WorkingHoursOrderByInputDayDesc            WorkingHoursOrderByInput = "day_DESC"
	WorkingHoursOrderByInputNotWorkingAsc      WorkingHoursOrderByInput = "notWorking_ASC"
	WorkingHoursOrderByInputNotWorkingDesc     WorkingHoursOrderByInput = "notWorking_DESC"
	WorkingHoursOrderByInputBreakAsc           WorkingHoursOrderByInput = "break_ASC"
	WorkingHoursOrderByInputBreakDesc          WorkingHoursOrderByInput = "break_DESC"
	WorkingHoursOrderByInputStartForenoonAsc   WorkingHoursOrderByInput = "startForenoon_ASC"
	WorkingHoursOrderByInputStartForenoonDesc  WorkingHoursOrderByInput = "startForenoon_DESC"
	WorkingHoursOrderByInputEndForenoonAsc     WorkingHoursOrderByInput = "endForenoon_ASC"
	WorkingHoursOrderByInputEndForenoonDesc    WorkingHoursOrderByInput = "endForenoon_DESC"
	WorkingHoursOrderByInputStartAfternoonAsc  WorkingHoursOrderByInput = "startAfternoon_ASC"
	WorkingHoursOrderByInputStartAfternoonDesc WorkingHoursOrderByInput = "startAfternoon_DESC"
	WorkingHoursOrderByInputEndAfternoonAsc    WorkingHoursOrderByInput = "endAfternoon_ASC"
	WorkingHoursOrderByInputEndAfternoonDesc   WorkingHoursOrderByInput = "endAfternoon_DESC"
	WorkingHoursOrderByInputStatusAsc          WorkingHoursOrderByInput = "status_ASC"
	WorkingHoursOrderByInputStatusDesc         WorkingHoursOrderByInput = "status_DESC"
)

type SessionOrderByInput string

const (
	SessionOrderByInputIDAsc         SessionOrderByInput = "id_ASC"
	SessionOrderByInputIDDesc        SessionOrderByInput = "id_DESC"
	SessionOrderByInputCreatedAtAsc  SessionOrderByInput = "createdAt_ASC"
	SessionOrderByInputCreatedAtDesc SessionOrderByInput = "createdAt_DESC"
	SessionOrderByInputUpdatedAtAsc  SessionOrderByInput = "updatedAt_ASC"
	SessionOrderByInputUpdatedAtDesc SessionOrderByInput = "updatedAt_DESC"
	SessionOrderByInputTokenAsc      SessionOrderByInput = "token_ASC"
	SessionOrderByInputTokenDesc     SessionOrderByInput = "token_DESC"
)

type BranchOrderByInput string

const (
	BranchOrderByInputIDAsc                  BranchOrderByInput = "id_ASC"
	BranchOrderByInputIDDesc                 BranchOrderByInput = "id_DESC"
	BranchOrderByInputCreatedAtAsc           BranchOrderByInput = "createdAt_ASC"
	BranchOrderByInputCreatedAtDesc          BranchOrderByInput = "createdAt_DESC"
	BranchOrderByInputUpdatedAtAsc           BranchOrderByInput = "updatedAt_ASC"
	BranchOrderByInputUpdatedAtDesc          BranchOrderByInput = "updatedAt_DESC"
	BranchOrderByInputPhoneNumberAsc         BranchOrderByInput = "phoneNumber_ASC"
	BranchOrderByInputPhoneNumberDesc        BranchOrderByInput = "phoneNumber_DESC"
	BranchOrderByInputAddressAsc             BranchOrderByInput = "address_ASC"
	BranchOrderByInputAddressDesc            BranchOrderByInput = "address_DESC"
	BranchOrderByInputWebsiteUrlAsc          BranchOrderByInput = "websiteUrl_ASC"
	BranchOrderByInputWebsiteUrlDesc         BranchOrderByInput = "websiteUrl_DESC"
	BranchOrderByInputNavigationLinkAsc      BranchOrderByInput = "navigationLink_ASC"
	BranchOrderByInputNavigationLinkDesc     BranchOrderByInput = "navigationLink_DESC"
	BranchOrderByInputSharingRedirectUrlAsc  BranchOrderByInput = "sharingRedirectUrl_ASC"
	BranchOrderByInputSharingRedirectUrlDesc BranchOrderByInput = "sharingRedirectUrl_DESC"
	BranchOrderByInputImprintAsc             BranchOrderByInput = "imprint_ASC"
	BranchOrderByInputImprintDesc            BranchOrderByInput = "imprint_DESC"
	BranchOrderByInputLogoAsc                BranchOrderByInput = "logo_ASC"
	BranchOrderByInputLogoDesc               BranchOrderByInput = "logo_DESC"
	BranchOrderByInputAppThemeAsc            BranchOrderByInput = "appTheme_ASC"
	BranchOrderByInputAppThemeDesc           BranchOrderByInput = "appTheme_DESC"
	BranchOrderByInputFacebookLinkAsc        BranchOrderByInput = "facebookLink_ASC"
	BranchOrderByInputFacebookLinkDesc       BranchOrderByInput = "facebookLink_DESC"
	BranchOrderByInputTiktokLinkAsc          BranchOrderByInput = "tiktokLink_ASC"
	BranchOrderByInputTiktokLinkDesc         BranchOrderByInput = "tiktokLink_DESC"
	BranchOrderByInputInstagramLinkAsc       BranchOrderByInput = "instagramLink_ASC"
	BranchOrderByInputInstagramLinkDesc      BranchOrderByInput = "instagramLink_DESC"
	BranchOrderByInputSmtpSendHostAsc        BranchOrderByInput = "smtpSendHost_ASC"
	BranchOrderByInputSmtpSendHostDesc       BranchOrderByInput = "smtpSendHost_DESC"
	BranchOrderByInputSmtpSendPortAsc        BranchOrderByInput = "smtpSendPort_ASC"
	BranchOrderByInputSmtpSendPortDesc       BranchOrderByInput = "smtpSendPort_DESC"
	BranchOrderByInputSmtpUsernameAsc        BranchOrderByInput = "smtpUsername_ASC"
	BranchOrderByInputSmtpUsernameDesc       BranchOrderByInput = "smtpUsername_DESC"
	BranchOrderByInputSmtpPasswordAsc        BranchOrderByInput = "smtpPassword_ASC"
	BranchOrderByInputSmtpPasswordDesc       BranchOrderByInput = "smtpPassword_DESC"
	BranchOrderByInputFromEmailAsc           BranchOrderByInput = "fromEmail_ASC"
	BranchOrderByInputFromEmailDesc          BranchOrderByInput = "fromEmail_DESC"
	BranchOrderByInputMailchimpApiKeyAsc     BranchOrderByInput = "mailchimpApiKey_ASC"
	BranchOrderByInputMailchimpApiKeyDesc    BranchOrderByInput = "mailchimpApiKey_DESC"
	BranchOrderByInputMailchimpListIdAsc     BranchOrderByInput = "mailchimpListId_ASC"
	BranchOrderByInputMailchimpListIdDesc    BranchOrderByInput = "mailchimpListId_DESC"
)

type AppointmentOrderByInput string

const (
	AppointmentOrderByInputIDAsc                            AppointmentOrderByInput = "id_ASC"
	AppointmentOrderByInputIDDesc                           AppointmentOrderByInput = "id_DESC"
	AppointmentOrderByInputCreatedAtAsc                     AppointmentOrderByInput = "createdAt_ASC"
	AppointmentOrderByInputCreatedAtDesc                    AppointmentOrderByInput = "createdAt_DESC"
	AppointmentOrderByInputUpdatedAtAsc                     AppointmentOrderByInput = "updatedAt_ASC"
	AppointmentOrderByInputUpdatedAtDesc                    AppointmentOrderByInput = "updatedAt_DESC"
	AppointmentOrderByInputStartAsc                         AppointmentOrderByInput = "start_ASC"
	AppointmentOrderByInputStartDesc                        AppointmentOrderByInput = "start_DESC"
	AppointmentOrderByInputEndAsc                           AppointmentOrderByInput = "end_ASC"
	AppointmentOrderByInputEndDesc                          AppointmentOrderByInput = "end_DESC"
	AppointmentOrderByInputPriceAsc                         AppointmentOrderByInput = "price_ASC"
	AppointmentOrderByInputPriceDesc                        AppointmentOrderByInput = "price_DESC"
	AppointmentOrderByInputStatusAsc                        AppointmentOrderByInput = "status_ASC"
	AppointmentOrderByInputStatusDesc                       AppointmentOrderByInput = "status_DESC"
	AppointmentOrderByInputCustomerNotifiedAsc              AppointmentOrderByInput = "customerNotified_ASC"
	AppointmentOrderByInputCustomerNotifiedDesc             AppointmentOrderByInput = "customerNotified_DESC"
	AppointmentOrderByInputCustomerNotifiedAnHourBeforeAsc  AppointmentOrderByInput = "customerNotifiedAnHourBefore_ASC"
	AppointmentOrderByInputCustomerNotifiedAnHourBeforeDesc AppointmentOrderByInput = "customerNotifiedAnHourBefore_DESC"
	AppointmentOrderByInputNoteAsc                          AppointmentOrderByInput = "note_ASC"
	AppointmentOrderByInputNoteDesc                         AppointmentOrderByInput = "note_DESC"
	AppointmentOrderByInputBeforeImageAsc                   AppointmentOrderByInput = "beforeImage_ASC"
	AppointmentOrderByInputBeforeImageDesc                  AppointmentOrderByInput = "beforeImage_DESC"
	AppointmentOrderByInputAfterImageAsc                    AppointmentOrderByInput = "afterImage_ASC"
	AppointmentOrderByInputAfterImageDesc                   AppointmentOrderByInput = "afterImage_DESC"
)

type CompanyOrderByInput string

const (
	CompanyOrderByInputIDAsc                  CompanyOrderByInput = "id_ASC"
	CompanyOrderByInputIDDesc                 CompanyOrderByInput = "id_DESC"
	CompanyOrderByInputCreatedAtAsc           CompanyOrderByInput = "createdAt_ASC"
	CompanyOrderByInputCreatedAtDesc          CompanyOrderByInput = "createdAt_DESC"
	CompanyOrderByInputUpdatedAtAsc           CompanyOrderByInput = "updatedAt_ASC"
	CompanyOrderByInputUpdatedAtDesc          CompanyOrderByInput = "updatedAt_DESC"
	CompanyOrderByInputSharingRedirectUrlAsc  CompanyOrderByInput = "sharingRedirectUrl_ASC"
	CompanyOrderByInputSharingRedirectUrlDesc CompanyOrderByInput = "sharingRedirectUrl_DESC"
	CompanyOrderByInputLogoAsc                CompanyOrderByInput = "logo_ASC"
	CompanyOrderByInputLogoDesc               CompanyOrderByInput = "logo_DESC"
	CompanyOrderByInputAppThemeAsc            CompanyOrderByInput = "appTheme_ASC"
	CompanyOrderByInputAppThemeDesc           CompanyOrderByInput = "appTheme_DESC"
	CompanyOrderByInputPwaIconAsc             CompanyOrderByInput = "pwaIcon_ASC"
	CompanyOrderByInputPwaIconDesc            CompanyOrderByInput = "pwaIcon_DESC"
	CompanyOrderByInputPwaThemeColorAsc       CompanyOrderByInput = "pwaThemeColor_ASC"
	CompanyOrderByInputPwaThemeColorDesc      CompanyOrderByInput = "pwaThemeColor_DESC"
	CompanyOrderByInputPwaBackgroundColorAsc  CompanyOrderByInput = "pwaBackgroundColor_ASC"
	CompanyOrderByInputPwaBackgroundColorDesc CompanyOrderByInput = "pwaBackgroundColor_DESC"
)

type EmailTemplateOrderByInput string

const (
	EmailTemplateOrderByInputIDAsc         EmailTemplateOrderByInput = "id_ASC"
	EmailTemplateOrderByInputIDDesc        EmailTemplateOrderByInput = "id_DESC"
	EmailTemplateOrderByInputCreatedAtAsc  EmailTemplateOrderByInput = "createdAt_ASC"
	EmailTemplateOrderByInputCreatedAtDesc EmailTemplateOrderByInput = "createdAt_DESC"
	EmailTemplateOrderByInputUpdatedAtAsc  EmailTemplateOrderByInput = "updatedAt_ASC"
	EmailTemplateOrderByInputUpdatedAtDesc EmailTemplateOrderByInput = "updatedAt_DESC"
	EmailTemplateOrderByInputNameAsc       EmailTemplateOrderByInput = "name_ASC"
	EmailTemplateOrderByInputNameDesc      EmailTemplateOrderByInput = "name_DESC"
)

type FavoriteOrderByInput string

const (
	FavoriteOrderByInputIDAsc  FavoriteOrderByInput = "id_ASC"
	FavoriteOrderByInputIDDesc FavoriteOrderByInput = "id_DESC"
)

type LocalizedStringOrderByInput string

const (
	LocalizedStringOrderByInputIDAsc  LocalizedStringOrderByInput = "id_ASC"
	LocalizedStringOrderByInputIDDesc LocalizedStringOrderByInput = "id_DESC"
	LocalizedStringOrderByInputDeAsc  LocalizedStringOrderByInput = "de_ASC"
	LocalizedStringOrderByInputDeDesc LocalizedStringOrderByInput = "de_DESC"
	LocalizedStringOrderByInputEnAsc  LocalizedStringOrderByInput = "en_ASC"
	LocalizedStringOrderByInputEnDesc LocalizedStringOrderByInput = "en_DESC"
	LocalizedStringOrderByInputTrAsc  LocalizedStringOrderByInput = "tr_ASC"
	LocalizedStringOrderByInputTrDesc LocalizedStringOrderByInput = "tr_DESC"
)

type PasswordTokenOrderByInput string

const (
	PasswordTokenOrderByInputIDAsc         PasswordTokenOrderByInput = "id_ASC"
	PasswordTokenOrderByInputIDDesc        PasswordTokenOrderByInput = "id_DESC"
	PasswordTokenOrderByInputCreatedAtAsc  PasswordTokenOrderByInput = "createdAt_ASC"
	PasswordTokenOrderByInputCreatedAtDesc PasswordTokenOrderByInput = "createdAt_DESC"
	PasswordTokenOrderByInputUpdatedAtAsc  PasswordTokenOrderByInput = "updatedAt_ASC"
	PasswordTokenOrderByInputUpdatedAtDesc PasswordTokenOrderByInput = "updatedAt_DESC"
	PasswordTokenOrderByInputTokenAsc      PasswordTokenOrderByInput = "token_ASC"
	PasswordTokenOrderByInputTokenDesc     PasswordTokenOrderByInput = "token_DESC"
)

type ProductCategoryOrderByInput string

const (
	ProductCategoryOrderByInputIDAsc         ProductCategoryOrderByInput = "id_ASC"
	ProductCategoryOrderByInputIDDesc        ProductCategoryOrderByInput = "id_DESC"
	ProductCategoryOrderByInputCreatedAtAsc  ProductCategoryOrderByInput = "createdAt_ASC"
	ProductCategoryOrderByInputCreatedAtDesc ProductCategoryOrderByInput = "createdAt_DESC"
	ProductCategoryOrderByInputUpdatedAtAsc  ProductCategoryOrderByInput = "updatedAt_ASC"
	ProductCategoryOrderByInputUpdatedAtDesc ProductCategoryOrderByInput = "updatedAt_DESC"
	ProductCategoryOrderByInputNameAsc       ProductCategoryOrderByInput = "name_ASC"
	ProductCategoryOrderByInputNameDesc      ProductCategoryOrderByInput = "name_DESC"
)

type ServiceCategoryOrderByInput string

const (
	ServiceCategoryOrderByInputIDAsc         ServiceCategoryOrderByInput = "id_ASC"
	ServiceCategoryOrderByInputIDDesc        ServiceCategoryOrderByInput = "id_DESC"
	ServiceCategoryOrderByInputCreatedAtAsc  ServiceCategoryOrderByInput = "createdAt_ASC"
	ServiceCategoryOrderByInputCreatedAtDesc ServiceCategoryOrderByInput = "createdAt_DESC"
	ServiceCategoryOrderByInputUpdatedAtAsc  ServiceCategoryOrderByInput = "updatedAt_ASC"
	ServiceCategoryOrderByInputUpdatedAtDesc ServiceCategoryOrderByInput = "updatedAt_DESC"
	ServiceCategoryOrderByInputNameAsc       ServiceCategoryOrderByInput = "name_ASC"
	ServiceCategoryOrderByInputNameDesc      ServiceCategoryOrderByInput = "name_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type AliasWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

type CustomUrlWhereInput struct {
	ID                 *string               `json:"id,omitempty"`
	IDNot              *string               `json:"id_not,omitempty"`
	IDIn               []string              `json:"id_in,omitempty"`
	IDNotIn            []string              `json:"id_not_in,omitempty"`
	IDLt               *string               `json:"id_lt,omitempty"`
	IDLte              *string               `json:"id_lte,omitempty"`
	IDGt               *string               `json:"id_gt,omitempty"`
	IDGte              *string               `json:"id_gte,omitempty"`
	IDContains         *string               `json:"id_contains,omitempty"`
	IDNotContains      *string               `json:"id_not_contains,omitempty"`
	IDStartsWith       *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string               `json:"id_not_ends_with,omitempty"`
	Company            *CompanyWhereInput    `json:"company,omitempty"`
	Value              *string               `json:"value,omitempty"`
	ValueNot           *string               `json:"value_not,omitempty"`
	ValueIn            []string              `json:"value_in,omitempty"`
	ValueNotIn         []string              `json:"value_not_in,omitempty"`
	ValueLt            *string               `json:"value_lt,omitempty"`
	ValueLte           *string               `json:"value_lte,omitempty"`
	ValueGt            *string               `json:"value_gt,omitempty"`
	ValueGte           *string               `json:"value_gte,omitempty"`
	ValueContains      *string               `json:"value_contains,omitempty"`
	ValueNotContains   *string               `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string               `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string               `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string               `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string               `json:"value_not_ends_with,omitempty"`
	And                []CustomUrlWhereInput `json:"AND,omitempty"`
	Or                 []CustomUrlWhereInput `json:"OR,omitempty"`
	Not                []CustomUrlWhereInput `json:"NOT,omitempty"`
}

type CompanyWhereInput struct {
	ID                              *string                    `json:"id,omitempty"`
	IDNot                           *string                    `json:"id_not,omitempty"`
	IDIn                            []string                   `json:"id_in,omitempty"`
	IDNotIn                         []string                   `json:"id_not_in,omitempty"`
	IDLt                            *string                    `json:"id_lt,omitempty"`
	IDLte                           *string                    `json:"id_lte,omitempty"`
	IDGt                            *string                    `json:"id_gt,omitempty"`
	IDGte                           *string                    `json:"id_gte,omitempty"`
	IDContains                      *string                    `json:"id_contains,omitempty"`
	IDNotContains                   *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith                    *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith                 *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                      *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith                   *string                    `json:"id_not_ends_with,omitempty"`
	CreatedAt                       *string                    `json:"createdAt,omitempty"`
	CreatedAtNot                    *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                       *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot                    *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                     []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                  []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                     *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                    *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                     *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                    *string                    `json:"updatedAt_gte,omitempty"`
	Name                            *LocalizedStringWhereInput `json:"name,omitempty"`
	CustomUrlsEvery                 *CustomUrlWhereInput       `json:"customUrls_every,omitempty"`
	CustomUrlsSome                  *CustomUrlWhereInput       `json:"customUrls_some,omitempty"`
	CustomUrlsNone                  *CustomUrlWhereInput       `json:"customUrls_none,omitempty"`
	AliasesEvery                    *AliasWhereInput           `json:"aliases_every,omitempty"`
	AliasesSome                     *AliasWhereInput           `json:"aliases_some,omitempty"`
	AliasesNone                     *AliasWhereInput           `json:"aliases_none,omitempty"`
	SharingRedirectUrl              *string                    `json:"sharingRedirectUrl,omitempty"`
	SharingRedirectUrlNot           *string                    `json:"sharingRedirectUrl_not,omitempty"`
	SharingRedirectUrlIn            []string                   `json:"sharingRedirectUrl_in,omitempty"`
	SharingRedirectUrlNotIn         []string                   `json:"sharingRedirectUrl_not_in,omitempty"`
	SharingRedirectUrlLt            *string                    `json:"sharingRedirectUrl_lt,omitempty"`
	SharingRedirectUrlLte           *string                    `json:"sharingRedirectUrl_lte,omitempty"`
	SharingRedirectUrlGt            *string                    `json:"sharingRedirectUrl_gt,omitempty"`
	SharingRedirectUrlGte           *string                    `json:"sharingRedirectUrl_gte,omitempty"`
	SharingRedirectUrlContains      *string                    `json:"sharingRedirectUrl_contains,omitempty"`
	SharingRedirectUrlNotContains   *string                    `json:"sharingRedirectUrl_not_contains,omitempty"`
	SharingRedirectUrlStartsWith    *string                    `json:"sharingRedirectUrl_starts_with,omitempty"`
	SharingRedirectUrlNotStartsWith *string                    `json:"sharingRedirectUrl_not_starts_with,omitempty"`
	SharingRedirectUrlEndsWith      *string                    `json:"sharingRedirectUrl_ends_with,omitempty"`
	SharingRedirectUrlNotEndsWith   *string                    `json:"sharingRedirectUrl_not_ends_with,omitempty"`
	Logo                            *string                    `json:"logo,omitempty"`
	LogoNot                         *string                    `json:"logo_not,omitempty"`
	LogoIn                          []string                   `json:"logo_in,omitempty"`
	LogoNotIn                       []string                   `json:"logo_not_in,omitempty"`
	LogoLt                          *string                    `json:"logo_lt,omitempty"`
	LogoLte                         *string                    `json:"logo_lte,omitempty"`
	LogoGt                          *string                    `json:"logo_gt,omitempty"`
	LogoGte                         *string                    `json:"logo_gte,omitempty"`
	LogoContains                    *string                    `json:"logo_contains,omitempty"`
	LogoNotContains                 *string                    `json:"logo_not_contains,omitempty"`
	LogoStartsWith                  *string                    `json:"logo_starts_with,omitempty"`
	LogoNotStartsWith               *string                    `json:"logo_not_starts_with,omitempty"`
	LogoEndsWith                    *string                    `json:"logo_ends_with,omitempty"`
	LogoNotEndsWith                 *string                    `json:"logo_not_ends_with,omitempty"`
	AppTheme                        *string                    `json:"appTheme,omitempty"`
	AppThemeNot                     *string                    `json:"appTheme_not,omitempty"`
	AppThemeIn                      []string                   `json:"appTheme_in,omitempty"`
	AppThemeNotIn                   []string                   `json:"appTheme_not_in,omitempty"`
	AppThemeLt                      *string                    `json:"appTheme_lt,omitempty"`
	AppThemeLte                     *string                    `json:"appTheme_lte,omitempty"`
	AppThemeGt                      *string                    `json:"appTheme_gt,omitempty"`
	AppThemeGte                     *string                    `json:"appTheme_gte,omitempty"`
	AppThemeContains                *string                    `json:"appTheme_contains,omitempty"`
	AppThemeNotContains             *string                    `json:"appTheme_not_contains,omitempty"`
	AppThemeStartsWith              *string                    `json:"appTheme_starts_with,omitempty"`
	AppThemeNotStartsWith           *string                    `json:"appTheme_not_starts_with,omitempty"`
	AppThemeEndsWith                *string                    `json:"appTheme_ends_with,omitempty"`
	AppThemeNotEndsWith             *string                    `json:"appTheme_not_ends_with,omitempty"`
	PwaShortName                    *LocalizedStringWhereInput `json:"pwaShortName,omitempty"`
	PwaIcon                         *string                    `json:"pwaIcon,omitempty"`
	PwaIconNot                      *string                    `json:"pwaIcon_not,omitempty"`
	PwaIconIn                       []string                   `json:"pwaIcon_in,omitempty"`
	PwaIconNotIn                    []string                   `json:"pwaIcon_not_in,omitempty"`
	PwaIconLt                       *string                    `json:"pwaIcon_lt,omitempty"`
	PwaIconLte                      *string                    `json:"pwaIcon_lte,omitempty"`
	PwaIconGt                       *string                    `json:"pwaIcon_gt,omitempty"`
	PwaIconGte                      *string                    `json:"pwaIcon_gte,omitempty"`
	PwaIconContains                 *string                    `json:"pwaIcon_contains,omitempty"`
	PwaIconNotContains              *string                    `json:"pwaIcon_not_contains,omitempty"`
	PwaIconStartsWith               *string                    `json:"pwaIcon_starts_with,omitempty"`
	PwaIconNotStartsWith            *string                    `json:"pwaIcon_not_starts_with,omitempty"`
	PwaIconEndsWith                 *string                    `json:"pwaIcon_ends_with,omitempty"`
	PwaIconNotEndsWith              *string                    `json:"pwaIcon_not_ends_with,omitempty"`
	PwaThemeColor                   *string                    `json:"pwaThemeColor,omitempty"`
	PwaThemeColorNot                *string                    `json:"pwaThemeColor_not,omitempty"`
	PwaThemeColorIn                 []string                   `json:"pwaThemeColor_in,omitempty"`
	PwaThemeColorNotIn              []string                   `json:"pwaThemeColor_not_in,omitempty"`
	PwaThemeColorLt                 *string                    `json:"pwaThemeColor_lt,omitempty"`
	PwaThemeColorLte                *string                    `json:"pwaThemeColor_lte,omitempty"`
	PwaThemeColorGt                 *string                    `json:"pwaThemeColor_gt,omitempty"`
	PwaThemeColorGte                *string                    `json:"pwaThemeColor_gte,omitempty"`
	PwaThemeColorContains           *string                    `json:"pwaThemeColor_contains,omitempty"`
	PwaThemeColorNotContains        *string                    `json:"pwaThemeColor_not_contains,omitempty"`
	PwaThemeColorStartsWith         *string                    `json:"pwaThemeColor_starts_with,omitempty"`
	PwaThemeColorNotStartsWith      *string                    `json:"pwaThemeColor_not_starts_with,omitempty"`
	PwaThemeColorEndsWith           *string                    `json:"pwaThemeColor_ends_with,omitempty"`
	PwaThemeColorNotEndsWith        *string                    `json:"pwaThemeColor_not_ends_with,omitempty"`
	PwaBackgroundColor              *string                    `json:"pwaBackgroundColor,omitempty"`
	PwaBackgroundColorNot           *string                    `json:"pwaBackgroundColor_not,omitempty"`
	PwaBackgroundColorIn            []string                   `json:"pwaBackgroundColor_in,omitempty"`
	PwaBackgroundColorNotIn         []string                   `json:"pwaBackgroundColor_not_in,omitempty"`
	PwaBackgroundColorLt            *string                    `json:"pwaBackgroundColor_lt,omitempty"`
	PwaBackgroundColorLte           *string                    `json:"pwaBackgroundColor_lte,omitempty"`
	PwaBackgroundColorGt            *string                    `json:"pwaBackgroundColor_gt,omitempty"`
	PwaBackgroundColorGte           *string                    `json:"pwaBackgroundColor_gte,omitempty"`
	PwaBackgroundColorContains      *string                    `json:"pwaBackgroundColor_contains,omitempty"`
	PwaBackgroundColorNotContains   *string                    `json:"pwaBackgroundColor_not_contains,omitempty"`
	PwaBackgroundColorStartsWith    *string                    `json:"pwaBackgroundColor_starts_with,omitempty"`
	PwaBackgroundColorNotStartsWith *string                    `json:"pwaBackgroundColor_not_starts_with,omitempty"`
	PwaBackgroundColorEndsWith      *string                    `json:"pwaBackgroundColor_ends_with,omitempty"`
	PwaBackgroundColorNotEndsWith   *string                    `json:"pwaBackgroundColor_not_ends_with,omitempty"`
	UsersEvery                      *UserWhereInput            `json:"users_every,omitempty"`
	UsersSome                       *UserWhereInput            `json:"users_some,omitempty"`
	UsersNone                       *UserWhereInput            `json:"users_none,omitempty"`
	BranchesEvery                   *BranchWhereInput          `json:"branches_every,omitempty"`
	BranchesSome                    *BranchWhereInput          `json:"branches_some,omitempty"`
	BranchesNone                    *BranchWhereInput          `json:"branches_none,omitempty"`
	And                             []CompanyWhereInput        `json:"AND,omitempty"`
	Or                              []CompanyWhereInput        `json:"OR,omitempty"`
	Not                             []CompanyWhereInput        `json:"NOT,omitempty"`
}

type LocalizedStringWhereInput struct {
	ID              *string                     `json:"id,omitempty"`
	IDNot           *string                     `json:"id_not,omitempty"`
	IDIn            []string                    `json:"id_in,omitempty"`
	IDNotIn         []string                    `json:"id_not_in,omitempty"`
	IDLt            *string                     `json:"id_lt,omitempty"`
	IDLte           *string                     `json:"id_lte,omitempty"`
	IDGt            *string                     `json:"id_gt,omitempty"`
	IDGte           *string                     `json:"id_gte,omitempty"`
	IDContains      *string                     `json:"id_contains,omitempty"`
	IDNotContains   *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                     `json:"id_not_ends_with,omitempty"`
	De              *string                     `json:"de,omitempty"`
	DeNot           *string                     `json:"de_not,omitempty"`
	DeIn            []string                    `json:"de_in,omitempty"`
	DeNotIn         []string                    `json:"de_not_in,omitempty"`
	DeLt            *string                     `json:"de_lt,omitempty"`
	DeLte           *string                     `json:"de_lte,omitempty"`
	DeGt            *string                     `json:"de_gt,omitempty"`
	DeGte           *string                     `json:"de_gte,omitempty"`
	DeContains      *string                     `json:"de_contains,omitempty"`
	DeNotContains   *string                     `json:"de_not_contains,omitempty"`
	DeStartsWith    *string                     `json:"de_starts_with,omitempty"`
	DeNotStartsWith *string                     `json:"de_not_starts_with,omitempty"`
	DeEndsWith      *string                     `json:"de_ends_with,omitempty"`
	DeNotEndsWith   *string                     `json:"de_not_ends_with,omitempty"`
	En              *string                     `json:"en,omitempty"`
	EnNot           *string                     `json:"en_not,omitempty"`
	EnIn            []string                    `json:"en_in,omitempty"`
	EnNotIn         []string                    `json:"en_not_in,omitempty"`
	EnLt            *string                     `json:"en_lt,omitempty"`
	EnLte           *string                     `json:"en_lte,omitempty"`
	EnGt            *string                     `json:"en_gt,omitempty"`
	EnGte           *string                     `json:"en_gte,omitempty"`
	EnContains      *string                     `json:"en_contains,omitempty"`
	EnNotContains   *string                     `json:"en_not_contains,omitempty"`
	EnStartsWith    *string                     `json:"en_starts_with,omitempty"`
	EnNotStartsWith *string                     `json:"en_not_starts_with,omitempty"`
	EnEndsWith      *string                     `json:"en_ends_with,omitempty"`
	EnNotEndsWith   *string                     `json:"en_not_ends_with,omitempty"`
	Tr              *string                     `json:"tr,omitempty"`
	TrNot           *string                     `json:"tr_not,omitempty"`
	TrIn            []string                    `json:"tr_in,omitempty"`
	TrNotIn         []string                    `json:"tr_not_in,omitempty"`
	TrLt            *string                     `json:"tr_lt,omitempty"`
	TrLte           *string                     `json:"tr_lte,omitempty"`
	TrGt            *string                     `json:"tr_gt,omitempty"`
	TrGte           *string                     `json:"tr_gte,omitempty"`
	TrContains      *string                     `json:"tr_contains,omitempty"`
	TrNotContains   *string                     `json:"tr_not_contains,omitempty"`
	TrStartsWith    *string                     `json:"tr_starts_with,omitempty"`
	TrNotStartsWith *string                     `json:"tr_not_starts_with,omitempty"`
	TrEndsWith      *string                     `json:"tr_ends_with,omitempty"`
	TrNotEndsWith   *string                     `json:"tr_not_ends_with,omitempty"`
	And             []LocalizedStringWhereInput `json:"AND,omitempty"`
	Or              []LocalizedStringWhereInput `json:"OR,omitempty"`
	Not             []LocalizedStringWhereInput `json:"NOT,omitempty"`
}

type AliasWhereInput struct {
	ID                 *string            `json:"id,omitempty"`
	IDNot              *string            `json:"id_not,omitempty"`
	IDIn               []string           `json:"id_in,omitempty"`
	IDNotIn            []string           `json:"id_not_in,omitempty"`
	IDLt               *string            `json:"id_lt,omitempty"`
	IDLte              *string            `json:"id_lte,omitempty"`
	IDGt               *string            `json:"id_gt,omitempty"`
	IDGte              *string            `json:"id_gte,omitempty"`
	IDContains         *string            `json:"id_contains,omitempty"`
	IDNotContains      *string            `json:"id_not_contains,omitempty"`
	IDStartsWith       *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string            `json:"id_not_ends_with,omitempty"`
	Company            *CompanyWhereInput `json:"company,omitempty"`
	Value              *string            `json:"value,omitempty"`
	ValueNot           *string            `json:"value_not,omitempty"`
	ValueIn            []string           `json:"value_in,omitempty"`
	ValueNotIn         []string           `json:"value_not_in,omitempty"`
	ValueLt            *string            `json:"value_lt,omitempty"`
	ValueLte           *string            `json:"value_lte,omitempty"`
	ValueGt            *string            `json:"value_gt,omitempty"`
	ValueGte           *string            `json:"value_gte,omitempty"`
	ValueContains      *string            `json:"value_contains,omitempty"`
	ValueNotContains   *string            `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string            `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string            `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string            `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string            `json:"value_not_ends_with,omitempty"`
	And                []AliasWhereInput  `json:"AND,omitempty"`
	Or                 []AliasWhereInput  `json:"OR,omitempty"`
	Not                []AliasWhereInput  `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                             *string                  `json:"id,omitempty"`
	IDNot                          *string                  `json:"id_not,omitempty"`
	IDIn                           []string                 `json:"id_in,omitempty"`
	IDNotIn                        []string                 `json:"id_not_in,omitempty"`
	IDLt                           *string                  `json:"id_lt,omitempty"`
	IDLte                          *string                  `json:"id_lte,omitempty"`
	IDGt                           *string                  `json:"id_gt,omitempty"`
	IDGte                          *string                  `json:"id_gte,omitempty"`
	IDContains                     *string                  `json:"id_contains,omitempty"`
	IDNotContains                  *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                      *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                  `json:"updatedAt_gte,omitempty"`
	Type                           *UserType                `json:"type,omitempty"`
	TypeNot                        *UserType                `json:"type_not,omitempty"`
	TypeIn                         []UserType               `json:"type_in,omitempty"`
	TypeNotIn                      []UserType               `json:"type_not_in,omitempty"`
	Email                          *string                  `json:"email,omitempty"`
	EmailNot                       *string                  `json:"email_not,omitempty"`
	EmailIn                        []string                 `json:"email_in,omitempty"`
	EmailNotIn                     []string                 `json:"email_not_in,omitempty"`
	EmailLt                        *string                  `json:"email_lt,omitempty"`
	EmailLte                       *string                  `json:"email_lte,omitempty"`
	EmailGt                        *string                  `json:"email_gt,omitempty"`
	EmailGte                       *string                  `json:"email_gte,omitempty"`
	EmailContains                  *string                  `json:"email_contains,omitempty"`
	EmailNotContains               *string                  `json:"email_not_contains,omitempty"`
	EmailStartsWith                *string                  `json:"email_starts_with,omitempty"`
	EmailNotStartsWith             *string                  `json:"email_not_starts_with,omitempty"`
	EmailEndsWith                  *string                  `json:"email_ends_with,omitempty"`
	EmailNotEndsWith               *string                  `json:"email_not_ends_with,omitempty"`
	PasswordHash                   *string                  `json:"passwordHash,omitempty"`
	PasswordHashNot                *string                  `json:"passwordHash_not,omitempty"`
	PasswordHashIn                 []string                 `json:"passwordHash_in,omitempty"`
	PasswordHashNotIn              []string                 `json:"passwordHash_not_in,omitempty"`
	PasswordHashLt                 *string                  `json:"passwordHash_lt,omitempty"`
	PasswordHashLte                *string                  `json:"passwordHash_lte,omitempty"`
	PasswordHashGt                 *string                  `json:"passwordHash_gt,omitempty"`
	PasswordHashGte                *string                  `json:"passwordHash_gte,omitempty"`
	PasswordHashContains           *string                  `json:"passwordHash_contains,omitempty"`
	PasswordHashNotContains        *string                  `json:"passwordHash_not_contains,omitempty"`
	PasswordHashStartsWith         *string                  `json:"passwordHash_starts_with,omitempty"`
	PasswordHashNotStartsWith      *string                  `json:"passwordHash_not_starts_with,omitempty"`
	PasswordHashEndsWith           *string                  `json:"passwordHash_ends_with,omitempty"`
	PasswordHashNotEndsWith        *string                  `json:"passwordHash_not_ends_with,omitempty"`
	FirstName                      *string                  `json:"firstName,omitempty"`
	FirstNameNot                   *string                  `json:"firstName_not,omitempty"`
	FirstNameIn                    []string                 `json:"firstName_in,omitempty"`
	FirstNameNotIn                 []string                 `json:"firstName_not_in,omitempty"`
	FirstNameLt                    *string                  `json:"firstName_lt,omitempty"`
	FirstNameLte                   *string                  `json:"firstName_lte,omitempty"`
	FirstNameGt                    *string                  `json:"firstName_gt,omitempty"`
	FirstNameGte                   *string                  `json:"firstName_gte,omitempty"`
	FirstNameContains              *string                  `json:"firstName_contains,omitempty"`
	FirstNameNotContains           *string                  `json:"firstName_not_contains,omitempty"`
	FirstNameStartsWith            *string                  `json:"firstName_starts_with,omitempty"`
	FirstNameNotStartsWith         *string                  `json:"firstName_not_starts_with,omitempty"`
	FirstNameEndsWith              *string                  `json:"firstName_ends_with,omitempty"`
	FirstNameNotEndsWith           *string                  `json:"firstName_not_ends_with,omitempty"`
	LastName                       *string                  `json:"lastName,omitempty"`
	LastNameNot                    *string                  `json:"lastName_not,omitempty"`
	LastNameIn                     []string                 `json:"lastName_in,omitempty"`
	LastNameNotIn                  []string                 `json:"lastName_not_in,omitempty"`
	LastNameLt                     *string                  `json:"lastName_lt,omitempty"`
	LastNameLte                    *string                  `json:"lastName_lte,omitempty"`
	LastNameGt                     *string                  `json:"lastName_gt,omitempty"`
	LastNameGte                    *string                  `json:"lastName_gte,omitempty"`
	LastNameContains               *string                  `json:"lastName_contains,omitempty"`
	LastNameNotContains            *string                  `json:"lastName_not_contains,omitempty"`
	LastNameStartsWith             *string                  `json:"lastName_starts_with,omitempty"`
	LastNameNotStartsWith          *string                  `json:"lastName_not_starts_with,omitempty"`
	LastNameEndsWith               *string                  `json:"lastName_ends_with,omitempty"`
	LastNameNotEndsWith            *string                  `json:"lastName_not_ends_with,omitempty"`
	Gender                         *Gender                  `json:"gender,omitempty"`
	GenderNot                      *Gender                  `json:"gender_not,omitempty"`
	GenderIn                       []Gender                 `json:"gender_in,omitempty"`
	GenderNotIn                    []Gender                 `json:"gender_not_in,omitempty"`
	ZipCode                        *string                  `json:"zipCode,omitempty"`
	ZipCodeNot                     *string                  `json:"zipCode_not,omitempty"`
	ZipCodeIn                      []string                 `json:"zipCode_in,omitempty"`
	ZipCodeNotIn                   []string                 `json:"zipCode_not_in,omitempty"`
	ZipCodeLt                      *string                  `json:"zipCode_lt,omitempty"`
	ZipCodeLte                     *string                  `json:"zipCode_lte,omitempty"`
	ZipCodeGt                      *string                  `json:"zipCode_gt,omitempty"`
	ZipCodeGte                     *string                  `json:"zipCode_gte,omitempty"`
	ZipCodeContains                *string                  `json:"zipCode_contains,omitempty"`
	ZipCodeNotContains             *string                  `json:"zipCode_not_contains,omitempty"`
	ZipCodeStartsWith              *string                  `json:"zipCode_starts_with,omitempty"`
	ZipCodeNotStartsWith           *string                  `json:"zipCode_not_starts_with,omitempty"`
	ZipCodeEndsWith                *string                  `json:"zipCode_ends_with,omitempty"`
	ZipCodeNotEndsWith             *string                  `json:"zipCode_not_ends_with,omitempty"`
	Street                         *string                  `json:"street,omitempty"`
	StreetNot                      *string                  `json:"street_not,omitempty"`
	StreetIn                       []string                 `json:"street_in,omitempty"`
	StreetNotIn                    []string                 `json:"street_not_in,omitempty"`
	StreetLt                       *string                  `json:"street_lt,omitempty"`
	StreetLte                      *string                  `json:"street_lte,omitempty"`
	StreetGt                       *string                  `json:"street_gt,omitempty"`
	StreetGte                      *string                  `json:"street_gte,omitempty"`
	StreetContains                 *string                  `json:"street_contains,omitempty"`
	StreetNotContains              *string                  `json:"street_not_contains,omitempty"`
	StreetStartsWith               *string                  `json:"street_starts_with,omitempty"`
	StreetNotStartsWith            *string                  `json:"street_not_starts_with,omitempty"`
	StreetEndsWith                 *string                  `json:"street_ends_with,omitempty"`
	StreetNotEndsWith              *string                  `json:"street_not_ends_with,omitempty"`
	City                           *string                  `json:"city,omitempty"`
	CityNot                        *string                  `json:"city_not,omitempty"`
	CityIn                         []string                 `json:"city_in,omitempty"`
	CityNotIn                      []string                 `json:"city_not_in,omitempty"`
	CityLt                         *string                  `json:"city_lt,omitempty"`
	CityLte                        *string                  `json:"city_lte,omitempty"`
	CityGt                         *string                  `json:"city_gt,omitempty"`
	CityGte                        *string                  `json:"city_gte,omitempty"`
	CityContains                   *string                  `json:"city_contains,omitempty"`
	CityNotContains                *string                  `json:"city_not_contains,omitempty"`
	CityStartsWith                 *string                  `json:"city_starts_with,omitempty"`
	CityNotStartsWith              *string                  `json:"city_not_starts_with,omitempty"`
	CityEndsWith                   *string                  `json:"city_ends_with,omitempty"`
	CityNotEndsWith                *string                  `json:"city_not_ends_with,omitempty"`
	Birthday                       *string                  `json:"birthday,omitempty"`
	BirthdayNot                    *string                  `json:"birthday_not,omitempty"`
	BirthdayIn                     []string                 `json:"birthday_in,omitempty"`
	BirthdayNotIn                  []string                 `json:"birthday_not_in,omitempty"`
	BirthdayLt                     *string                  `json:"birthday_lt,omitempty"`
	BirthdayLte                    *string                  `json:"birthday_lte,omitempty"`
	BirthdayGt                     *string                  `json:"birthday_gt,omitempty"`
	BirthdayGte                    *string                  `json:"birthday_gte,omitempty"`
	Birthdate                      *string                  `json:"birthdate,omitempty"`
	BirthdateNot                   *string                  `json:"birthdate_not,omitempty"`
	BirthdateIn                    []string                 `json:"birthdate_in,omitempty"`
	BirthdateNotIn                 []string                 `json:"birthdate_not_in,omitempty"`
	BirthdateLt                    *string                  `json:"birthdate_lt,omitempty"`
	BirthdateLte                   *string                  `json:"birthdate_lte,omitempty"`
	BirthdateGt                    *string                  `json:"birthdate_gt,omitempty"`
	BirthdateGte                   *string                  `json:"birthdate_gte,omitempty"`
	BirthdateContains              *string                  `json:"birthdate_contains,omitempty"`
	BirthdateNotContains           *string                  `json:"birthdate_not_contains,omitempty"`
	BirthdateStartsWith            *string                  `json:"birthdate_starts_with,omitempty"`
	BirthdateNotStartsWith         *string                  `json:"birthdate_not_starts_with,omitempty"`
	BirthdateEndsWith              *string                  `json:"birthdate_ends_with,omitempty"`
	BirthdateNotEndsWith           *string                  `json:"birthdate_not_ends_with,omitempty"`
	PhoneNumber                    *string                  `json:"phoneNumber,omitempty"`
	PhoneNumberNot                 *string                  `json:"phoneNumber_not,omitempty"`
	PhoneNumberIn                  []string                 `json:"phoneNumber_in,omitempty"`
	PhoneNumberNotIn               []string                 `json:"phoneNumber_not_in,omitempty"`
	PhoneNumberLt                  *string                  `json:"phoneNumber_lt,omitempty"`
	PhoneNumberLte                 *string                  `json:"phoneNumber_lte,omitempty"`
	PhoneNumberGt                  *string                  `json:"phoneNumber_gt,omitempty"`
	PhoneNumberGte                 *string                  `json:"phoneNumber_gte,omitempty"`
	PhoneNumberContains            *string                  `json:"phoneNumber_contains,omitempty"`
	PhoneNumberNotContains         *string                  `json:"phoneNumber_not_contains,omitempty"`
	PhoneNumberStartsWith          *string                  `json:"phoneNumber_starts_with,omitempty"`
	PhoneNumberNotStartsWith       *string                  `json:"phoneNumber_not_starts_with,omitempty"`
	PhoneNumberEndsWith            *string                  `json:"phoneNumber_ends_with,omitempty"`
	PhoneNumberNotEndsWith         *string                  `json:"phoneNumber_not_ends_with,omitempty"`
	Image                          *string                  `json:"image,omitempty"`
	ImageNot                       *string                  `json:"image_not,omitempty"`
	ImageIn                        []string                 `json:"image_in,omitempty"`
	ImageNotIn                     []string                 `json:"image_not_in,omitempty"`
	ImageLt                        *string                  `json:"image_lt,omitempty"`
	ImageLte                       *string                  `json:"image_lte,omitempty"`
	ImageGt                        *string                  `json:"image_gt,omitempty"`
	ImageGte                       *string                  `json:"image_gte,omitempty"`
	ImageContains                  *string                  `json:"image_contains,omitempty"`
	ImageNotContains               *string                  `json:"image_not_contains,omitempty"`
	ImageStartsWith                *string                  `json:"image_starts_with,omitempty"`
	ImageNotStartsWith             *string                  `json:"image_not_starts_with,omitempty"`
	ImageEndsWith                  *string                  `json:"image_ends_with,omitempty"`
	ImageNotEndsWith               *string                  `json:"image_not_ends_with,omitempty"`
	Company                        *CompanyWhereInput       `json:"company,omitempty"`
	Note                           *string                  `json:"note,omitempty"`
	NoteNot                        *string                  `json:"note_not,omitempty"`
	NoteIn                         []string                 `json:"note_in,omitempty"`
	NoteNotIn                      []string                 `json:"note_not_in,omitempty"`
	NoteLt                         *string                  `json:"note_lt,omitempty"`
	NoteLte                        *string                  `json:"note_lte,omitempty"`
	NoteGt                         *string                  `json:"note_gt,omitempty"`
	NoteGte                        *string                  `json:"note_gte,omitempty"`
	NoteContains                   *string                  `json:"note_contains,omitempty"`
	NoteNotContains                *string                  `json:"note_not_contains,omitempty"`
	NoteStartsWith                 *string                  `json:"note_starts_with,omitempty"`
	NoteNotStartsWith              *string                  `json:"note_not_starts_with,omitempty"`
	NoteEndsWith                   *string                  `json:"note_ends_with,omitempty"`
	NoteNotEndsWith                *string                  `json:"note_not_ends_with,omitempty"`
	ReviewsEvery                   *ReviewWhereInput        `json:"reviews_every,omitempty"`
	ReviewsSome                    *ReviewWhereInput        `json:"reviews_some,omitempty"`
	ReviewsNone                    *ReviewWhereInput        `json:"reviews_none,omitempty"`
	AllowReviewSharing             *bool                    `json:"allowReviewSharing,omitempty"`
	AllowReviewSharingNot          *bool                    `json:"allowReviewSharing_not,omitempty"`
	Branch                         *BranchWhereInput        `json:"branch,omitempty"`
	WorkingHoursEvery              *WorkingHoursWhereInput  `json:"workingHours_every,omitempty"`
	WorkingHoursSome               *WorkingHoursWhereInput  `json:"workingHours_some,omitempty"`
	WorkingHoursNone               *WorkingHoursWhereInput  `json:"workingHours_none,omitempty"`
	SessionsEvery                  *SessionWhereInput       `json:"sessions_every,omitempty"`
	SessionsSome                   *SessionWhereInput       `json:"sessions_some,omitempty"`
	SessionsNone                   *SessionWhereInput       `json:"sessions_none,omitempty"`
	NotificationToken              *string                  `json:"notificationToken,omitempty"`
	NotificationTokenNot           *string                  `json:"notificationToken_not,omitempty"`
	NotificationTokenIn            []string                 `json:"notificationToken_in,omitempty"`
	NotificationTokenNotIn         []string                 `json:"notificationToken_not_in,omitempty"`
	NotificationTokenLt            *string                  `json:"notificationToken_lt,omitempty"`
	NotificationTokenLte           *string                  `json:"notificationToken_lte,omitempty"`
	NotificationTokenGt            *string                  `json:"notificationToken_gt,omitempty"`
	NotificationTokenGte           *string                  `json:"notificationToken_gte,omitempty"`
	NotificationTokenContains      *string                  `json:"notificationToken_contains,omitempty"`
	NotificationTokenNotContains   *string                  `json:"notificationToken_not_contains,omitempty"`
	NotificationTokenStartsWith    *string                  `json:"notificationToken_starts_with,omitempty"`
	NotificationTokenNotStartsWith *string                  `json:"notificationToken_not_starts_with,omitempty"`
	NotificationTokenEndsWith      *string                  `json:"notificationToken_ends_with,omitempty"`
	NotificationTokenNotEndsWith   *string                  `json:"notificationToken_not_ends_with,omitempty"`
	Language                       *string                  `json:"language,omitempty"`
	LanguageNot                    *string                  `json:"language_not,omitempty"`
	LanguageIn                     []string                 `json:"language_in,omitempty"`
	LanguageNotIn                  []string                 `json:"language_not_in,omitempty"`
	LanguageLt                     *string                  `json:"language_lt,omitempty"`
	LanguageLte                    *string                  `json:"language_lte,omitempty"`
	LanguageGt                     *string                  `json:"language_gt,omitempty"`
	LanguageGte                    *string                  `json:"language_gte,omitempty"`
	LanguageContains               *string                  `json:"language_contains,omitempty"`
	LanguageNotContains            *string                  `json:"language_not_contains,omitempty"`
	LanguageStartsWith             *string                  `json:"language_starts_with,omitempty"`
	LanguageNotStartsWith          *string                  `json:"language_not_starts_with,omitempty"`
	LanguageEndsWith               *string                  `json:"language_ends_with,omitempty"`
	LanguageNotEndsWith            *string                  `json:"language_not_ends_with,omitempty"`
	PasswordToken                  *PasswordTokenWhereInput `json:"passwordToken,omitempty"`
	Deleted                        *bool                    `json:"deleted,omitempty"`
	DeletedNot                     *bool                    `json:"deleted_not,omitempty"`
	Activated                      *bool                    `json:"activated,omitempty"`
	ActivatedNot                   *bool                    `json:"activated_not,omitempty"`
	ActivateToken                  *string                  `json:"activateToken,omitempty"`
	ActivateTokenNot               *string                  `json:"activateToken_not,omitempty"`
	ActivateTokenIn                []string                 `json:"activateToken_in,omitempty"`
	ActivateTokenNotIn             []string                 `json:"activateToken_not_in,omitempty"`
	ActivateTokenLt                *string                  `json:"activateToken_lt,omitempty"`
	ActivateTokenLte               *string                  `json:"activateToken_lte,omitempty"`
	ActivateTokenGt                *string                  `json:"activateToken_gt,omitempty"`
	ActivateTokenGte               *string                  `json:"activateToken_gte,omitempty"`
	ActivateTokenContains          *string                  `json:"activateToken_contains,omitempty"`
	ActivateTokenNotContains       *string                  `json:"activateToken_not_contains,omitempty"`
	ActivateTokenStartsWith        *string                  `json:"activateToken_starts_with,omitempty"`
	ActivateTokenNotStartsWith     *string                  `json:"activateToken_not_starts_with,omitempty"`
	ActivateTokenEndsWith          *string                  `json:"activateToken_ends_with,omitempty"`
	ActivateTokenNotEndsWith       *string                  `json:"activateToken_not_ends_with,omitempty"`
	And                            []UserWhereInput         `json:"AND,omitempty"`
	Or                             []UserWhereInput         `json:"OR,omitempty"`
	Not                            []UserWhereInput         `json:"NOT,omitempty"`
}

type ReviewWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                `json:"createdAt,omitempty"`
	CreatedAtNot       *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                `json:"updatedAt_gte,omitempty"`
	Type               *ReviewType            `json:"type,omitempty"`
	TypeNot            *ReviewType            `json:"type_not,omitempty"`
	TypeIn             []ReviewType           `json:"type_in,omitempty"`
	TypeNotIn          []ReviewType           `json:"type_not_in,omitempty"`
	Stars              *float64               `json:"stars,omitempty"`
	StarsNot           *float64               `json:"stars_not,omitempty"`
	StarsIn            []float64              `json:"stars_in,omitempty"`
	StarsNotIn         []float64              `json:"stars_not_in,omitempty"`
	StarsLt            *float64               `json:"stars_lt,omitempty"`
	StarsLte           *float64               `json:"stars_lte,omitempty"`
	StarsGt            *float64               `json:"stars_gt,omitempty"`
	StarsGte           *float64               `json:"stars_gte,omitempty"`
	Title              *string                `json:"title,omitempty"`
	TitleNot           *string                `json:"title_not,omitempty"`
	TitleIn            []string               `json:"title_in,omitempty"`
	TitleNotIn         []string               `json:"title_not_in,omitempty"`
	TitleLt            *string                `json:"title_lt,omitempty"`
	TitleLte           *string                `json:"title_lte,omitempty"`
	TitleGt            *string                `json:"title_gt,omitempty"`
	TitleGte           *string                `json:"title_gte,omitempty"`
	TitleContains      *string                `json:"title_contains,omitempty"`
	TitleNotContains   *string                `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string                `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string                `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string                `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string                `json:"title_not_ends_with,omitempty"`
	Text               *string                `json:"text,omitempty"`
	TextNot            *string                `json:"text_not,omitempty"`
	TextIn             []string               `json:"text_in,omitempty"`
	TextNotIn          []string               `json:"text_not_in,omitempty"`
	TextLt             *string                `json:"text_lt,omitempty"`
	TextLte            *string                `json:"text_lte,omitempty"`
	TextGt             *string                `json:"text_gt,omitempty"`
	TextGte            *string                `json:"text_gte,omitempty"`
	TextContains       *string                `json:"text_contains,omitempty"`
	TextNotContains    *string                `json:"text_not_contains,omitempty"`
	TextStartsWith     *string                `json:"text_starts_with,omitempty"`
	TextNotStartsWith  *string                `json:"text_not_starts_with,omitempty"`
	TextEndsWith       *string                `json:"text_ends_with,omitempty"`
	TextNotEndsWith    *string                `json:"text_not_ends_with,omitempty"`
	Status             *ReviewStatus          `json:"status,omitempty"`
	StatusNot          *ReviewStatus          `json:"status_not,omitempty"`
	StatusIn           []ReviewStatus         `json:"status_in,omitempty"`
	StatusNotIn        []ReviewStatus         `json:"status_not_in,omitempty"`
	Customer           *UserWhereInput        `json:"customer,omitempty"`
	Product            *ProductWhereInput     `json:"product,omitempty"`
	Service            *ServiceWhereInput     `json:"service,omitempty"`
	Appointment        *AppointmentWhereInput `json:"appointment,omitempty"`
	Company            *CompanyWhereInput     `json:"company,omitempty"`
	And                []ReviewWhereInput     `json:"AND,omitempty"`
	Or                 []ReviewWhereInput     `json:"OR,omitempty"`
	Not                []ReviewWhereInput     `json:"NOT,omitempty"`
}

type ProductWhereInput struct {
	ID                    *string                            `json:"id,omitempty"`
	IDNot                 *string                            `json:"id_not,omitempty"`
	IDIn                  []string                           `json:"id_in,omitempty"`
	IDNotIn               []string                           `json:"id_not_in,omitempty"`
	IDLt                  *string                            `json:"id_lt,omitempty"`
	IDLte                 *string                            `json:"id_lte,omitempty"`
	IDGt                  *string                            `json:"id_gt,omitempty"`
	IDGte                 *string                            `json:"id_gte,omitempty"`
	IDContains            *string                            `json:"id_contains,omitempty"`
	IDNotContains         *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                            `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                            `json:"createdAt,omitempty"`
	CreatedAtNot          *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                            `json:"updatedAt_gte,omitempty"`
	Name                  *LocalizedStringWhereInput         `json:"name,omitempty"`
	Desc                  *LocalizedStringWhereInput         `json:"desc,omitempty"`
	Price                 *int32                             `json:"price,omitempty"`
	PriceNot              *int32                             `json:"price_not,omitempty"`
	PriceIn               []int32                            `json:"price_in,omitempty"`
	PriceNotIn            []int32                            `json:"price_not_in,omitempty"`
	PriceLt               *int32                             `json:"price_lt,omitempty"`
	PriceLte              *int32                             `json:"price_lte,omitempty"`
	PriceGt               *int32                             `json:"price_gt,omitempty"`
	PriceGte              *int32                             `json:"price_gte,omitempty"`
	Capacity              *string                            `json:"capacity,omitempty"`
	CapacityNot           *string                            `json:"capacity_not,omitempty"`
	CapacityIn            []string                           `json:"capacity_in,omitempty"`
	CapacityNotIn         []string                           `json:"capacity_not_in,omitempty"`
	CapacityLt            *string                            `json:"capacity_lt,omitempty"`
	CapacityLte           *string                            `json:"capacity_lte,omitempty"`
	CapacityGt            *string                            `json:"capacity_gt,omitempty"`
	CapacityGte           *string                            `json:"capacity_gte,omitempty"`
	CapacityContains      *string                            `json:"capacity_contains,omitempty"`
	CapacityNotContains   *string                            `json:"capacity_not_contains,omitempty"`
	CapacityStartsWith    *string                            `json:"capacity_starts_with,omitempty"`
	CapacityNotStartsWith *string                            `json:"capacity_not_starts_with,omitempty"`
	CapacityEndsWith      *string                            `json:"capacity_ends_with,omitempty"`
	CapacityNotEndsWith   *string                            `json:"capacity_not_ends_with,omitempty"`
	Category              *ProductCategoryWhereInput         `json:"category,omitempty"`
	SubCategory           *ProductSubCategoryWhereInput      `json:"subCategory,omitempty"`
	Image                 *string                            `json:"image,omitempty"`
	ImageNot              *string                            `json:"image_not,omitempty"`
	ImageIn               []string                           `json:"image_in,omitempty"`
	ImageNotIn            []string                           `json:"image_not_in,omitempty"`
	ImageLt               *string                            `json:"image_lt,omitempty"`
	ImageLte              *string                            `json:"image_lte,omitempty"`
	ImageGt               *string                            `json:"image_gt,omitempty"`
	ImageGte              *string                            `json:"image_gte,omitempty"`
	ImageContains         *string                            `json:"image_contains,omitempty"`
	ImageNotContains      *string                            `json:"image_not_contains,omitempty"`
	ImageStartsWith       *string                            `json:"image_starts_with,omitempty"`
	ImageNotStartsWith    *string                            `json:"image_not_starts_with,omitempty"`
	ImageEndsWith         *string                            `json:"image_ends_with,omitempty"`
	ImageNotEndsWith      *string                            `json:"image_not_ends_with,omitempty"`
	AttributesEvery       *ProductServiceAttributeWhereInput `json:"attributes_every,omitempty"`
	AttributesSome        *ProductServiceAttributeWhereInput `json:"attributes_some,omitempty"`
	AttributesNone        *ProductServiceAttributeWhereInput `json:"attributes_none,omitempty"`
	Branch                *BranchWhereInput                  `json:"branch,omitempty"`
	Company               *CompanyWhereInput                 `json:"company,omitempty"`
	ReviewsEvery          *ReviewWhereInput                  `json:"reviews_every,omitempty"`
	ReviewsSome           *ReviewWhereInput                  `json:"reviews_some,omitempty"`
	ReviewsNone           *ReviewWhereInput                  `json:"reviews_none,omitempty"`
	Deleted               *bool                              `json:"deleted,omitempty"`
	DeletedNot            *bool                              `json:"deleted_not,omitempty"`
	Active                *bool                              `json:"active,omitempty"`
	ActiveNot             *bool                              `json:"active_not,omitempty"`
	And                   []ProductWhereInput                `json:"AND,omitempty"`
	Or                    []ProductWhereInput                `json:"OR,omitempty"`
	Not                   []ProductWhereInput                `json:"NOT,omitempty"`
}

type ProductCategoryWhereInput struct {
	ID                 *string                       `json:"id,omitempty"`
	IDNot              *string                       `json:"id_not,omitempty"`
	IDIn               []string                      `json:"id_in,omitempty"`
	IDNotIn            []string                      `json:"id_not_in,omitempty"`
	IDLt               *string                       `json:"id_lt,omitempty"`
	IDLte              *string                       `json:"id_lte,omitempty"`
	IDGt               *string                       `json:"id_gt,omitempty"`
	IDGte              *string                       `json:"id_gte,omitempty"`
	IDContains         *string                       `json:"id_contains,omitempty"`
	IDNotContains      *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                       `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                       `json:"createdAt,omitempty"`
	CreatedAtNot       *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                       `json:"updatedAt_gte,omitempty"`
	Name               *string                       `json:"name,omitempty"`
	NameNot            *string                       `json:"name_not,omitempty"`
	NameIn             []string                      `json:"name_in,omitempty"`
	NameNotIn          []string                      `json:"name_not_in,omitempty"`
	NameLt             *string                       `json:"name_lt,omitempty"`
	NameLte            *string                       `json:"name_lte,omitempty"`
	NameGt             *string                       `json:"name_gt,omitempty"`
	NameGte            *string                       `json:"name_gte,omitempty"`
	NameContains       *string                       `json:"name_contains,omitempty"`
	NameNotContains    *string                       `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                       `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                       `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                       `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                       `json:"name_not_ends_with,omitempty"`
	SubCategoriesEvery *ProductSubCategoryWhereInput `json:"subCategories_every,omitempty"`
	SubCategoriesSome  *ProductSubCategoryWhereInput `json:"subCategories_some,omitempty"`
	SubCategoriesNone  *ProductSubCategoryWhereInput `json:"subCategories_none,omitempty"`
	Company            *CompanyWhereInput            `json:"company,omitempty"`
	And                []ProductCategoryWhereInput   `json:"AND,omitempty"`
	Or                 []ProductCategoryWhereInput   `json:"OR,omitempty"`
	Not                []ProductCategoryWhereInput   `json:"NOT,omitempty"`
}

type ProductSubCategoryWhereInput struct {
	ID                *string                        `json:"id,omitempty"`
	IDNot             *string                        `json:"id_not,omitempty"`
	IDIn              []string                       `json:"id_in,omitempty"`
	IDNotIn           []string                       `json:"id_not_in,omitempty"`
	IDLt              *string                        `json:"id_lt,omitempty"`
	IDLte             *string                        `json:"id_lte,omitempty"`
	IDGt              *string                        `json:"id_gt,omitempty"`
	IDGte             *string                        `json:"id_gte,omitempty"`
	IDContains        *string                        `json:"id_contains,omitempty"`
	IDNotContains     *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                        `json:"createdAt,omitempty"`
	CreatedAtNot      *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                        `json:"updatedAt_gte,omitempty"`
	Name              *string                        `json:"name,omitempty"`
	NameNot           *string                        `json:"name_not,omitempty"`
	NameIn            []string                       `json:"name_in,omitempty"`
	NameNotIn         []string                       `json:"name_not_in,omitempty"`
	NameLt            *string                        `json:"name_lt,omitempty"`
	NameLte           *string                        `json:"name_lte,omitempty"`
	NameGt            *string                        `json:"name_gt,omitempty"`
	NameGte           *string                        `json:"name_gte,omitempty"`
	NameContains      *string                        `json:"name_contains,omitempty"`
	NameNotContains   *string                        `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                        `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                        `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                        `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                        `json:"name_not_ends_with,omitempty"`
	Category          *ProductCategoryWhereInput     `json:"category,omitempty"`
	ProductsEvery     *ProductWhereInput             `json:"products_every,omitempty"`
	ProductsSome      *ProductWhereInput             `json:"products_some,omitempty"`
	ProductsNone      *ProductWhereInput             `json:"products_none,omitempty"`
	Company           *CompanyWhereInput             `json:"company,omitempty"`
	And               []ProductSubCategoryWhereInput `json:"AND,omitempty"`
	Or                []ProductSubCategoryWhereInput `json:"OR,omitempty"`
	Not               []ProductSubCategoryWhereInput `json:"NOT,omitempty"`
}

type ProductServiceAttributeWhereInput struct {
	ID               *string                             `json:"id,omitempty"`
	IDNot            *string                             `json:"id_not,omitempty"`
	IDIn             []string                            `json:"id_in,omitempty"`
	IDNotIn          []string                            `json:"id_not_in,omitempty"`
	IDLt             *string                             `json:"id_lt,omitempty"`
	IDLte            *string                             `json:"id_lte,omitempty"`
	IDGt             *string                             `json:"id_gt,omitempty"`
	IDGte            *string                             `json:"id_gte,omitempty"`
	IDContains       *string                             `json:"id_contains,omitempty"`
	IDNotContains    *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith     *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith  *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith       *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith    *string                             `json:"id_not_ends_with,omitempty"`
	Service          *ServiceWhereInput                  `json:"service,omitempty"`
	Product          *ProductWhereInput                  `json:"product,omitempty"`
	Key              *string                             `json:"key,omitempty"`
	KeyNot           *string                             `json:"key_not,omitempty"`
	KeyIn            []string                            `json:"key_in,omitempty"`
	KeyNotIn         []string                            `json:"key_not_in,omitempty"`
	KeyLt            *string                             `json:"key_lt,omitempty"`
	KeyLte           *string                             `json:"key_lte,omitempty"`
	KeyGt            *string                             `json:"key_gt,omitempty"`
	KeyGte           *string                             `json:"key_gte,omitempty"`
	KeyContains      *string                             `json:"key_contains,omitempty"`
	KeyNotContains   *string                             `json:"key_not_contains,omitempty"`
	KeyStartsWith    *string                             `json:"key_starts_with,omitempty"`
	KeyNotStartsWith *string                             `json:"key_not_starts_with,omitempty"`
	KeyEndsWith      *string                             `json:"key_ends_with,omitempty"`
	KeyNotEndsWith   *string                             `json:"key_not_ends_with,omitempty"`
	Name             *LocalizedStringWhereInput          `json:"name,omitempty"`
	Value            *LocalizedStringWhereInput          `json:"value,omitempty"`
	Company          *CompanyWhereInput                  `json:"company,omitempty"`
	And              []ProductServiceAttributeWhereInput `json:"AND,omitempty"`
	Or               []ProductServiceAttributeWhereInput `json:"OR,omitempty"`
	Not              []ProductServiceAttributeWhereInput `json:"NOT,omitempty"`
}

type ServiceWhereInput struct {
	ID                 *string                            `json:"id,omitempty"`
	IDNot              *string                            `json:"id_not,omitempty"`
	IDIn               []string                           `json:"id_in,omitempty"`
	IDNotIn            []string                           `json:"id_not_in,omitempty"`
	IDLt               *string                            `json:"id_lt,omitempty"`
	IDLte              *string                            `json:"id_lte,omitempty"`
	IDGt               *string                            `json:"id_gt,omitempty"`
	IDGte              *string                            `json:"id_gte,omitempty"`
	IDContains         *string                            `json:"id_contains,omitempty"`
	IDNotContains      *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                            `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                            `json:"createdAt,omitempty"`
	CreatedAtNot       *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                            `json:"updatedAt_gte,omitempty"`
	Name               *LocalizedStringWhereInput         `json:"name,omitempty"`
	Desc               *LocalizedStringWhereInput         `json:"desc,omitempty"`
	Price              *int32                             `json:"price,omitempty"`
	PriceNot           *int32                             `json:"price_not,omitempty"`
	PriceIn            []int32                            `json:"price_in,omitempty"`
	PriceNotIn         []int32                            `json:"price_not_in,omitempty"`
	PriceLt            *int32                             `json:"price_lt,omitempty"`
	PriceLte           *int32                             `json:"price_lte,omitempty"`
	PriceGt            *int32                             `json:"price_gt,omitempty"`
	PriceGte           *int32                             `json:"price_gte,omitempty"`
	Duration           *int32                             `json:"duration,omitempty"`
	DurationNot        *int32                             `json:"duration_not,omitempty"`
	DurationIn         []int32                            `json:"duration_in,omitempty"`
	DurationNotIn      []int32                            `json:"duration_not_in,omitempty"`
	DurationLt         *int32                             `json:"duration_lt,omitempty"`
	DurationLte        *int32                             `json:"duration_lte,omitempty"`
	DurationGt         *int32                             `json:"duration_gt,omitempty"`
	DurationGte        *int32                             `json:"duration_gte,omitempty"`
	Image              *string                            `json:"image,omitempty"`
	ImageNot           *string                            `json:"image_not,omitempty"`
	ImageIn            []string                           `json:"image_in,omitempty"`
	ImageNotIn         []string                           `json:"image_not_in,omitempty"`
	ImageLt            *string                            `json:"image_lt,omitempty"`
	ImageLte           *string                            `json:"image_lte,omitempty"`
	ImageGt            *string                            `json:"image_gt,omitempty"`
	ImageGte           *string                            `json:"image_gte,omitempty"`
	ImageContains      *string                            `json:"image_contains,omitempty"`
	ImageNotContains   *string                            `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                            `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                            `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                            `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                            `json:"image_not_ends_with,omitempty"`
	GenderTarget       *GenderTarget                      `json:"genderTarget,omitempty"`
	GenderTargetNot    *GenderTarget                      `json:"genderTarget_not,omitempty"`
	GenderTargetIn     []GenderTarget                     `json:"genderTarget_in,omitempty"`
	GenderTargetNotIn  []GenderTarget                     `json:"genderTarget_not_in,omitempty"`
	AttributesEvery    *ProductServiceAttributeWhereInput `json:"attributes_every,omitempty"`
	AttributesSome     *ProductServiceAttributeWhereInput `json:"attributes_some,omitempty"`
	AttributesNone     *ProductServiceAttributeWhereInput `json:"attributes_none,omitempty"`
	Category           *ServiceCategoryWhereInput         `json:"category,omitempty"`
	SubCategory        *ServiceSubCategoryWhereInput      `json:"subCategory,omitempty"`
	Branch             *BranchWhereInput                  `json:"branch,omitempty"`
	Company            *CompanyWhereInput                 `json:"company,omitempty"`
	ReviewsEvery       *ReviewWhereInput                  `json:"reviews_every,omitempty"`
	ReviewsSome        *ReviewWhereInput                  `json:"reviews_some,omitempty"`
	ReviewsNone        *ReviewWhereInput                  `json:"reviews_none,omitempty"`
	Deleted            *bool                              `json:"deleted,omitempty"`
	DeletedNot         *bool                              `json:"deleted_not,omitempty"`
	Active             *bool                              `json:"active,omitempty"`
	ActiveNot          *bool                              `json:"active_not,omitempty"`
	And                []ServiceWhereInput                `json:"AND,omitempty"`
	Or                 []ServiceWhereInput                `json:"OR,omitempty"`
	Not                []ServiceWhereInput                `json:"NOT,omitempty"`
}

type ServiceCategoryWhereInput struct {
	ID                 *string                       `json:"id,omitempty"`
	IDNot              *string                       `json:"id_not,omitempty"`
	IDIn               []string                      `json:"id_in,omitempty"`
	IDNotIn            []string                      `json:"id_not_in,omitempty"`
	IDLt               *string                       `json:"id_lt,omitempty"`
	IDLte              *string                       `json:"id_lte,omitempty"`
	IDGt               *string                       `json:"id_gt,omitempty"`
	IDGte              *string                       `json:"id_gte,omitempty"`
	IDContains         *string                       `json:"id_contains,omitempty"`
	IDNotContains      *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                       `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                       `json:"createdAt,omitempty"`
	CreatedAtNot       *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                       `json:"updatedAt_gte,omitempty"`
	Name               *string                       `json:"name,omitempty"`
	NameNot            *string                       `json:"name_not,omitempty"`
	NameIn             []string                      `json:"name_in,omitempty"`
	NameNotIn          []string                      `json:"name_not_in,omitempty"`
	NameLt             *string                       `json:"name_lt,omitempty"`
	NameLte            *string                       `json:"name_lte,omitempty"`
	NameGt             *string                       `json:"name_gt,omitempty"`
	NameGte            *string                       `json:"name_gte,omitempty"`
	NameContains       *string                       `json:"name_contains,omitempty"`
	NameNotContains    *string                       `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                       `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                       `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                       `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                       `json:"name_not_ends_with,omitempty"`
	SubCategoriesEvery *ServiceSubCategoryWhereInput `json:"subCategories_every,omitempty"`
	SubCategoriesSome  *ServiceSubCategoryWhereInput `json:"subCategories_some,omitempty"`
	SubCategoriesNone  *ServiceSubCategoryWhereInput `json:"subCategories_none,omitempty"`
	Company            *CompanyWhereInput            `json:"company,omitempty"`
	And                []ServiceCategoryWhereInput   `json:"AND,omitempty"`
	Or                 []ServiceCategoryWhereInput   `json:"OR,omitempty"`
	Not                []ServiceCategoryWhereInput   `json:"NOT,omitempty"`
}

type ServiceSubCategoryWhereInput struct {
	ID                *string                        `json:"id,omitempty"`
	IDNot             *string                        `json:"id_not,omitempty"`
	IDIn              []string                       `json:"id_in,omitempty"`
	IDNotIn           []string                       `json:"id_not_in,omitempty"`
	IDLt              *string                        `json:"id_lt,omitempty"`
	IDLte             *string                        `json:"id_lte,omitempty"`
	IDGt              *string                        `json:"id_gt,omitempty"`
	IDGte             *string                        `json:"id_gte,omitempty"`
	IDContains        *string                        `json:"id_contains,omitempty"`
	IDNotContains     *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                        `json:"createdAt,omitempty"`
	CreatedAtNot      *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                        `json:"updatedAt_gte,omitempty"`
	Name              *string                        `json:"name,omitempty"`
	NameNot           *string                        `json:"name_not,omitempty"`
	NameIn            []string                       `json:"name_in,omitempty"`
	NameNotIn         []string                       `json:"name_not_in,omitempty"`
	NameLt            *string                        `json:"name_lt,omitempty"`
	NameLte           *string                        `json:"name_lte,omitempty"`
	NameGt            *string                        `json:"name_gt,omitempty"`
	NameGte           *string                        `json:"name_gte,omitempty"`
	NameContains      *string                        `json:"name_contains,omitempty"`
	NameNotContains   *string                        `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                        `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                        `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                        `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                        `json:"name_not_ends_with,omitempty"`
	Category          *ServiceCategoryWhereInput     `json:"category,omitempty"`
	Company           *CompanyWhereInput             `json:"company,omitempty"`
	ServicesEvery     *ServiceWhereInput             `json:"services_every,omitempty"`
	ServicesSome      *ServiceWhereInput             `json:"services_some,omitempty"`
	ServicesNone      *ServiceWhereInput             `json:"services_none,omitempty"`
	And               []ServiceSubCategoryWhereInput `json:"AND,omitempty"`
	Or                []ServiceSubCategoryWhereInput `json:"OR,omitempty"`
	Not               []ServiceSubCategoryWhereInput `json:"NOT,omitempty"`
}

type BranchWhereInput struct {
	ID                              *string                      `json:"id,omitempty"`
	IDNot                           *string                      `json:"id_not,omitempty"`
	IDIn                            []string                     `json:"id_in,omitempty"`
	IDNotIn                         []string                     `json:"id_not_in,omitempty"`
	IDLt                            *string                      `json:"id_lt,omitempty"`
	IDLte                           *string                      `json:"id_lte,omitempty"`
	IDGt                            *string                      `json:"id_gt,omitempty"`
	IDGte                           *string                      `json:"id_gte,omitempty"`
	IDContains                      *string                      `json:"id_contains,omitempty"`
	IDNotContains                   *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                    *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith                 *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                      *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith                   *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                       *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                    *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                       *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                    *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                     []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                  []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                     *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                    *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                     *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                    *string                      `json:"updatedAt_gte,omitempty"`
	Name                            *LocalizedStringWhereInput   `json:"name,omitempty"`
	PhoneNumber                     *string                      `json:"phoneNumber,omitempty"`
	PhoneNumberNot                  *string                      `json:"phoneNumber_not,omitempty"`
	PhoneNumberIn                   []string                     `json:"phoneNumber_in,omitempty"`
	PhoneNumberNotIn                []string                     `json:"phoneNumber_not_in,omitempty"`
	PhoneNumberLt                   *string                      `json:"phoneNumber_lt,omitempty"`
	PhoneNumberLte                  *string                      `json:"phoneNumber_lte,omitempty"`
	PhoneNumberGt                   *string                      `json:"phoneNumber_gt,omitempty"`
	PhoneNumberGte                  *string                      `json:"phoneNumber_gte,omitempty"`
	PhoneNumberContains             *string                      `json:"phoneNumber_contains,omitempty"`
	PhoneNumberNotContains          *string                      `json:"phoneNumber_not_contains,omitempty"`
	PhoneNumberStartsWith           *string                      `json:"phoneNumber_starts_with,omitempty"`
	PhoneNumberNotStartsWith        *string                      `json:"phoneNumber_not_starts_with,omitempty"`
	PhoneNumberEndsWith             *string                      `json:"phoneNumber_ends_with,omitempty"`
	PhoneNumberNotEndsWith          *string                      `json:"phoneNumber_not_ends_with,omitempty"`
	WelcomeMessage                  *LocalizedStringWhereInput   `json:"welcomeMessage,omitempty"`
	Address                         *string                      `json:"address,omitempty"`
	AddressNot                      *string                      `json:"address_not,omitempty"`
	AddressIn                       []string                     `json:"address_in,omitempty"`
	AddressNotIn                    []string                     `json:"address_not_in,omitempty"`
	AddressLt                       *string                      `json:"address_lt,omitempty"`
	AddressLte                      *string                      `json:"address_lte,omitempty"`
	AddressGt                       *string                      `json:"address_gt,omitempty"`
	AddressGte                      *string                      `json:"address_gte,omitempty"`
	AddressContains                 *string                      `json:"address_contains,omitempty"`
	AddressNotContains              *string                      `json:"address_not_contains,omitempty"`
	AddressStartsWith               *string                      `json:"address_starts_with,omitempty"`
	AddressNotStartsWith            *string                      `json:"address_not_starts_with,omitempty"`
	AddressEndsWith                 *string                      `json:"address_ends_with,omitempty"`
	AddressNotEndsWith              *string                      `json:"address_not_ends_with,omitempty"`
	WebsiteUrl                      *string                      `json:"websiteUrl,omitempty"`
	WebsiteUrlNot                   *string                      `json:"websiteUrl_not,omitempty"`
	WebsiteUrlIn                    []string                     `json:"websiteUrl_in,omitempty"`
	WebsiteUrlNotIn                 []string                     `json:"websiteUrl_not_in,omitempty"`
	WebsiteUrlLt                    *string                      `json:"websiteUrl_lt,omitempty"`
	WebsiteUrlLte                   *string                      `json:"websiteUrl_lte,omitempty"`
	WebsiteUrlGt                    *string                      `json:"websiteUrl_gt,omitempty"`
	WebsiteUrlGte                   *string                      `json:"websiteUrl_gte,omitempty"`
	WebsiteUrlContains              *string                      `json:"websiteUrl_contains,omitempty"`
	WebsiteUrlNotContains           *string                      `json:"websiteUrl_not_contains,omitempty"`
	WebsiteUrlStartsWith            *string                      `json:"websiteUrl_starts_with,omitempty"`
	WebsiteUrlNotStartsWith         *string                      `json:"websiteUrl_not_starts_with,omitempty"`
	WebsiteUrlEndsWith              *string                      `json:"websiteUrl_ends_with,omitempty"`
	WebsiteUrlNotEndsWith           *string                      `json:"websiteUrl_not_ends_with,omitempty"`
	NavigationLink                  *string                      `json:"navigationLink,omitempty"`
	NavigationLinkNot               *string                      `json:"navigationLink_not,omitempty"`
	NavigationLinkIn                []string                     `json:"navigationLink_in,omitempty"`
	NavigationLinkNotIn             []string                     `json:"navigationLink_not_in,omitempty"`
	NavigationLinkLt                *string                      `json:"navigationLink_lt,omitempty"`
	NavigationLinkLte               *string                      `json:"navigationLink_lte,omitempty"`
	NavigationLinkGt                *string                      `json:"navigationLink_gt,omitempty"`
	NavigationLinkGte               *string                      `json:"navigationLink_gte,omitempty"`
	NavigationLinkContains          *string                      `json:"navigationLink_contains,omitempty"`
	NavigationLinkNotContains       *string                      `json:"navigationLink_not_contains,omitempty"`
	NavigationLinkStartsWith        *string                      `json:"navigationLink_starts_with,omitempty"`
	NavigationLinkNotStartsWith     *string                      `json:"navigationLink_not_starts_with,omitempty"`
	NavigationLinkEndsWith          *string                      `json:"navigationLink_ends_with,omitempty"`
	NavigationLinkNotEndsWith       *string                      `json:"navigationLink_not_ends_with,omitempty"`
	SharingRedirectUrl              *string                      `json:"sharingRedirectUrl,omitempty"`
	SharingRedirectUrlNot           *string                      `json:"sharingRedirectUrl_not,omitempty"`
	SharingRedirectUrlIn            []string                     `json:"sharingRedirectUrl_in,omitempty"`
	SharingRedirectUrlNotIn         []string                     `json:"sharingRedirectUrl_not_in,omitempty"`
	SharingRedirectUrlLt            *string                      `json:"sharingRedirectUrl_lt,omitempty"`
	SharingRedirectUrlLte           *string                      `json:"sharingRedirectUrl_lte,omitempty"`
	SharingRedirectUrlGt            *string                      `json:"sharingRedirectUrl_gt,omitempty"`
	SharingRedirectUrlGte           *string                      `json:"sharingRedirectUrl_gte,omitempty"`
	SharingRedirectUrlContains      *string                      `json:"sharingRedirectUrl_contains,omitempty"`
	SharingRedirectUrlNotContains   *string                      `json:"sharingRedirectUrl_not_contains,omitempty"`
	SharingRedirectUrlStartsWith    *string                      `json:"sharingRedirectUrl_starts_with,omitempty"`
	SharingRedirectUrlNotStartsWith *string                      `json:"sharingRedirectUrl_not_starts_with,omitempty"`
	SharingRedirectUrlEndsWith      *string                      `json:"sharingRedirectUrl_ends_with,omitempty"`
	SharingRedirectUrlNotEndsWith   *string                      `json:"sharingRedirectUrl_not_ends_with,omitempty"`
	Imprint                         *string                      `json:"imprint,omitempty"`
	ImprintNot                      *string                      `json:"imprint_not,omitempty"`
	ImprintIn                       []string                     `json:"imprint_in,omitempty"`
	ImprintNotIn                    []string                     `json:"imprint_not_in,omitempty"`
	ImprintLt                       *string                      `json:"imprint_lt,omitempty"`
	ImprintLte                      *string                      `json:"imprint_lte,omitempty"`
	ImprintGt                       *string                      `json:"imprint_gt,omitempty"`
	ImprintGte                      *string                      `json:"imprint_gte,omitempty"`
	ImprintContains                 *string                      `json:"imprint_contains,omitempty"`
	ImprintNotContains              *string                      `json:"imprint_not_contains,omitempty"`
	ImprintStartsWith               *string                      `json:"imprint_starts_with,omitempty"`
	ImprintNotStartsWith            *string                      `json:"imprint_not_starts_with,omitempty"`
	ImprintEndsWith                 *string                      `json:"imprint_ends_with,omitempty"`
	ImprintNotEndsWith              *string                      `json:"imprint_not_ends_with,omitempty"`
	Company                         *CompanyWhereInput           `json:"company,omitempty"`
	EmployeesEvery                  *UserWhereInput              `json:"employees_every,omitempty"`
	EmployeesSome                   *UserWhereInput              `json:"employees_some,omitempty"`
	EmployeesNone                   *UserWhereInput              `json:"employees_none,omitempty"`
	OpeningHoursEvery               *BranchOpeningHourWhereInput `json:"openingHours_every,omitempty"`
	OpeningHoursSome                *BranchOpeningHourWhereInput `json:"openingHours_some,omitempty"`
	OpeningHoursNone                *BranchOpeningHourWhereInput `json:"openingHours_none,omitempty"`
	NewsEvery                       *NewsWhereInput              `json:"news_every,omitempty"`
	NewsSome                        *NewsWhereInput              `json:"news_some,omitempty"`
	NewsNone                        *NewsWhereInput              `json:"news_none,omitempty"`
	SlotsEvery                      *BranchImageSlotWhereInput   `json:"slots_every,omitempty"`
	SlotsSome                       *BranchImageSlotWhereInput   `json:"slots_some,omitempty"`
	SlotsNone                       *BranchImageSlotWhereInput   `json:"slots_none,omitempty"`
	Logo                            *string                      `json:"logo,omitempty"`
	LogoNot                         *string                      `json:"logo_not,omitempty"`
	LogoIn                          []string                     `json:"logo_in,omitempty"`
	LogoNotIn                       []string                     `json:"logo_not_in,omitempty"`
	LogoLt                          *string                      `json:"logo_lt,omitempty"`
	LogoLte                         *string                      `json:"logo_lte,omitempty"`
	LogoGt                          *string                      `json:"logo_gt,omitempty"`
	LogoGte                         *string                      `json:"logo_gte,omitempty"`
	LogoContains                    *string                      `json:"logo_contains,omitempty"`
	LogoNotContains                 *string                      `json:"logo_not_contains,omitempty"`
	LogoStartsWith                  *string                      `json:"logo_starts_with,omitempty"`
	LogoNotStartsWith               *string                      `json:"logo_not_starts_with,omitempty"`
	LogoEndsWith                    *string                      `json:"logo_ends_with,omitempty"`
	LogoNotEndsWith                 *string                      `json:"logo_not_ends_with,omitempty"`
	AppTheme                        *string                      `json:"appTheme,omitempty"`
	AppThemeNot                     *string                      `json:"appTheme_not,omitempty"`
	AppThemeIn                      []string                     `json:"appTheme_in,omitempty"`
	AppThemeNotIn                   []string                     `json:"appTheme_not_in,omitempty"`
	AppThemeLt                      *string                      `json:"appTheme_lt,omitempty"`
	AppThemeLte                     *string                      `json:"appTheme_lte,omitempty"`
	AppThemeGt                      *string                      `json:"appTheme_gt,omitempty"`
	AppThemeGte                     *string                      `json:"appTheme_gte,omitempty"`
	AppThemeContains                *string                      `json:"appTheme_contains,omitempty"`
	AppThemeNotContains             *string                      `json:"appTheme_not_contains,omitempty"`
	AppThemeStartsWith              *string                      `json:"appTheme_starts_with,omitempty"`
	AppThemeNotStartsWith           *string                      `json:"appTheme_not_starts_with,omitempty"`
	AppThemeEndsWith                *string                      `json:"appTheme_ends_with,omitempty"`
	AppThemeNotEndsWith             *string                      `json:"appTheme_not_ends_with,omitempty"`
	FacebookLink                    *string                      `json:"facebookLink,omitempty"`
	FacebookLinkNot                 *string                      `json:"facebookLink_not,omitempty"`
	FacebookLinkIn                  []string                     `json:"facebookLink_in,omitempty"`
	FacebookLinkNotIn               []string                     `json:"facebookLink_not_in,omitempty"`
	FacebookLinkLt                  *string                      `json:"facebookLink_lt,omitempty"`
	FacebookLinkLte                 *string                      `json:"facebookLink_lte,omitempty"`
	FacebookLinkGt                  *string                      `json:"facebookLink_gt,omitempty"`
	FacebookLinkGte                 *string                      `json:"facebookLink_gte,omitempty"`
	FacebookLinkContains            *string                      `json:"facebookLink_contains,omitempty"`
	FacebookLinkNotContains         *string                      `json:"facebookLink_not_contains,omitempty"`
	FacebookLinkStartsWith          *string                      `json:"facebookLink_starts_with,omitempty"`
	FacebookLinkNotStartsWith       *string                      `json:"facebookLink_not_starts_with,omitempty"`
	FacebookLinkEndsWith            *string                      `json:"facebookLink_ends_with,omitempty"`
	FacebookLinkNotEndsWith         *string                      `json:"facebookLink_not_ends_with,omitempty"`
	TiktokLink                      *string                      `json:"tiktokLink,omitempty"`
	TiktokLinkNot                   *string                      `json:"tiktokLink_not,omitempty"`
	TiktokLinkIn                    []string                     `json:"tiktokLink_in,omitempty"`
	TiktokLinkNotIn                 []string                     `json:"tiktokLink_not_in,omitempty"`
	TiktokLinkLt                    *string                      `json:"tiktokLink_lt,omitempty"`
	TiktokLinkLte                   *string                      `json:"tiktokLink_lte,omitempty"`
	TiktokLinkGt                    *string                      `json:"tiktokLink_gt,omitempty"`
	TiktokLinkGte                   *string                      `json:"tiktokLink_gte,omitempty"`
	TiktokLinkContains              *string                      `json:"tiktokLink_contains,omitempty"`
	TiktokLinkNotContains           *string                      `json:"tiktokLink_not_contains,omitempty"`
	TiktokLinkStartsWith            *string                      `json:"tiktokLink_starts_with,omitempty"`
	TiktokLinkNotStartsWith         *string                      `json:"tiktokLink_not_starts_with,omitempty"`
	TiktokLinkEndsWith              *string                      `json:"tiktokLink_ends_with,omitempty"`
	TiktokLinkNotEndsWith           *string                      `json:"tiktokLink_not_ends_with,omitempty"`
	InstagramLink                   *string                      `json:"instagramLink,omitempty"`
	InstagramLinkNot                *string                      `json:"instagramLink_not,omitempty"`
	InstagramLinkIn                 []string                     `json:"instagramLink_in,omitempty"`
	InstagramLinkNotIn              []string                     `json:"instagramLink_not_in,omitempty"`
	InstagramLinkLt                 *string                      `json:"instagramLink_lt,omitempty"`
	InstagramLinkLte                *string                      `json:"instagramLink_lte,omitempty"`
	InstagramLinkGt                 *string                      `json:"instagramLink_gt,omitempty"`
	InstagramLinkGte                *string                      `json:"instagramLink_gte,omitempty"`
	InstagramLinkContains           *string                      `json:"instagramLink_contains,omitempty"`
	InstagramLinkNotContains        *string                      `json:"instagramLink_not_contains,omitempty"`
	InstagramLinkStartsWith         *string                      `json:"instagramLink_starts_with,omitempty"`
	InstagramLinkNotStartsWith      *string                      `json:"instagramLink_not_starts_with,omitempty"`
	InstagramLinkEndsWith           *string                      `json:"instagramLink_ends_with,omitempty"`
	InstagramLinkNotEndsWith        *string                      `json:"instagramLink_not_ends_with,omitempty"`
	SmtpSendHost                    *string                      `json:"smtpSendHost,omitempty"`
	SmtpSendHostNot                 *string                      `json:"smtpSendHost_not,omitempty"`
	SmtpSendHostIn                  []string                     `json:"smtpSendHost_in,omitempty"`
	SmtpSendHostNotIn               []string                     `json:"smtpSendHost_not_in,omitempty"`
	SmtpSendHostLt                  *string                      `json:"smtpSendHost_lt,omitempty"`
	SmtpSendHostLte                 *string                      `json:"smtpSendHost_lte,omitempty"`
	SmtpSendHostGt                  *string                      `json:"smtpSendHost_gt,omitempty"`
	SmtpSendHostGte                 *string                      `json:"smtpSendHost_gte,omitempty"`
	SmtpSendHostContains            *string                      `json:"smtpSendHost_contains,omitempty"`
	SmtpSendHostNotContains         *string                      `json:"smtpSendHost_not_contains,omitempty"`
	SmtpSendHostStartsWith          *string                      `json:"smtpSendHost_starts_with,omitempty"`
	SmtpSendHostNotStartsWith       *string                      `json:"smtpSendHost_not_starts_with,omitempty"`
	SmtpSendHostEndsWith            *string                      `json:"smtpSendHost_ends_with,omitempty"`
	SmtpSendHostNotEndsWith         *string                      `json:"smtpSendHost_not_ends_with,omitempty"`
	SmtpSendPort                    *string                      `json:"smtpSendPort,omitempty"`
	SmtpSendPortNot                 *string                      `json:"smtpSendPort_not,omitempty"`
	SmtpSendPortIn                  []string                     `json:"smtpSendPort_in,omitempty"`
	SmtpSendPortNotIn               []string                     `json:"smtpSendPort_not_in,omitempty"`
	SmtpSendPortLt                  *string                      `json:"smtpSendPort_lt,omitempty"`
	SmtpSendPortLte                 *string                      `json:"smtpSendPort_lte,omitempty"`
	SmtpSendPortGt                  *string                      `json:"smtpSendPort_gt,omitempty"`
	SmtpSendPortGte                 *string                      `json:"smtpSendPort_gte,omitempty"`
	SmtpSendPortContains            *string                      `json:"smtpSendPort_contains,omitempty"`
	SmtpSendPortNotContains         *string                      `json:"smtpSendPort_not_contains,omitempty"`
	SmtpSendPortStartsWith          *string                      `json:"smtpSendPort_starts_with,omitempty"`
	SmtpSendPortNotStartsWith       *string                      `json:"smtpSendPort_not_starts_with,omitempty"`
	SmtpSendPortEndsWith            *string                      `json:"smtpSendPort_ends_with,omitempty"`
	SmtpSendPortNotEndsWith         *string                      `json:"smtpSendPort_not_ends_with,omitempty"`
	SmtpUsername                    *string                      `json:"smtpUsername,omitempty"`
	SmtpUsernameNot                 *string                      `json:"smtpUsername_not,omitempty"`
	SmtpUsernameIn                  []string                     `json:"smtpUsername_in,omitempty"`
	SmtpUsernameNotIn               []string                     `json:"smtpUsername_not_in,omitempty"`
	SmtpUsernameLt                  *string                      `json:"smtpUsername_lt,omitempty"`
	SmtpUsernameLte                 *string                      `json:"smtpUsername_lte,omitempty"`
	SmtpUsernameGt                  *string                      `json:"smtpUsername_gt,omitempty"`
	SmtpUsernameGte                 *string                      `json:"smtpUsername_gte,omitempty"`
	SmtpUsernameContains            *string                      `json:"smtpUsername_contains,omitempty"`
	SmtpUsernameNotContains         *string                      `json:"smtpUsername_not_contains,omitempty"`
	SmtpUsernameStartsWith          *string                      `json:"smtpUsername_starts_with,omitempty"`
	SmtpUsernameNotStartsWith       *string                      `json:"smtpUsername_not_starts_with,omitempty"`
	SmtpUsernameEndsWith            *string                      `json:"smtpUsername_ends_with,omitempty"`
	SmtpUsernameNotEndsWith         *string                      `json:"smtpUsername_not_ends_with,omitempty"`
	SmtpPassword                    *string                      `json:"smtpPassword,omitempty"`
	SmtpPasswordNot                 *string                      `json:"smtpPassword_not,omitempty"`
	SmtpPasswordIn                  []string                     `json:"smtpPassword_in,omitempty"`
	SmtpPasswordNotIn               []string                     `json:"smtpPassword_not_in,omitempty"`
	SmtpPasswordLt                  *string                      `json:"smtpPassword_lt,omitempty"`
	SmtpPasswordLte                 *string                      `json:"smtpPassword_lte,omitempty"`
	SmtpPasswordGt                  *string                      `json:"smtpPassword_gt,omitempty"`
	SmtpPasswordGte                 *string                      `json:"smtpPassword_gte,omitempty"`
	SmtpPasswordContains            *string                      `json:"smtpPassword_contains,omitempty"`
	SmtpPasswordNotContains         *string                      `json:"smtpPassword_not_contains,omitempty"`
	SmtpPasswordStartsWith          *string                      `json:"smtpPassword_starts_with,omitempty"`
	SmtpPasswordNotStartsWith       *string                      `json:"smtpPassword_not_starts_with,omitempty"`
	SmtpPasswordEndsWith            *string                      `json:"smtpPassword_ends_with,omitempty"`
	SmtpPasswordNotEndsWith         *string                      `json:"smtpPassword_not_ends_with,omitempty"`
	FromEmail                       *string                      `json:"fromEmail,omitempty"`
	FromEmailNot                    *string                      `json:"fromEmail_not,omitempty"`
	FromEmailIn                     []string                     `json:"fromEmail_in,omitempty"`
	FromEmailNotIn                  []string                     `json:"fromEmail_not_in,omitempty"`
	FromEmailLt                     *string                      `json:"fromEmail_lt,omitempty"`
	FromEmailLte                    *string                      `json:"fromEmail_lte,omitempty"`
	FromEmailGt                     *string                      `json:"fromEmail_gt,omitempty"`
	FromEmailGte                    *string                      `json:"fromEmail_gte,omitempty"`
	FromEmailContains               *string                      `json:"fromEmail_contains,omitempty"`
	FromEmailNotContains            *string                      `json:"fromEmail_not_contains,omitempty"`
	FromEmailStartsWith             *string                      `json:"fromEmail_starts_with,omitempty"`
	FromEmailNotStartsWith          *string                      `json:"fromEmail_not_starts_with,omitempty"`
	FromEmailEndsWith               *string                      `json:"fromEmail_ends_with,omitempty"`
	FromEmailNotEndsWith            *string                      `json:"fromEmail_not_ends_with,omitempty"`
	MailchimpApiKey                 *string                      `json:"mailchimpApiKey,omitempty"`
	MailchimpApiKeyNot              *string                      `json:"mailchimpApiKey_not,omitempty"`
	MailchimpApiKeyIn               []string                     `json:"mailchimpApiKey_in,omitempty"`
	MailchimpApiKeyNotIn            []string                     `json:"mailchimpApiKey_not_in,omitempty"`
	MailchimpApiKeyLt               *string                      `json:"mailchimpApiKey_lt,omitempty"`
	MailchimpApiKeyLte              *string                      `json:"mailchimpApiKey_lte,omitempty"`
	MailchimpApiKeyGt               *string                      `json:"mailchimpApiKey_gt,omitempty"`
	MailchimpApiKeyGte              *string                      `json:"mailchimpApiKey_gte,omitempty"`
	MailchimpApiKeyContains         *string                      `json:"mailchimpApiKey_contains,omitempty"`
	MailchimpApiKeyNotContains      *string                      `json:"mailchimpApiKey_not_contains,omitempty"`
	MailchimpApiKeyStartsWith       *string                      `json:"mailchimpApiKey_starts_with,omitempty"`
	MailchimpApiKeyNotStartsWith    *string                      `json:"mailchimpApiKey_not_starts_with,omitempty"`
	MailchimpApiKeyEndsWith         *string                      `json:"mailchimpApiKey_ends_with,omitempty"`
	MailchimpApiKeyNotEndsWith      *string                      `json:"mailchimpApiKey_not_ends_with,omitempty"`
	MailchimpListId                 *string                      `json:"mailchimpListId,omitempty"`
	MailchimpListIdNot              *string                      `json:"mailchimpListId_not,omitempty"`
	MailchimpListIdIn               []string                     `json:"mailchimpListId_in,omitempty"`
	MailchimpListIdNotIn            []string                     `json:"mailchimpListId_not_in,omitempty"`
	MailchimpListIdLt               *string                      `json:"mailchimpListId_lt,omitempty"`
	MailchimpListIdLte              *string                      `json:"mailchimpListId_lte,omitempty"`
	MailchimpListIdGt               *string                      `json:"mailchimpListId_gt,omitempty"`
	MailchimpListIdGte              *string                      `json:"mailchimpListId_gte,omitempty"`
	MailchimpListIdContains         *string                      `json:"mailchimpListId_contains,omitempty"`
	MailchimpListIdNotContains      *string                      `json:"mailchimpListId_not_contains,omitempty"`
	MailchimpListIdStartsWith       *string                      `json:"mailchimpListId_starts_with,omitempty"`
	MailchimpListIdNotStartsWith    *string                      `json:"mailchimpListId_not_starts_with,omitempty"`
	MailchimpListIdEndsWith         *string                      `json:"mailchimpListId_ends_with,omitempty"`
	MailchimpListIdNotEndsWith      *string                      `json:"mailchimpListId_not_ends_with,omitempty"`
	And                             []BranchWhereInput           `json:"AND,omitempty"`
	Or                              []BranchWhereInput           `json:"OR,omitempty"`
	Not                             []BranchWhereInput           `json:"NOT,omitempty"`
}

type BranchOpeningHourWhereInput struct {
	ID                  *string                       `json:"id,omitempty"`
	IDNot               *string                       `json:"id_not,omitempty"`
	IDIn                []string                      `json:"id_in,omitempty"`
	IDNotIn             []string                      `json:"id_not_in,omitempty"`
	IDLt                *string                       `json:"id_lt,omitempty"`
	IDLte               *string                       `json:"id_lte,omitempty"`
	IDGt                *string                       `json:"id_gt,omitempty"`
	IDGte               *string                       `json:"id_gte,omitempty"`
	IDContains          *string                       `json:"id_contains,omitempty"`
	IDNotContains       *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                       `json:"id_not_ends_with,omitempty"`
	CreatedAt           *string                       `json:"createdAt,omitempty"`
	CreatedAtNot        *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                       `json:"updatedAt_gte,omitempty"`
	Branch              *BranchWhereInput             `json:"branch,omitempty"`
	Company             *CompanyWhereInput            `json:"company,omitempty"`
	Day                 *DayOfWeek                    `json:"day,omitempty"`
	DayNot              *DayOfWeek                    `json:"day_not,omitempty"`
	DayIn               []DayOfWeek                   `json:"day_in,omitempty"`
	DayNotIn            []DayOfWeek                   `json:"day_not_in,omitempty"`
	Closed              *bool                         `json:"closed,omitempty"`
	ClosedNot           *bool                         `json:"closed_not,omitempty"`
	Break               *bool                         `json:"break,omitempty"`
	BreakNot            *bool                         `json:"break_not,omitempty"`
	StartForenoon       *string                       `json:"startForenoon,omitempty"`
	StartForenoonNot    *string                       `json:"startForenoon_not,omitempty"`
	StartForenoonIn     []string                      `json:"startForenoon_in,omitempty"`
	StartForenoonNotIn  []string                      `json:"startForenoon_not_in,omitempty"`
	StartForenoonLt     *string                       `json:"startForenoon_lt,omitempty"`
	StartForenoonLte    *string                       `json:"startForenoon_lte,omitempty"`
	StartForenoonGt     *string                       `json:"startForenoon_gt,omitempty"`
	StartForenoonGte    *string                       `json:"startForenoon_gte,omitempty"`
	EndForenoon         *string                       `json:"endForenoon,omitempty"`
	EndForenoonNot      *string                       `json:"endForenoon_not,omitempty"`
	EndForenoonIn       []string                      `json:"endForenoon_in,omitempty"`
	EndForenoonNotIn    []string                      `json:"endForenoon_not_in,omitempty"`
	EndForenoonLt       *string                       `json:"endForenoon_lt,omitempty"`
	EndForenoonLte      *string                       `json:"endForenoon_lte,omitempty"`
	EndForenoonGt       *string                       `json:"endForenoon_gt,omitempty"`
	EndForenoonGte      *string                       `json:"endForenoon_gte,omitempty"`
	StartAfternoon      *string                       `json:"startAfternoon,omitempty"`
	StartAfternoonNot   *string                       `json:"startAfternoon_not,omitempty"`
	StartAfternoonIn    []string                      `json:"startAfternoon_in,omitempty"`
	StartAfternoonNotIn []string                      `json:"startAfternoon_not_in,omitempty"`
	StartAfternoonLt    *string                       `json:"startAfternoon_lt,omitempty"`
	StartAfternoonLte   *string                       `json:"startAfternoon_lte,omitempty"`
	StartAfternoonGt    *string                       `json:"startAfternoon_gt,omitempty"`
	StartAfternoonGte   *string                       `json:"startAfternoon_gte,omitempty"`
	EndAfternoon        *string                       `json:"endAfternoon,omitempty"`
	EndAfternoonNot     *string                       `json:"endAfternoon_not,omitempty"`
	EndAfternoonIn      []string                      `json:"endAfternoon_in,omitempty"`
	EndAfternoonNotIn   []string                      `json:"endAfternoon_not_in,omitempty"`
	EndAfternoonLt      *string                       `json:"endAfternoon_lt,omitempty"`
	EndAfternoonLte     *string                       `json:"endAfternoon_lte,omitempty"`
	EndAfternoonGt      *string                       `json:"endAfternoon_gt,omitempty"`
	EndAfternoonGte     *string                       `json:"endAfternoon_gte,omitempty"`
	And                 []BranchOpeningHourWhereInput `json:"AND,omitempty"`
	Or                  []BranchOpeningHourWhereInput `json:"OR,omitempty"`
	Not                 []BranchOpeningHourWhereInput `json:"NOT,omitempty"`
}

type NewsWhereInput struct {
	ID                 *string                    `json:"id,omitempty"`
	IDNot              *string                    `json:"id_not,omitempty"`
	IDIn               []string                   `json:"id_in,omitempty"`
	IDNotIn            []string                   `json:"id_not_in,omitempty"`
	IDLt               *string                    `json:"id_lt,omitempty"`
	IDLte              *string                    `json:"id_lte,omitempty"`
	IDGt               *string                    `json:"id_gt,omitempty"`
	IDGte              *string                    `json:"id_gte,omitempty"`
	IDContains         *string                    `json:"id_contains,omitempty"`
	IDNotContains      *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                    `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                    `json:"createdAt,omitempty"`
	CreatedAtNot       *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                    `json:"updatedAt_gte,omitempty"`
	Title              *LocalizedStringWhereInput `json:"title,omitempty"`
	Image              *string                    `json:"image,omitempty"`
	ImageNot           *string                    `json:"image_not,omitempty"`
	ImageIn            []string                   `json:"image_in,omitempty"`
	ImageNotIn         []string                   `json:"image_not_in,omitempty"`
	ImageLt            *string                    `json:"image_lt,omitempty"`
	ImageLte           *string                    `json:"image_lte,omitempty"`
	ImageGt            *string                    `json:"image_gt,omitempty"`
	ImageGte           *string                    `json:"image_gte,omitempty"`
	ImageContains      *string                    `json:"image_contains,omitempty"`
	ImageNotContains   *string                    `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                    `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                    `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                    `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                    `json:"image_not_ends_with,omitempty"`
	Branch             *BranchWhereInput          `json:"branch,omitempty"`
	Company            *CompanyWhereInput         `json:"company,omitempty"`
	And                []NewsWhereInput           `json:"AND,omitempty"`
	Or                 []NewsWhereInput           `json:"OR,omitempty"`
	Not                []NewsWhereInput           `json:"NOT,omitempty"`
}

type BranchImageSlotWhereInput struct {
	ID                    *string                     `json:"id,omitempty"`
	IDNot                 *string                     `json:"id_not,omitempty"`
	IDIn                  []string                    `json:"id_in,omitempty"`
	IDNotIn               []string                    `json:"id_not_in,omitempty"`
	IDLt                  *string                     `json:"id_lt,omitempty"`
	IDLte                 *string                     `json:"id_lte,omitempty"`
	IDGt                  *string                     `json:"id_gt,omitempty"`
	IDGte                 *string                     `json:"id_gte,omitempty"`
	IDContains            *string                     `json:"id_contains,omitempty"`
	IDNotContains         *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                     `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                     `json:"createdAt,omitempty"`
	CreatedAtNot          *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                     `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                     `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                     `json:"updatedAt_gte,omitempty"`
	SlotNumber            *int32                      `json:"slotNumber,omitempty"`
	SlotNumberNot         *int32                      `json:"slotNumber_not,omitempty"`
	SlotNumberIn          []int32                     `json:"slotNumber_in,omitempty"`
	SlotNumberNotIn       []int32                     `json:"slotNumber_not_in,omitempty"`
	SlotNumberLt          *int32                      `json:"slotNumber_lt,omitempty"`
	SlotNumberLte         *int32                      `json:"slotNumber_lte,omitempty"`
	SlotNumberGt          *int32                      `json:"slotNumber_gt,omitempty"`
	SlotNumberGte         *int32                      `json:"slotNumber_gte,omitempty"`
	Branch                *BranchWhereInput           `json:"branch,omitempty"`
	Company               *CompanyWhereInput          `json:"company,omitempty"`
	ImageUrl              *string                     `json:"imageUrl,omitempty"`
	ImageUrlNot           *string                     `json:"imageUrl_not,omitempty"`
	ImageUrlIn            []string                    `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn         []string                    `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt            *string                     `json:"imageUrl_lt,omitempty"`
	ImageUrlLte           *string                     `json:"imageUrl_lte,omitempty"`
	ImageUrlGt            *string                     `json:"imageUrl_gt,omitempty"`
	ImageUrlGte           *string                     `json:"imageUrl_gte,omitempty"`
	ImageUrlContains      *string                     `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains   *string                     `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith    *string                     `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith *string                     `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith      *string                     `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith   *string                     `json:"imageUrl_not_ends_with,omitempty"`
	And                   []BranchImageSlotWhereInput `json:"AND,omitempty"`
	Or                    []BranchImageSlotWhereInput `json:"OR,omitempty"`
	Not                   []BranchImageSlotWhereInput `json:"NOT,omitempty"`
}

type AppointmentWhereInput struct {
	ID                              *string                           `json:"id,omitempty"`
	IDNot                           *string                           `json:"id_not,omitempty"`
	IDIn                            []string                          `json:"id_in,omitempty"`
	IDNotIn                         []string                          `json:"id_not_in,omitempty"`
	IDLt                            *string                           `json:"id_lt,omitempty"`
	IDLte                           *string                           `json:"id_lte,omitempty"`
	IDGt                            *string                           `json:"id_gt,omitempty"`
	IDGte                           *string                           `json:"id_gte,omitempty"`
	IDContains                      *string                           `json:"id_contains,omitempty"`
	IDNotContains                   *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith                    *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith                 *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith                      *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith                   *string                           `json:"id_not_ends_with,omitempty"`
	CreatedAt                       *string                           `json:"createdAt,omitempty"`
	CreatedAtNot                    *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt                       *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot                    *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                     []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                  []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                     *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                    *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                     *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                    *string                           `json:"updatedAt_gte,omitempty"`
	Desc                            *LocalizedStringWhereInput        `json:"desc,omitempty"`
	Start                           *string                           `json:"start,omitempty"`
	StartNot                        *string                           `json:"start_not,omitempty"`
	StartIn                         []string                          `json:"start_in,omitempty"`
	StartNotIn                      []string                          `json:"start_not_in,omitempty"`
	StartLt                         *string                           `json:"start_lt,omitempty"`
	StartLte                        *string                           `json:"start_lte,omitempty"`
	StartGt                         *string                           `json:"start_gt,omitempty"`
	StartGte                        *string                           `json:"start_gte,omitempty"`
	End                             *string                           `json:"end,omitempty"`
	EndNot                          *string                           `json:"end_not,omitempty"`
	EndIn                           []string                          `json:"end_in,omitempty"`
	EndNotIn                        []string                          `json:"end_not_in,omitempty"`
	EndLt                           *string                           `json:"end_lt,omitempty"`
	EndLte                          *string                           `json:"end_lte,omitempty"`
	EndGt                           *string                           `json:"end_gt,omitempty"`
	EndGte                          *string                           `json:"end_gte,omitempty"`
	Price                           *int32                            `json:"price,omitempty"`
	PriceNot                        *int32                            `json:"price_not,omitempty"`
	PriceIn                         []int32                           `json:"price_in,omitempty"`
	PriceNotIn                      []int32                           `json:"price_not_in,omitempty"`
	PriceLt                         *int32                            `json:"price_lt,omitempty"`
	PriceLte                        *int32                            `json:"price_lte,omitempty"`
	PriceGt                         *int32                            `json:"price_gt,omitempty"`
	PriceGte                        *int32                            `json:"price_gte,omitempty"`
	Status                          *AppointmentStatus                `json:"status,omitempty"`
	StatusNot                       *AppointmentStatus                `json:"status_not,omitempty"`
	StatusIn                        []AppointmentStatus               `json:"status_in,omitempty"`
	StatusNotIn                     []AppointmentStatus               `json:"status_not_in,omitempty"`
	CustomerNotified                *bool                             `json:"customerNotified,omitempty"`
	CustomerNotifiedNot             *bool                             `json:"customerNotified_not,omitempty"`
	CustomerNotifiedAnHourBefore    *bool                             `json:"customerNotifiedAnHourBefore,omitempty"`
	CustomerNotifiedAnHourBeforeNot *bool                             `json:"customerNotifiedAnHourBefore_not,omitempty"`
	Note                            *string                           `json:"note,omitempty"`
	NoteNot                         *string                           `json:"note_not,omitempty"`
	NoteIn                          []string                          `json:"note_in,omitempty"`
	NoteNotIn                       []string                          `json:"note_not_in,omitempty"`
	NoteLt                          *string                           `json:"note_lt,omitempty"`
	NoteLte                         *string                           `json:"note_lte,omitempty"`
	NoteGt                          *string                           `json:"note_gt,omitempty"`
	NoteGte                         *string                           `json:"note_gte,omitempty"`
	NoteContains                    *string                           `json:"note_contains,omitempty"`
	NoteNotContains                 *string                           `json:"note_not_contains,omitempty"`
	NoteStartsWith                  *string                           `json:"note_starts_with,omitempty"`
	NoteNotStartsWith               *string                           `json:"note_not_starts_with,omitempty"`
	NoteEndsWith                    *string                           `json:"note_ends_with,omitempty"`
	NoteNotEndsWith                 *string                           `json:"note_not_ends_with,omitempty"`
	BeforeImage                     *string                           `json:"beforeImage,omitempty"`
	BeforeImageNot                  *string                           `json:"beforeImage_not,omitempty"`
	BeforeImageIn                   []string                          `json:"beforeImage_in,omitempty"`
	BeforeImageNotIn                []string                          `json:"beforeImage_not_in,omitempty"`
	BeforeImageLt                   *string                           `json:"beforeImage_lt,omitempty"`
	BeforeImageLte                  *string                           `json:"beforeImage_lte,omitempty"`
	BeforeImageGt                   *string                           `json:"beforeImage_gt,omitempty"`
	BeforeImageGte                  *string                           `json:"beforeImage_gte,omitempty"`
	BeforeImageContains             *string                           `json:"beforeImage_contains,omitempty"`
	BeforeImageNotContains          *string                           `json:"beforeImage_not_contains,omitempty"`
	BeforeImageStartsWith           *string                           `json:"beforeImage_starts_with,omitempty"`
	BeforeImageNotStartsWith        *string                           `json:"beforeImage_not_starts_with,omitempty"`
	BeforeImageEndsWith             *string                           `json:"beforeImage_ends_with,omitempty"`
	BeforeImageNotEndsWith          *string                           `json:"beforeImage_not_ends_with,omitempty"`
	AfterImage                      *string                           `json:"afterImage,omitempty"`
	AfterImageNot                   *string                           `json:"afterImage_not,omitempty"`
	AfterImageIn                    []string                          `json:"afterImage_in,omitempty"`
	AfterImageNotIn                 []string                          `json:"afterImage_not_in,omitempty"`
	AfterImageLt                    *string                           `json:"afterImage_lt,omitempty"`
	AfterImageLte                   *string                           `json:"afterImage_lte,omitempty"`
	AfterImageGt                    *string                           `json:"afterImage_gt,omitempty"`
	AfterImageGte                   *string                           `json:"afterImage_gte,omitempty"`
	AfterImageContains              *string                           `json:"afterImage_contains,omitempty"`
	AfterImageNotContains           *string                           `json:"afterImage_not_contains,omitempty"`
	AfterImageStartsWith            *string                           `json:"afterImage_starts_with,omitempty"`
	AfterImageNotStartsWith         *string                           `json:"afterImage_not_starts_with,omitempty"`
	AfterImageEndsWith              *string                           `json:"afterImage_ends_with,omitempty"`
	AfterImageNotEndsWith           *string                           `json:"afterImage_not_ends_with,omitempty"`
	Branch                          *BranchWhereInput                 `json:"branch,omitempty"`
	Company                         *CompanyWhereInput                `json:"company,omitempty"`
	Employee                        *UserWhereInput                   `json:"employee,omitempty"`
	Customer                        *UserWhereInput                   `json:"customer,omitempty"`
	ProductsEvery                   *AppointmentProductLinkWhereInput `json:"products_every,omitempty"`
	ProductsSome                    *AppointmentProductLinkWhereInput `json:"products_some,omitempty"`
	ProductsNone                    *AppointmentProductLinkWhereInput `json:"products_none,omitempty"`
	ServicesEvery                   *AppointmentServiceLinkWhereInput `json:"services_every,omitempty"`
	ServicesSome                    *AppointmentServiceLinkWhereInput `json:"services_some,omitempty"`
	ServicesNone                    *AppointmentServiceLinkWhereInput `json:"services_none,omitempty"`
	Review                          *ReviewWhereInput                 `json:"review,omitempty"`
	And                             []AppointmentWhereInput           `json:"AND,omitempty"`
	Or                              []AppointmentWhereInput           `json:"OR,omitempty"`
	Not                             []AppointmentWhereInput           `json:"NOT,omitempty"`
}

type AppointmentProductLinkWhereInput struct {
	ID              *string                            `json:"id,omitempty"`
	IDNot           *string                            `json:"id_not,omitempty"`
	IDIn            []string                           `json:"id_in,omitempty"`
	IDNotIn         []string                           `json:"id_not_in,omitempty"`
	IDLt            *string                            `json:"id_lt,omitempty"`
	IDLte           *string                            `json:"id_lte,omitempty"`
	IDGt            *string                            `json:"id_gt,omitempty"`
	IDGte           *string                            `json:"id_gte,omitempty"`
	IDContains      *string                            `json:"id_contains,omitempty"`
	IDNotContains   *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                            `json:"id_not_ends_with,omitempty"`
	Appointment     *AppointmentWhereInput             `json:"appointment,omitempty"`
	Product         *ProductWhereInput                 `json:"product,omitempty"`
	Count           *int32                             `json:"count,omitempty"`
	CountNot        *int32                             `json:"count_not,omitempty"`
	CountIn         []int32                            `json:"count_in,omitempty"`
	CountNotIn      []int32                            `json:"count_not_in,omitempty"`
	CountLt         *int32                             `json:"count_lt,omitempty"`
	CountLte        *int32                             `json:"count_lte,omitempty"`
	CountGt         *int32                             `json:"count_gt,omitempty"`
	CountGte        *int32                             `json:"count_gte,omitempty"`
	And             []AppointmentProductLinkWhereInput `json:"AND,omitempty"`
	Or              []AppointmentProductLinkWhereInput `json:"OR,omitempty"`
	Not             []AppointmentProductLinkWhereInput `json:"NOT,omitempty"`
}

type AppointmentServiceLinkWhereInput struct {
	ID              *string                            `json:"id,omitempty"`
	IDNot           *string                            `json:"id_not,omitempty"`
	IDIn            []string                           `json:"id_in,omitempty"`
	IDNotIn         []string                           `json:"id_not_in,omitempty"`
	IDLt            *string                            `json:"id_lt,omitempty"`
	IDLte           *string                            `json:"id_lte,omitempty"`
	IDGt            *string                            `json:"id_gt,omitempty"`
	IDGte           *string                            `json:"id_gte,omitempty"`
	IDContains      *string                            `json:"id_contains,omitempty"`
	IDNotContains   *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                            `json:"id_not_ends_with,omitempty"`
	Appointment     *AppointmentWhereInput             `json:"appointment,omitempty"`
	Service         *ServiceWhereInput                 `json:"service,omitempty"`
	And             []AppointmentServiceLinkWhereInput `json:"AND,omitempty"`
	Or              []AppointmentServiceLinkWhereInput `json:"OR,omitempty"`
	Not             []AppointmentServiceLinkWhereInput `json:"NOT,omitempty"`
}

type WorkingHoursWhereInput struct {
	ID                  *string                  `json:"id,omitempty"`
	IDNot               *string                  `json:"id_not,omitempty"`
	IDIn                []string                 `json:"id_in,omitempty"`
	IDNotIn             []string                 `json:"id_not_in,omitempty"`
	IDLt                *string                  `json:"id_lt,omitempty"`
	IDLte               *string                  `json:"id_lte,omitempty"`
	IDGt                *string                  `json:"id_gt,omitempty"`
	IDGte               *string                  `json:"id_gte,omitempty"`
	IDContains          *string                  `json:"id_contains,omitempty"`
	IDNotContains       *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt           *string                  `json:"createdAt,omitempty"`
	CreatedAtNot        *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                  `json:"updatedAt_gte,omitempty"`
	User                *UserWhereInput          `json:"user,omitempty"`
	Day                 *DayOfWeek               `json:"day,omitempty"`
	DayNot              *DayOfWeek               `json:"day_not,omitempty"`
	DayIn               []DayOfWeek              `json:"day_in,omitempty"`
	DayNotIn            []DayOfWeek              `json:"day_not_in,omitempty"`
	NotWorking          *bool                    `json:"notWorking,omitempty"`
	NotWorkingNot       *bool                    `json:"notWorking_not,omitempty"`
	Break               *bool                    `json:"break,omitempty"`
	BreakNot            *bool                    `json:"break_not,omitempty"`
	StartForenoon       *string                  `json:"startForenoon,omitempty"`
	StartForenoonNot    *string                  `json:"startForenoon_not,omitempty"`
	StartForenoonIn     []string                 `json:"startForenoon_in,omitempty"`
	StartForenoonNotIn  []string                 `json:"startForenoon_not_in,omitempty"`
	StartForenoonLt     *string                  `json:"startForenoon_lt,omitempty"`
	StartForenoonLte    *string                  `json:"startForenoon_lte,omitempty"`
	StartForenoonGt     *string                  `json:"startForenoon_gt,omitempty"`
	StartForenoonGte    *string                  `json:"startForenoon_gte,omitempty"`
	EndForenoon         *string                  `json:"endForenoon,omitempty"`
	EndForenoonNot      *string                  `json:"endForenoon_not,omitempty"`
	EndForenoonIn       []string                 `json:"endForenoon_in,omitempty"`
	EndForenoonNotIn    []string                 `json:"endForenoon_not_in,omitempty"`
	EndForenoonLt       *string                  `json:"endForenoon_lt,omitempty"`
	EndForenoonLte      *string                  `json:"endForenoon_lte,omitempty"`
	EndForenoonGt       *string                  `json:"endForenoon_gt,omitempty"`
	EndForenoonGte      *string                  `json:"endForenoon_gte,omitempty"`
	StartAfternoon      *string                  `json:"startAfternoon,omitempty"`
	StartAfternoonNot   *string                  `json:"startAfternoon_not,omitempty"`
	StartAfternoonIn    []string                 `json:"startAfternoon_in,omitempty"`
	StartAfternoonNotIn []string                 `json:"startAfternoon_not_in,omitempty"`
	StartAfternoonLt    *string                  `json:"startAfternoon_lt,omitempty"`
	StartAfternoonLte   *string                  `json:"startAfternoon_lte,omitempty"`
	StartAfternoonGt    *string                  `json:"startAfternoon_gt,omitempty"`
	StartAfternoonGte   *string                  `json:"startAfternoon_gte,omitempty"`
	EndAfternoon        *string                  `json:"endAfternoon,omitempty"`
	EndAfternoonNot     *string                  `json:"endAfternoon_not,omitempty"`
	EndAfternoonIn      []string                 `json:"endAfternoon_in,omitempty"`
	EndAfternoonNotIn   []string                 `json:"endAfternoon_not_in,omitempty"`
	EndAfternoonLt      *string                  `json:"endAfternoon_lt,omitempty"`
	EndAfternoonLte     *string                  `json:"endAfternoon_lte,omitempty"`
	EndAfternoonGt      *string                  `json:"endAfternoon_gt,omitempty"`
	EndAfternoonGte     *string                  `json:"endAfternoon_gte,omitempty"`
	Company             *CompanyWhereInput       `json:"company,omitempty"`
	Status              *AvailabilityStatus      `json:"status,omitempty"`
	StatusNot           *AvailabilityStatus      `json:"status_not,omitempty"`
	StatusIn            []AvailabilityStatus     `json:"status_in,omitempty"`
	StatusNotIn         []AvailabilityStatus     `json:"status_not_in,omitempty"`
	And                 []WorkingHoursWhereInput `json:"AND,omitempty"`
	Or                  []WorkingHoursWhereInput `json:"OR,omitempty"`
	Not                 []WorkingHoursWhereInput `json:"NOT,omitempty"`
}

type SessionWhereInput struct {
	ID                 *string             `json:"id,omitempty"`
	IDNot              *string             `json:"id_not,omitempty"`
	IDIn               []string            `json:"id_in,omitempty"`
	IDNotIn            []string            `json:"id_not_in,omitempty"`
	IDLt               *string             `json:"id_lt,omitempty"`
	IDLte              *string             `json:"id_lte,omitempty"`
	IDGt               *string             `json:"id_gt,omitempty"`
	IDGte              *string             `json:"id_gte,omitempty"`
	IDContains         *string             `json:"id_contains,omitempty"`
	IDNotContains      *string             `json:"id_not_contains,omitempty"`
	IDStartsWith       *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string             `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string             `json:"createdAt,omitempty"`
	CreatedAtNot       *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string             `json:"updatedAt_gte,omitempty"`
	Token              *string             `json:"token,omitempty"`
	TokenNot           *string             `json:"token_not,omitempty"`
	TokenIn            []string            `json:"token_in,omitempty"`
	TokenNotIn         []string            `json:"token_not_in,omitempty"`
	TokenLt            *string             `json:"token_lt,omitempty"`
	TokenLte           *string             `json:"token_lte,omitempty"`
	TokenGt            *string             `json:"token_gt,omitempty"`
	TokenGte           *string             `json:"token_gte,omitempty"`
	TokenContains      *string             `json:"token_contains,omitempty"`
	TokenNotContains   *string             `json:"token_not_contains,omitempty"`
	TokenStartsWith    *string             `json:"token_starts_with,omitempty"`
	TokenNotStartsWith *string             `json:"token_not_starts_with,omitempty"`
	TokenEndsWith      *string             `json:"token_ends_with,omitempty"`
	TokenNotEndsWith   *string             `json:"token_not_ends_with,omitempty"`
	User               *UserWhereInput     `json:"user,omitempty"`
	Company            *CompanyWhereInput  `json:"company,omitempty"`
	And                []SessionWhereInput `json:"AND,omitempty"`
	Or                 []SessionWhereInput `json:"OR,omitempty"`
	Not                []SessionWhereInput `json:"NOT,omitempty"`
}

type PasswordTokenWhereInput struct {
	ID                 *string                   `json:"id,omitempty"`
	IDNot              *string                   `json:"id_not,omitempty"`
	IDIn               []string                  `json:"id_in,omitempty"`
	IDNotIn            []string                  `json:"id_not_in,omitempty"`
	IDLt               *string                   `json:"id_lt,omitempty"`
	IDLte              *string                   `json:"id_lte,omitempty"`
	IDGt               *string                   `json:"id_gt,omitempty"`
	IDGte              *string                   `json:"id_gte,omitempty"`
	IDContains         *string                   `json:"id_contains,omitempty"`
	IDNotContains      *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                   `json:"createdAt,omitempty"`
	CreatedAtNot       *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                   `json:"updatedAt_gte,omitempty"`
	Token              *string                   `json:"token,omitempty"`
	TokenNot           *string                   `json:"token_not,omitempty"`
	TokenIn            []string                  `json:"token_in,omitempty"`
	TokenNotIn         []string                  `json:"token_not_in,omitempty"`
	TokenLt            *string                   `json:"token_lt,omitempty"`
	TokenLte           *string                   `json:"token_lte,omitempty"`
	TokenGt            *string                   `json:"token_gt,omitempty"`
	TokenGte           *string                   `json:"token_gte,omitempty"`
	TokenContains      *string                   `json:"token_contains,omitempty"`
	TokenNotContains   *string                   `json:"token_not_contains,omitempty"`
	TokenStartsWith    *string                   `json:"token_starts_with,omitempty"`
	TokenNotStartsWith *string                   `json:"token_not_starts_with,omitempty"`
	TokenEndsWith      *string                   `json:"token_ends_with,omitempty"`
	TokenNotEndsWith   *string                   `json:"token_not_ends_with,omitempty"`
	User               *UserWhereInput           `json:"user,omitempty"`
	And                []PasswordTokenWhereInput `json:"AND,omitempty"`
	Or                 []PasswordTokenWhereInput `json:"OR,omitempty"`
	Not                []PasswordTokenWhereInput `json:"NOT,omitempty"`
}

type AppointmentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AppointmentProductLinkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AppointmentServiceLinkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BranchWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BranchImageSlotWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BranchOpeningHourWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CompanyWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CustomUrlWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

type EmailTemplateWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type EmailTemplateWhereInput struct {
	ID                *string                    `json:"id,omitempty"`
	IDNot             *string                    `json:"id_not,omitempty"`
	IDIn              []string                   `json:"id_in,omitempty"`
	IDNotIn           []string                   `json:"id_not_in,omitempty"`
	IDLt              *string                    `json:"id_lt,omitempty"`
	IDLte             *string                    `json:"id_lte,omitempty"`
	IDGt              *string                    `json:"id_gt,omitempty"`
	IDGte             *string                    `json:"id_gte,omitempty"`
	IDContains        *string                    `json:"id_contains,omitempty"`
	IDNotContains     *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                    `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                    `json:"createdAt,omitempty"`
	CreatedAtNot      *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                    `json:"updatedAt_gte,omitempty"`
	Name              *string                    `json:"name,omitempty"`
	NameNot           *string                    `json:"name_not,omitempty"`
	NameIn            []string                   `json:"name_in,omitempty"`
	NameNotIn         []string                   `json:"name_not_in,omitempty"`
	NameLt            *string                    `json:"name_lt,omitempty"`
	NameLte           *string                    `json:"name_lte,omitempty"`
	NameGt            *string                    `json:"name_gt,omitempty"`
	NameGte           *string                    `json:"name_gte,omitempty"`
	NameContains      *string                    `json:"name_contains,omitempty"`
	NameNotContains   *string                    `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                    `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                    `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                    `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                    `json:"name_not_ends_with,omitempty"`
	Content           *LocalizedStringWhereInput `json:"content,omitempty"`
	Title             *LocalizedStringWhereInput `json:"title,omitempty"`
	Company           *CompanyWhereInput         `json:"company,omitempty"`
	And               []EmailTemplateWhereInput  `json:"AND,omitempty"`
	Or                []EmailTemplateWhereInput  `json:"OR,omitempty"`
	Not               []EmailTemplateWhereInput  `json:"NOT,omitempty"`
}

type FavoriteWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FavoriteWhereInput struct {
	ID              *string              `json:"id,omitempty"`
	IDNot           *string              `json:"id_not,omitempty"`
	IDIn            []string             `json:"id_in,omitempty"`
	IDNotIn         []string             `json:"id_not_in,omitempty"`
	IDLt            *string              `json:"id_lt,omitempty"`
	IDLte           *string              `json:"id_lte,omitempty"`
	IDGt            *string              `json:"id_gt,omitempty"`
	IDGte           *string              `json:"id_gte,omitempty"`
	IDContains      *string              `json:"id_contains,omitempty"`
	IDNotContains   *string              `json:"id_not_contains,omitempty"`
	IDStartsWith    *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string              `json:"id_not_ends_with,omitempty"`
	User            *UserWhereInput      `json:"user,omitempty"`
	Product         *ProductWhereInput   `json:"product,omitempty"`
	Service         *ServiceWhereInput   `json:"service,omitempty"`
	Company         *CompanyWhereInput   `json:"company,omitempty"`
	And             []FavoriteWhereInput `json:"AND,omitempty"`
	Or              []FavoriteWhereInput `json:"OR,omitempty"`
	Not             []FavoriteWhereInput `json:"NOT,omitempty"`
}

type LocalizedStringWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type NewsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PasswordTokenWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Token *string `json:"token,omitempty"`
}

type ProductWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ProductCategoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ProductServiceAttributeWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ProductSubCategoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ServiceWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ServiceCategoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ServiceSubCategoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type SessionWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Token *string `json:"token,omitempty"`
}

type UserWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type WorkingHoursWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AliasCreateInput struct {
	ID      *string                             `json:"id,omitempty"`
	Company CompanyCreateOneWithoutAliasesInput `json:"company"`
	Value   string                              `json:"value"`
}

type CompanyCreateOneWithoutAliasesInput struct {
	Create  *CompanyCreateWithoutAliasesInput `json:"create,omitempty"`
	Connect *CompanyWhereUniqueInput          `json:"connect,omitempty"`
}

type CompanyCreateWithoutAliasesInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput           `json:"name"`
	CustomUrls         *CustomUrlCreateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       LocalizedStringCreateOneInput           `json:"pwaShortName"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      string                                  `json:"pwaThemeColor"`
	PwaBackgroundColor string                                  `json:"pwaBackgroundColor"`
	Users              *UserCreateManyWithoutCompanyInput      `json:"users,omitempty"`
	Branches           *BranchCreateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type LocalizedStringCreateOneInput struct {
	Create  *LocalizedStringCreateInput      `json:"create,omitempty"`
	Connect *LocalizedStringWhereUniqueInput `json:"connect,omitempty"`
}

type LocalizedStringCreateInput struct {
	ID *string `json:"id,omitempty"`
	De *string `json:"de,omitempty"`
	En *string `json:"en,omitempty"`
	Tr *string `json:"tr,omitempty"`
}

type CustomUrlCreateManyWithoutCompanyInput struct {
	Create  []CustomUrlCreateWithoutCompanyInput `json:"create,omitempty"`
	Connect []CustomUrlWhereUniqueInput          `json:"connect,omitempty"`
}

type CustomUrlCreateWithoutCompanyInput struct {
	ID    *string `json:"id,omitempty"`
	Value string  `json:"value"`
}

type UserCreateManyWithoutCompanyInput struct {
	Create  []UserCreateWithoutCompanyInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput          `json:"connect,omitempty"`
}

type UserCreateWithoutCompanyInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewCreateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchCreateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursCreateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionCreateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenCreateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type ReviewCreateManyWithoutCustomerInput struct {
	Create  []ReviewCreateWithoutCustomerInput `json:"create,omitempty"`
	Connect []ReviewWhereUniqueInput           `json:"connect,omitempty"`
}

type ReviewCreateWithoutCustomerInput struct {
	ID          *string                                 `json:"id,omitempty"`
	Type        ReviewType                              `json:"type"`
	Stars       float64                                 `json:"stars"`
	Title       string                                  `json:"title"`
	Text        string                                  `json:"text"`
	Status      *ReviewStatus                           `json:"status,omitempty"`
	Product     *ProductCreateOneWithoutReviewsInput    `json:"product,omitempty"`
	Service     *ServiceCreateOneWithoutReviewsInput    `json:"service,omitempty"`
	Appointment *AppointmentCreateOneWithoutReviewInput `json:"appointment,omitempty"`
	Company     *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type ProductCreateOneWithoutReviewsInput struct {
	Create  *ProductCreateWithoutReviewsInput `json:"create,omitempty"`
	Connect *ProductWhereUniqueInput          `json:"connect,omitempty"`
}

type ProductCreateWithoutReviewsInput struct {
	ID          *string                                               `json:"id,omitempty"`
	Name        LocalizedStringCreateOneInput                         `json:"name"`
	Desc        LocalizedStringCreateOneInput                         `json:"desc"`
	Price       int32                                                 `json:"price"`
	Capacity    *string                                               `json:"capacity,omitempty"`
	Category    *ProductCategoryCreateOneInput                        `json:"category,omitempty"`
	SubCategory *ProductSubCategoryCreateOneWithoutProductsInput      `json:"subCategory,omitempty"`
	Image       *string                                               `json:"image,omitempty"`
	Attributes  *ProductServiceAttributeCreateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch      BranchCreateOneInput                                  `json:"branch"`
	Company     *CompanyCreateOneInput                                `json:"company,omitempty"`
	Deleted     *bool                                                 `json:"deleted,omitempty"`
	Active      *bool                                                 `json:"active,omitempty"`
}

type ProductCategoryCreateOneInput struct {
	Create  *ProductCategoryCreateInput      `json:"create,omitempty"`
	Connect *ProductCategoryWhereUniqueInput `json:"connect,omitempty"`
}

type ProductCategoryCreateInput struct {
	ID            *string                                           `json:"id,omitempty"`
	Name          string                                            `json:"name"`
	SubCategories *ProductSubCategoryCreateManyWithoutCategoryInput `json:"subCategories,omitempty"`
	Company       *CompanyCreateOneInput                            `json:"company,omitempty"`
}

type ProductSubCategoryCreateManyWithoutCategoryInput struct {
	Create  []ProductSubCategoryCreateWithoutCategoryInput `json:"create,omitempty"`
	Connect []ProductSubCategoryWhereUniqueInput           `json:"connect,omitempty"`
}

type ProductSubCategoryCreateWithoutCategoryInput struct {
	ID       *string                                   `json:"id,omitempty"`
	Name     string                                    `json:"name"`
	Products *ProductCreateManyWithoutSubCategoryInput `json:"products,omitempty"`
	Company  *CompanyCreateOneInput                    `json:"company,omitempty"`
}

type ProductCreateManyWithoutSubCategoryInput struct {
	Create  []ProductCreateWithoutSubCategoryInput `json:"create,omitempty"`
	Connect []ProductWhereUniqueInput              `json:"connect,omitempty"`
}

type ProductCreateWithoutSubCategoryInput struct {
	ID         *string                                               `json:"id,omitempty"`
	Name       LocalizedStringCreateOneInput                         `json:"name"`
	Desc       LocalizedStringCreateOneInput                         `json:"desc"`
	Price      int32                                                 `json:"price"`
	Capacity   *string                                               `json:"capacity,omitempty"`
	Category   *ProductCategoryCreateOneInput                        `json:"category,omitempty"`
	Image      *string                                               `json:"image,omitempty"`
	Attributes *ProductServiceAttributeCreateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch     BranchCreateOneInput                                  `json:"branch"`
	Company    *CompanyCreateOneInput                                `json:"company,omitempty"`
	Reviews    *ReviewCreateManyWithoutProductInput                  `json:"reviews,omitempty"`
	Deleted    *bool                                                 `json:"deleted,omitempty"`
	Active     *bool                                                 `json:"active,omitempty"`
}

type ProductServiceAttributeCreateManyWithoutProductInput struct {
	Create  []ProductServiceAttributeCreateWithoutProductInput `json:"create,omitempty"`
	Connect []ProductServiceAttributeWhereUniqueInput          `json:"connect,omitempty"`
}

type ProductServiceAttributeCreateWithoutProductInput struct {
	ID      *string                                 `json:"id,omitempty"`
	Service *ServiceCreateOneWithoutAttributesInput `json:"service,omitempty"`
	Key     string                                  `json:"key"`
	Name    LocalizedStringCreateOneInput           `json:"name"`
	Value   LocalizedStringCreateOneInput           `json:"value"`
	Company *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type ServiceCreateOneWithoutAttributesInput struct {
	Create  *ServiceCreateWithoutAttributesInput `json:"create,omitempty"`
	Connect *ServiceWhereUniqueInput             `json:"connect,omitempty"`
}

type ServiceCreateWithoutAttributesInput struct {
	ID           *string                                          `json:"id,omitempty"`
	Name         LocalizedStringCreateOneInput                    `json:"name"`
	Desc         LocalizedStringCreateOneInput                    `json:"desc"`
	Price        int32                                            `json:"price"`
	Duration     int32                                            `json:"duration"`
	Image        *string                                          `json:"image,omitempty"`
	GenderTarget *GenderTarget                                    `json:"genderTarget,omitempty"`
	Category     *ServiceCategoryCreateOneInput                   `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryCreateOneWithoutServicesInput `json:"subCategory,omitempty"`
	Branch       BranchCreateOneInput                             `json:"branch"`
	Company      *CompanyCreateOneInput                           `json:"company,omitempty"`
	Reviews      *ReviewCreateManyWithoutServiceInput             `json:"reviews,omitempty"`
	Deleted      *bool                                            `json:"deleted,omitempty"`
	Active       *bool                                            `json:"active,omitempty"`
}

type ServiceCategoryCreateOneInput struct {
	Create  *ServiceCategoryCreateInput      `json:"create,omitempty"`
	Connect *ServiceCategoryWhereUniqueInput `json:"connect,omitempty"`
}

type ServiceCategoryCreateInput struct {
	ID            *string                                           `json:"id,omitempty"`
	Name          string                                            `json:"name"`
	SubCategories *ServiceSubCategoryCreateManyWithoutCategoryInput `json:"subCategories,omitempty"`
	Company       *CompanyCreateOneInput                            `json:"company,omitempty"`
}

type ServiceSubCategoryCreateManyWithoutCategoryInput struct {
	Create  []ServiceSubCategoryCreateWithoutCategoryInput `json:"create,omitempty"`
	Connect []ServiceSubCategoryWhereUniqueInput           `json:"connect,omitempty"`
}

type ServiceSubCategoryCreateWithoutCategoryInput struct {
	ID       *string                                   `json:"id,omitempty"`
	Name     string                                    `json:"name"`
	Company  *CompanyCreateOneInput                    `json:"company,omitempty"`
	Services *ServiceCreateManyWithoutSubCategoryInput `json:"services,omitempty"`
}

type CompanyCreateOneInput struct {
	Create  *CompanyCreateInput      `json:"create,omitempty"`
	Connect *CompanyWhereUniqueInput `json:"connect,omitempty"`
}

type CompanyCreateInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput           `json:"name"`
	CustomUrls         *CustomUrlCreateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasCreateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       LocalizedStringCreateOneInput           `json:"pwaShortName"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      string                                  `json:"pwaThemeColor"`
	PwaBackgroundColor string                                  `json:"pwaBackgroundColor"`
	Users              *UserCreateManyWithoutCompanyInput      `json:"users,omitempty"`
	Branches           *BranchCreateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type AliasCreateManyWithoutCompanyInput struct {
	Create  []AliasCreateWithoutCompanyInput `json:"create,omitempty"`
	Connect []AliasWhereUniqueInput          `json:"connect,omitempty"`
}

type AliasCreateWithoutCompanyInput struct {
	ID    *string `json:"id,omitempty"`
	Value string  `json:"value"`
}

type BranchCreateManyWithoutCompanyInput struct {
	Create  []BranchCreateWithoutCompanyInput `json:"create,omitempty"`
	Connect []BranchWhereUniqueInput          `json:"connect,omitempty"`
}

type BranchCreateWithoutCompanyInput struct {
	ID                 *string                                        `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput                  `json:"name"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     LocalizedStringCreateOneInput                  `json:"welcomeMessage"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchCreateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         string                                         `json:"websiteUrl"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            string                                         `json:"imprint"`
	Employees          *UserCreateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourCreateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsCreateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotCreateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchCreateimagesInput struct {
	Set []string `json:"set,omitempty"`
}

type UserCreateManyWithoutBranchInput struct {
	Create  []UserCreateWithoutBranchInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput         `json:"connect,omitempty"`
}

type UserCreateWithoutBranchInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyCreateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewCreateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	WorkingHours       *WorkingHoursCreateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionCreateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenCreateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type CompanyCreateOneWithoutUsersInput struct {
	Create  *CompanyCreateWithoutUsersInput `json:"create,omitempty"`
	Connect *CompanyWhereUniqueInput        `json:"connect,omitempty"`
}

type CompanyCreateWithoutUsersInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput           `json:"name"`
	CustomUrls         *CustomUrlCreateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasCreateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       LocalizedStringCreateOneInput           `json:"pwaShortName"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      string                                  `json:"pwaThemeColor"`
	PwaBackgroundColor string                                  `json:"pwaBackgroundColor"`
	Branches           *BranchCreateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type WorkingHoursCreateManyWithoutUserInput struct {
	Create  []WorkingHoursCreateWithoutUserInput `json:"create,omitempty"`
	Connect []WorkingHoursWhereUniqueInput       `json:"connect,omitempty"`
}

type WorkingHoursCreateWithoutUserInput struct {
	ID             *string                `json:"id,omitempty"`
	Day            DayOfWeek              `json:"day"`
	NotWorking     *bool                  `json:"notWorking,omitempty"`
	Break          *bool                  `json:"break,omitempty"`
	StartForenoon  *string                `json:"startForenoon,omitempty"`
	EndForenoon    *string                `json:"endForenoon,omitempty"`
	StartAfternoon *string                `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                `json:"endAfternoon,omitempty"`
	Company        *CompanyCreateOneInput `json:"company,omitempty"`
	Status         *AvailabilityStatus    `json:"status,omitempty"`
}

type SessionCreateManyWithoutUserInput struct {
	Create  []SessionCreateWithoutUserInput `json:"create,omitempty"`
	Connect []SessionWhereUniqueInput       `json:"connect,omitempty"`
}

type SessionCreateWithoutUserInput struct {
	ID      *string                `json:"id,omitempty"`
	Token   string                 `json:"token"`
	Company *CompanyCreateOneInput `json:"company,omitempty"`
}

type PasswordTokenCreateOneWithoutUserInput struct {
	Create  *PasswordTokenCreateWithoutUserInput `json:"create,omitempty"`
	Connect *PasswordTokenWhereUniqueInput       `json:"connect,omitempty"`
}

type PasswordTokenCreateWithoutUserInput struct {
	ID    *string `json:"id,omitempty"`
	Token string  `json:"token"`
}

type BranchOpeningHourCreateManyWithoutBranchInput struct {
	Create  []BranchOpeningHourCreateWithoutBranchInput `json:"create,omitempty"`
	Connect []BranchOpeningHourWhereUniqueInput         `json:"connect,omitempty"`
}

type BranchOpeningHourCreateWithoutBranchInput struct {
	ID             *string                `json:"id,omitempty"`
	Company        *CompanyCreateOneInput `json:"company,omitempty"`
	Day            DayOfWeek              `json:"day"`
	Closed         *bool                  `json:"closed,omitempty"`
	Break          *bool                  `json:"break,omitempty"`
	StartForenoon  *string                `json:"startForenoon,omitempty"`
	EndForenoon    *string                `json:"endForenoon,omitempty"`
	StartAfternoon *string                `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                `json:"endAfternoon,omitempty"`
}

type NewsCreateManyWithoutBranchInput struct {
	Create  []NewsCreateWithoutBranchInput `json:"create,omitempty"`
	Connect []NewsWhereUniqueInput         `json:"connect,omitempty"`
}

type NewsCreateWithoutBranchInput struct {
	ID      *string                       `json:"id,omitempty"`
	Title   LocalizedStringCreateOneInput `json:"title"`
	Image   *string                       `json:"image,omitempty"`
	Company *CompanyCreateOneInput        `json:"company,omitempty"`
}

type BranchImageSlotCreateManyWithoutBranchInput struct {
	Create  []BranchImageSlotCreateWithoutBranchInput `json:"create,omitempty"`
	Connect []BranchImageSlotWhereUniqueInput         `json:"connect,omitempty"`
}

type BranchImageSlotCreateWithoutBranchInput struct {
	ID         *string                `json:"id,omitempty"`
	SlotNumber int32                  `json:"slotNumber"`
	Company    *CompanyCreateOneInput `json:"company,omitempty"`
	ImageUrl   string                 `json:"imageUrl"`
}

type ServiceCreateManyWithoutSubCategoryInput struct {
	Create  []ServiceCreateWithoutSubCategoryInput `json:"create,omitempty"`
	Connect []ServiceWhereUniqueInput              `json:"connect,omitempty"`
}

type ServiceCreateWithoutSubCategoryInput struct {
	ID           *string                                               `json:"id,omitempty"`
	Name         LocalizedStringCreateOneInput                         `json:"name"`
	Desc         LocalizedStringCreateOneInput                         `json:"desc"`
	Price        int32                                                 `json:"price"`
	Duration     int32                                                 `json:"duration"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeCreateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryCreateOneInput                        `json:"category,omitempty"`
	Branch       BranchCreateOneInput                                  `json:"branch"`
	Company      *CompanyCreateOneInput                                `json:"company,omitempty"`
	Reviews      *ReviewCreateManyWithoutServiceInput                  `json:"reviews,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ProductServiceAttributeCreateManyWithoutServiceInput struct {
	Create  []ProductServiceAttributeCreateWithoutServiceInput `json:"create,omitempty"`
	Connect []ProductServiceAttributeWhereUniqueInput          `json:"connect,omitempty"`
}

type ProductServiceAttributeCreateWithoutServiceInput struct {
	ID      *string                                 `json:"id,omitempty"`
	Product *ProductCreateOneWithoutAttributesInput `json:"product,omitempty"`
	Key     string                                  `json:"key"`
	Name    LocalizedStringCreateOneInput           `json:"name"`
	Value   LocalizedStringCreateOneInput           `json:"value"`
	Company *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type ProductCreateOneWithoutAttributesInput struct {
	Create  *ProductCreateWithoutAttributesInput `json:"create,omitempty"`
	Connect *ProductWhereUniqueInput             `json:"connect,omitempty"`
}

type ProductCreateWithoutAttributesInput struct {
	ID          *string                                          `json:"id,omitempty"`
	Name        LocalizedStringCreateOneInput                    `json:"name"`
	Desc        LocalizedStringCreateOneInput                    `json:"desc"`
	Price       int32                                            `json:"price"`
	Capacity    *string                                          `json:"capacity,omitempty"`
	Category    *ProductCategoryCreateOneInput                   `json:"category,omitempty"`
	SubCategory *ProductSubCategoryCreateOneWithoutProductsInput `json:"subCategory,omitempty"`
	Image       *string                                          `json:"image,omitempty"`
	Branch      BranchCreateOneInput                             `json:"branch"`
	Company     *CompanyCreateOneInput                           `json:"company,omitempty"`
	Reviews     *ReviewCreateManyWithoutProductInput             `json:"reviews,omitempty"`
	Deleted     *bool                                            `json:"deleted,omitempty"`
	Active      *bool                                            `json:"active,omitempty"`
}

type ProductSubCategoryCreateOneWithoutProductsInput struct {
	Create  *ProductSubCategoryCreateWithoutProductsInput `json:"create,omitempty"`
	Connect *ProductSubCategoryWhereUniqueInput           `json:"connect,omitempty"`
}

type ProductSubCategoryCreateWithoutProductsInput struct {
	ID       *string                                            `json:"id,omitempty"`
	Name     string                                             `json:"name"`
	Category *ProductCategoryCreateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Company  *CompanyCreateOneInput                             `json:"company,omitempty"`
}

type ProductCategoryCreateOneWithoutSubCategoriesInput struct {
	Create  *ProductCategoryCreateWithoutSubCategoriesInput `json:"create,omitempty"`
	Connect *ProductCategoryWhereUniqueInput                `json:"connect,omitempty"`
}

type ProductCategoryCreateWithoutSubCategoriesInput struct {
	ID      *string                `json:"id,omitempty"`
	Name    string                 `json:"name"`
	Company *CompanyCreateOneInput `json:"company,omitempty"`
}

type BranchCreateOneInput struct {
	Create  *BranchCreateInput      `json:"create,omitempty"`
	Connect *BranchWhereUniqueInput `json:"connect,omitempty"`
}

type BranchCreateInput struct {
	ID                 *string                                        `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput                  `json:"name"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     LocalizedStringCreateOneInput                  `json:"welcomeMessage"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchCreateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         string                                         `json:"websiteUrl"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            string                                         `json:"imprint"`
	Company            CompanyCreateOneWithoutBranchesInput           `json:"company"`
	Employees          *UserCreateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourCreateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsCreateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotCreateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type CompanyCreateOneWithoutBranchesInput struct {
	Create  *CompanyCreateWithoutBranchesInput `json:"create,omitempty"`
	Connect *CompanyWhereUniqueInput           `json:"connect,omitempty"`
}

type CompanyCreateWithoutBranchesInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput           `json:"name"`
	CustomUrls         *CustomUrlCreateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasCreateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       LocalizedStringCreateOneInput           `json:"pwaShortName"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      string                                  `json:"pwaThemeColor"`
	PwaBackgroundColor string                                  `json:"pwaBackgroundColor"`
	Users              *UserCreateManyWithoutCompanyInput      `json:"users,omitempty"`
}

type ReviewCreateManyWithoutProductInput struct {
	Create  []ReviewCreateWithoutProductInput `json:"create,omitempty"`
	Connect []ReviewWhereUniqueInput          `json:"connect,omitempty"`
}

type ReviewCreateWithoutProductInput struct {
	ID          *string                                 `json:"id,omitempty"`
	Type        ReviewType                              `json:"type"`
	Stars       float64                                 `json:"stars"`
	Title       string                                  `json:"title"`
	Text        string                                  `json:"text"`
	Status      *ReviewStatus                           `json:"status,omitempty"`
	Customer    UserCreateOneWithoutReviewsInput        `json:"customer"`
	Service     *ServiceCreateOneWithoutReviewsInput    `json:"service,omitempty"`
	Appointment *AppointmentCreateOneWithoutReviewInput `json:"appointment,omitempty"`
	Company     *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type UserCreateOneWithoutReviewsInput struct {
	Create  *UserCreateWithoutReviewsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput          `json:"connect,omitempty"`
}

type UserCreateWithoutReviewsInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyCreateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchCreateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursCreateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionCreateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenCreateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type BranchCreateOneWithoutEmployeesInput struct {
	Create  *BranchCreateWithoutEmployeesInput `json:"create,omitempty"`
	Connect *BranchWhereUniqueInput            `json:"connect,omitempty"`
}

type BranchCreateWithoutEmployeesInput struct {
	ID                 *string                                        `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput                  `json:"name"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     LocalizedStringCreateOneInput                  `json:"welcomeMessage"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchCreateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         string                                         `json:"websiteUrl"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            string                                         `json:"imprint"`
	Company            CompanyCreateOneWithoutBranchesInput           `json:"company"`
	OpeningHours       *BranchOpeningHourCreateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsCreateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotCreateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type ServiceCreateOneWithoutReviewsInput struct {
	Create  *ServiceCreateWithoutReviewsInput `json:"create,omitempty"`
	Connect *ServiceWhereUniqueInput          `json:"connect,omitempty"`
}

type ServiceCreateWithoutReviewsInput struct {
	ID           *string                                               `json:"id,omitempty"`
	Name         LocalizedStringCreateOneInput                         `json:"name"`
	Desc         LocalizedStringCreateOneInput                         `json:"desc"`
	Price        int32                                                 `json:"price"`
	Duration     int32                                                 `json:"duration"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeCreateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryCreateOneInput                        `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryCreateOneWithoutServicesInput      `json:"subCategory,omitempty"`
	Branch       BranchCreateOneInput                                  `json:"branch"`
	Company      *CompanyCreateOneInput                                `json:"company,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ServiceSubCategoryCreateOneWithoutServicesInput struct {
	Create  *ServiceSubCategoryCreateWithoutServicesInput `json:"create,omitempty"`
	Connect *ServiceSubCategoryWhereUniqueInput           `json:"connect,omitempty"`
}

type ServiceSubCategoryCreateWithoutServicesInput struct {
	ID       *string                                            `json:"id,omitempty"`
	Name     string                                             `json:"name"`
	Category *ServiceCategoryCreateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Company  *CompanyCreateOneInput                             `json:"company,omitempty"`
}

type ServiceCategoryCreateOneWithoutSubCategoriesInput struct {
	Create  *ServiceCategoryCreateWithoutSubCategoriesInput `json:"create,omitempty"`
	Connect *ServiceCategoryWhereUniqueInput                `json:"connect,omitempty"`
}

type ServiceCategoryCreateWithoutSubCategoriesInput struct {
	ID      *string                `json:"id,omitempty"`
	Name    string                 `json:"name"`
	Company *CompanyCreateOneInput `json:"company,omitempty"`
}

type AppointmentCreateOneWithoutReviewInput struct {
	Create  *AppointmentCreateWithoutReviewInput `json:"create,omitempty"`
	Connect *AppointmentWhereUniqueInput         `json:"connect,omitempty"`
}

type AppointmentCreateWithoutReviewInput struct {
	ID                           *string                                                  `json:"id,omitempty"`
	Desc                         *LocalizedStringCreateOneInput                           `json:"desc,omitempty"`
	Start                        string                                                   `json:"start"`
	End                          string                                                   `json:"end"`
	Price                        int32                                                    `json:"price"`
	Status                       AppointmentStatus                                        `json:"status"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       BranchCreateOneInput                                     `json:"branch"`
	Company                      *CompanyCreateOneInput                                   `json:"company,omitempty"`
	Employee                     UserCreateOneInput                                       `json:"employee"`
	Customer                     UserCreateOneInput                                       `json:"customer"`
	Products                     *AppointmentProductLinkCreateManyWithoutAppointmentInput `json:"products,omitempty"`
	Services                     *AppointmentServiceLinkCreateManyWithoutAppointmentInput `json:"services,omitempty"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserCreateInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyCreateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewCreateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchCreateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursCreateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionCreateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenCreateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type AppointmentProductLinkCreateManyWithoutAppointmentInput struct {
	Create  []AppointmentProductLinkCreateWithoutAppointmentInput `json:"create,omitempty"`
	Connect []AppointmentProductLinkWhereUniqueInput              `json:"connect,omitempty"`
}

type AppointmentProductLinkCreateWithoutAppointmentInput struct {
	ID      *string               `json:"id,omitempty"`
	Product ProductCreateOneInput `json:"product"`
	Count   int32                 `json:"count"`
}

type ProductCreateOneInput struct {
	Create  *ProductCreateInput      `json:"create,omitempty"`
	Connect *ProductWhereUniqueInput `json:"connect,omitempty"`
}

type ProductCreateInput struct {
	ID          *string                                               `json:"id,omitempty"`
	Name        LocalizedStringCreateOneInput                         `json:"name"`
	Desc        LocalizedStringCreateOneInput                         `json:"desc"`
	Price       int32                                                 `json:"price"`
	Capacity    *string                                               `json:"capacity,omitempty"`
	Category    *ProductCategoryCreateOneInput                        `json:"category,omitempty"`
	SubCategory *ProductSubCategoryCreateOneWithoutProductsInput      `json:"subCategory,omitempty"`
	Image       *string                                               `json:"image,omitempty"`
	Attributes  *ProductServiceAttributeCreateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch      BranchCreateOneInput                                  `json:"branch"`
	Company     *CompanyCreateOneInput                                `json:"company,omitempty"`
	Reviews     *ReviewCreateManyWithoutProductInput                  `json:"reviews,omitempty"`
	Deleted     *bool                                                 `json:"deleted,omitempty"`
	Active      *bool                                                 `json:"active,omitempty"`
}

type AppointmentServiceLinkCreateManyWithoutAppointmentInput struct {
	Create  []AppointmentServiceLinkCreateWithoutAppointmentInput `json:"create,omitempty"`
	Connect []AppointmentServiceLinkWhereUniqueInput              `json:"connect,omitempty"`
}

type AppointmentServiceLinkCreateWithoutAppointmentInput struct {
	ID      *string               `json:"id,omitempty"`
	Service ServiceCreateOneInput `json:"service"`
}

type ServiceCreateOneInput struct {
	Create  *ServiceCreateInput      `json:"create,omitempty"`
	Connect *ServiceWhereUniqueInput `json:"connect,omitempty"`
}

type ServiceCreateInput struct {
	ID           *string                                               `json:"id,omitempty"`
	Name         LocalizedStringCreateOneInput                         `json:"name"`
	Desc         LocalizedStringCreateOneInput                         `json:"desc"`
	Price        int32                                                 `json:"price"`
	Duration     int32                                                 `json:"duration"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeCreateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryCreateOneInput                        `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryCreateOneWithoutServicesInput      `json:"subCategory,omitempty"`
	Branch       BranchCreateOneInput                                  `json:"branch"`
	Company      *CompanyCreateOneInput                                `json:"company,omitempty"`
	Reviews      *ReviewCreateManyWithoutServiceInput                  `json:"reviews,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ReviewCreateManyWithoutServiceInput struct {
	Create  []ReviewCreateWithoutServiceInput `json:"create,omitempty"`
	Connect []ReviewWhereUniqueInput          `json:"connect,omitempty"`
}

type ReviewCreateWithoutServiceInput struct {
	ID          *string                                 `json:"id,omitempty"`
	Type        ReviewType                              `json:"type"`
	Stars       float64                                 `json:"stars"`
	Title       string                                  `json:"title"`
	Text        string                                  `json:"text"`
	Status      *ReviewStatus                           `json:"status,omitempty"`
	Customer    UserCreateOneWithoutReviewsInput        `json:"customer"`
	Product     *ProductCreateOneWithoutReviewsInput    `json:"product,omitempty"`
	Appointment *AppointmentCreateOneWithoutReviewInput `json:"appointment,omitempty"`
	Company     *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type AliasUpdateInput struct {
	Company *CompanyUpdateOneRequiredWithoutAliasesInput `json:"company,omitempty"`
	Value   *string                                      `json:"value,omitempty"`
}

type CompanyUpdateOneRequiredWithoutAliasesInput struct {
	Create  *CompanyCreateWithoutAliasesInput     `json:"create,omitempty"`
	Update  *CompanyUpdateWithoutAliasesDataInput `json:"update,omitempty"`
	Upsert  *CompanyUpsertWithoutAliasesInput     `json:"upsert,omitempty"`
	Connect *CompanyWhereUniqueInput              `json:"connect,omitempty"`
}

type CompanyUpdateWithoutAliasesDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	CustomUrls         *CustomUrlUpdateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       *LocalizedStringUpdateOneRequiredInput  `json:"pwaShortName,omitempty"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string                                 `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string                                 `json:"pwaBackgroundColor,omitempty"`
	Users              *UserUpdateManyWithoutCompanyInput      `json:"users,omitempty"`
	Branches           *BranchUpdateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type LocalizedStringUpdateOneRequiredInput struct {
	Create  *LocalizedStringCreateInput       `json:"create,omitempty"`
	Update  *LocalizedStringUpdateDataInput   `json:"update,omitempty"`
	Upsert  *LocalizedStringUpsertNestedInput `json:"upsert,omitempty"`
	Connect *LocalizedStringWhereUniqueInput  `json:"connect,omitempty"`
}

type LocalizedStringUpdateDataInput struct {
	De *string `json:"de,omitempty"`
	En *string `json:"en,omitempty"`
	Tr *string `json:"tr,omitempty"`
}

type LocalizedStringUpsertNestedInput struct {
	Update LocalizedStringUpdateDataInput `json:"update"`
	Create LocalizedStringCreateInput     `json:"create"`
}

type CustomUrlUpdateManyWithoutCompanyInput struct {
	Create     []CustomUrlCreateWithoutCompanyInput                `json:"create,omitempty"`
	Delete     []CustomUrlWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []CustomUrlWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []CustomUrlWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []CustomUrlWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []CustomUrlUpdateWithWhereUniqueWithoutCompanyInput `json:"update,omitempty"`
	Upsert     []CustomUrlUpsertWithWhereUniqueWithoutCompanyInput `json:"upsert,omitempty"`
	DeleteMany []CustomUrlScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []CustomUrlUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type CustomUrlUpdateWithWhereUniqueWithoutCompanyInput struct {
	Where CustomUrlWhereUniqueInput              `json:"where"`
	Data  CustomUrlUpdateWithoutCompanyDataInput `json:"data"`
}

type CustomUrlUpdateWithoutCompanyDataInput struct {
	Value *string `json:"value,omitempty"`
}

type CustomUrlUpsertWithWhereUniqueWithoutCompanyInput struct {
	Where  CustomUrlWhereUniqueInput              `json:"where"`
	Update CustomUrlUpdateWithoutCompanyDataInput `json:"update"`
	Create CustomUrlCreateWithoutCompanyInput     `json:"create"`
}

type CustomUrlScalarWhereInput struct {
	ID                 *string                     `json:"id,omitempty"`
	IDNot              *string                     `json:"id_not,omitempty"`
	IDIn               []string                    `json:"id_in,omitempty"`
	IDNotIn            []string                    `json:"id_not_in,omitempty"`
	IDLt               *string                     `json:"id_lt,omitempty"`
	IDLte              *string                     `json:"id_lte,omitempty"`
	IDGt               *string                     `json:"id_gt,omitempty"`
	IDGte              *string                     `json:"id_gte,omitempty"`
	IDContains         *string                     `json:"id_contains,omitempty"`
	IDNotContains      *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                     `json:"id_not_ends_with,omitempty"`
	Value              *string                     `json:"value,omitempty"`
	ValueNot           *string                     `json:"value_not,omitempty"`
	ValueIn            []string                    `json:"value_in,omitempty"`
	ValueNotIn         []string                    `json:"value_not_in,omitempty"`
	ValueLt            *string                     `json:"value_lt,omitempty"`
	ValueLte           *string                     `json:"value_lte,omitempty"`
	ValueGt            *string                     `json:"value_gt,omitempty"`
	ValueGte           *string                     `json:"value_gte,omitempty"`
	ValueContains      *string                     `json:"value_contains,omitempty"`
	ValueNotContains   *string                     `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string                     `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string                     `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string                     `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string                     `json:"value_not_ends_with,omitempty"`
	And                []CustomUrlScalarWhereInput `json:"AND,omitempty"`
	Or                 []CustomUrlScalarWhereInput `json:"OR,omitempty"`
	Not                []CustomUrlScalarWhereInput `json:"NOT,omitempty"`
}

type CustomUrlUpdateManyWithWhereNestedInput struct {
	Where CustomUrlScalarWhereInput    `json:"where"`
	Data  CustomUrlUpdateManyDataInput `json:"data"`
}

type CustomUrlUpdateManyDataInput struct {
	Value *string `json:"value,omitempty"`
}

type UserUpdateManyWithoutCompanyInput struct {
	Create     []UserCreateWithoutCompanyInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutCompanyInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutCompanyInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutCompanyInput struct {
	Where UserWhereUniqueInput              `json:"where"`
	Data  UserUpdateWithoutCompanyDataInput `json:"data"`
}

type UserUpdateWithoutCompanyDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type ReviewUpdateManyWithoutCustomerInput struct {
	Create     []ReviewCreateWithoutCustomerInput                `json:"create,omitempty"`
	Delete     []ReviewWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []ReviewWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []ReviewWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []ReviewWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []ReviewUpdateWithWhereUniqueWithoutCustomerInput `json:"update,omitempty"`
	Upsert     []ReviewUpsertWithWhereUniqueWithoutCustomerInput `json:"upsert,omitempty"`
	DeleteMany []ReviewScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []ReviewUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type ReviewUpdateWithWhereUniqueWithoutCustomerInput struct {
	Where ReviewWhereUniqueInput               `json:"where"`
	Data  ReviewUpdateWithoutCustomerDataInput `json:"data"`
}

type ReviewUpdateWithoutCustomerDataInput struct {
	Type        *ReviewType                             `json:"type,omitempty"`
	Stars       *float64                                `json:"stars,omitempty"`
	Title       *string                                 `json:"title,omitempty"`
	Text        *string                                 `json:"text,omitempty"`
	Status      *ReviewStatus                           `json:"status,omitempty"`
	Product     *ProductUpdateOneWithoutReviewsInput    `json:"product,omitempty"`
	Service     *ServiceUpdateOneWithoutReviewsInput    `json:"service,omitempty"`
	Appointment *AppointmentUpdateOneWithoutReviewInput `json:"appointment,omitempty"`
	Company     *CompanyUpdateOneInput                  `json:"company,omitempty"`
}

type ProductUpdateOneWithoutReviewsInput struct {
	Create     *ProductCreateWithoutReviewsInput     `json:"create,omitempty"`
	Update     *ProductUpdateWithoutReviewsDataInput `json:"update,omitempty"`
	Upsert     *ProductUpsertWithoutReviewsInput     `json:"upsert,omitempty"`
	Delete     *bool                                 `json:"delete,omitempty"`
	Disconnect *bool                                 `json:"disconnect,omitempty"`
	Connect    *ProductWhereUniqueInput              `json:"connect,omitempty"`
}

type ProductUpdateWithoutReviewsDataInput struct {
	Name        *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc        *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price       *int32                                                `json:"price,omitempty"`
	Capacity    *string                                               `json:"capacity,omitempty"`
	Category    *ProductCategoryUpdateOneInput                        `json:"category,omitempty"`
	SubCategory *ProductSubCategoryUpdateOneWithoutProductsInput      `json:"subCategory,omitempty"`
	Image       *string                                               `json:"image,omitempty"`
	Attributes  *ProductServiceAttributeUpdateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch      *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company     *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Deleted     *bool                                                 `json:"deleted,omitempty"`
	Active      *bool                                                 `json:"active,omitempty"`
}

type ProductCategoryUpdateOneInput struct {
	Create     *ProductCategoryCreateInput       `json:"create,omitempty"`
	Update     *ProductCategoryUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ProductCategoryUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *ProductCategoryWhereUniqueInput  `json:"connect,omitempty"`
}

type ProductCategoryUpdateDataInput struct {
	Name          *string                                           `json:"name,omitempty"`
	SubCategories *ProductSubCategoryUpdateManyWithoutCategoryInput `json:"subCategories,omitempty"`
	Company       *CompanyUpdateOneInput                            `json:"company,omitempty"`
}

type ProductSubCategoryUpdateManyWithoutCategoryInput struct {
	Create     []ProductSubCategoryCreateWithoutCategoryInput                `json:"create,omitempty"`
	Delete     []ProductSubCategoryWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []ProductSubCategoryWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []ProductSubCategoryWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []ProductSubCategoryWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []ProductSubCategoryUpdateWithWhereUniqueWithoutCategoryInput `json:"update,omitempty"`
	Upsert     []ProductSubCategoryUpsertWithWhereUniqueWithoutCategoryInput `json:"upsert,omitempty"`
	DeleteMany []ProductSubCategoryScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []ProductSubCategoryUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type ProductSubCategoryUpdateWithWhereUniqueWithoutCategoryInput struct {
	Where ProductSubCategoryWhereUniqueInput               `json:"where"`
	Data  ProductSubCategoryUpdateWithoutCategoryDataInput `json:"data"`
}

type ProductSubCategoryUpdateWithoutCategoryDataInput struct {
	Name     *string                                   `json:"name,omitempty"`
	Products *ProductUpdateManyWithoutSubCategoryInput `json:"products,omitempty"`
	Company  *CompanyUpdateOneInput                    `json:"company,omitempty"`
}

type ProductUpdateManyWithoutSubCategoryInput struct {
	Create     []ProductCreateWithoutSubCategoryInput                `json:"create,omitempty"`
	Delete     []ProductWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []ProductWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []ProductWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []ProductWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []ProductUpdateWithWhereUniqueWithoutSubCategoryInput `json:"update,omitempty"`
	Upsert     []ProductUpsertWithWhereUniqueWithoutSubCategoryInput `json:"upsert,omitempty"`
	DeleteMany []ProductScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []ProductUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type ProductUpdateWithWhereUniqueWithoutSubCategoryInput struct {
	Where ProductWhereUniqueInput                  `json:"where"`
	Data  ProductUpdateWithoutSubCategoryDataInput `json:"data"`
}

type ProductUpdateWithoutSubCategoryDataInput struct {
	Name       *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc       *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price      *int32                                                `json:"price,omitempty"`
	Capacity   *string                                               `json:"capacity,omitempty"`
	Category   *ProductCategoryUpdateOneInput                        `json:"category,omitempty"`
	Image      *string                                               `json:"image,omitempty"`
	Attributes *ProductServiceAttributeUpdateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch     *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company    *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Reviews    *ReviewUpdateManyWithoutProductInput                  `json:"reviews,omitempty"`
	Deleted    *bool                                                 `json:"deleted,omitempty"`
	Active     *bool                                                 `json:"active,omitempty"`
}

type ProductServiceAttributeUpdateManyWithoutProductInput struct {
	Create     []ProductServiceAttributeCreateWithoutProductInput                `json:"create,omitempty"`
	Delete     []ProductServiceAttributeWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []ProductServiceAttributeWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []ProductServiceAttributeWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []ProductServiceAttributeWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []ProductServiceAttributeUpdateWithWhereUniqueWithoutProductInput `json:"update,omitempty"`
	Upsert     []ProductServiceAttributeUpsertWithWhereUniqueWithoutProductInput `json:"upsert,omitempty"`
	DeleteMany []ProductServiceAttributeScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []ProductServiceAttributeUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type ProductServiceAttributeUpdateWithWhereUniqueWithoutProductInput struct {
	Where ProductServiceAttributeWhereUniqueInput              `json:"where"`
	Data  ProductServiceAttributeUpdateWithoutProductDataInput `json:"data"`
}

type ProductServiceAttributeUpdateWithoutProductDataInput struct {
	Service *ServiceUpdateOneWithoutAttributesInput `json:"service,omitempty"`
	Key     *string                                 `json:"key,omitempty"`
	Name    *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	Value   *LocalizedStringUpdateOneRequiredInput  `json:"value,omitempty"`
	Company *CompanyUpdateOneInput                  `json:"company,omitempty"`
}

type ServiceUpdateOneWithoutAttributesInput struct {
	Create     *ServiceCreateWithoutAttributesInput     `json:"create,omitempty"`
	Update     *ServiceUpdateWithoutAttributesDataInput `json:"update,omitempty"`
	Upsert     *ServiceUpsertWithoutAttributesInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *ServiceWhereUniqueInput                 `json:"connect,omitempty"`
}

type ServiceUpdateWithoutAttributesDataInput struct {
	Name         *LocalizedStringUpdateOneRequiredInput           `json:"name,omitempty"`
	Desc         *LocalizedStringUpdateOneRequiredInput           `json:"desc,omitempty"`
	Price        *int32                                           `json:"price,omitempty"`
	Duration     *int32                                           `json:"duration,omitempty"`
	Image        *string                                          `json:"image,omitempty"`
	GenderTarget *GenderTarget                                    `json:"genderTarget,omitempty"`
	Category     *ServiceCategoryUpdateOneInput                   `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryUpdateOneWithoutServicesInput `json:"subCategory,omitempty"`
	Branch       *BranchUpdateOneRequiredInput                    `json:"branch,omitempty"`
	Company      *CompanyUpdateOneInput                           `json:"company,omitempty"`
	Reviews      *ReviewUpdateManyWithoutServiceInput             `json:"reviews,omitempty"`
	Deleted      *bool                                            `json:"deleted,omitempty"`
	Active       *bool                                            `json:"active,omitempty"`
}

type ServiceCategoryUpdateOneInput struct {
	Create     *ServiceCategoryCreateInput       `json:"create,omitempty"`
	Update     *ServiceCategoryUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ServiceCategoryUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *ServiceCategoryWhereUniqueInput  `json:"connect,omitempty"`
}

type ServiceCategoryUpdateDataInput struct {
	Name          *string                                           `json:"name,omitempty"`
	SubCategories *ServiceSubCategoryUpdateManyWithoutCategoryInput `json:"subCategories,omitempty"`
	Company       *CompanyUpdateOneInput                            `json:"company,omitempty"`
}

type ServiceSubCategoryUpdateManyWithoutCategoryInput struct {
	Create     []ServiceSubCategoryCreateWithoutCategoryInput                `json:"create,omitempty"`
	Delete     []ServiceSubCategoryWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []ServiceSubCategoryWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []ServiceSubCategoryWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []ServiceSubCategoryWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []ServiceSubCategoryUpdateWithWhereUniqueWithoutCategoryInput `json:"update,omitempty"`
	Upsert     []ServiceSubCategoryUpsertWithWhereUniqueWithoutCategoryInput `json:"upsert,omitempty"`
	DeleteMany []ServiceSubCategoryScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []ServiceSubCategoryUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type ServiceSubCategoryUpdateWithWhereUniqueWithoutCategoryInput struct {
	Where ServiceSubCategoryWhereUniqueInput               `json:"where"`
	Data  ServiceSubCategoryUpdateWithoutCategoryDataInput `json:"data"`
}

type ServiceSubCategoryUpdateWithoutCategoryDataInput struct {
	Name     *string                                   `json:"name,omitempty"`
	Company  *CompanyUpdateOneInput                    `json:"company,omitempty"`
	Services *ServiceUpdateManyWithoutSubCategoryInput `json:"services,omitempty"`
}

type CompanyUpdateOneInput struct {
	Create     *CompanyCreateInput       `json:"create,omitempty"`
	Update     *CompanyUpdateDataInput   `json:"update,omitempty"`
	Upsert     *CompanyUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                     `json:"delete,omitempty"`
	Disconnect *bool                     `json:"disconnect,omitempty"`
	Connect    *CompanyWhereUniqueInput  `json:"connect,omitempty"`
}

type CompanyUpdateDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	CustomUrls         *CustomUrlUpdateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasUpdateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       *LocalizedStringUpdateOneRequiredInput  `json:"pwaShortName,omitempty"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string                                 `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string                                 `json:"pwaBackgroundColor,omitempty"`
	Users              *UserUpdateManyWithoutCompanyInput      `json:"users,omitempty"`
	Branches           *BranchUpdateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type AliasUpdateManyWithoutCompanyInput struct {
	Create     []AliasCreateWithoutCompanyInput                `json:"create,omitempty"`
	Delete     []AliasWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []AliasWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []AliasWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []AliasWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []AliasUpdateWithWhereUniqueWithoutCompanyInput `json:"update,omitempty"`
	Upsert     []AliasUpsertWithWhereUniqueWithoutCompanyInput `json:"upsert,omitempty"`
	DeleteMany []AliasScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []AliasUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type AliasUpdateWithWhereUniqueWithoutCompanyInput struct {
	Where AliasWhereUniqueInput              `json:"where"`
	Data  AliasUpdateWithoutCompanyDataInput `json:"data"`
}

type AliasUpdateWithoutCompanyDataInput struct {
	Value *string `json:"value,omitempty"`
}

type AliasUpsertWithWhereUniqueWithoutCompanyInput struct {
	Where  AliasWhereUniqueInput              `json:"where"`
	Update AliasUpdateWithoutCompanyDataInput `json:"update"`
	Create AliasCreateWithoutCompanyInput     `json:"create"`
}

type AliasScalarWhereInput struct {
	ID                 *string                 `json:"id,omitempty"`
	IDNot              *string                 `json:"id_not,omitempty"`
	IDIn               []string                `json:"id_in,omitempty"`
	IDNotIn            []string                `json:"id_not_in,omitempty"`
	IDLt               *string                 `json:"id_lt,omitempty"`
	IDLte              *string                 `json:"id_lte,omitempty"`
	IDGt               *string                 `json:"id_gt,omitempty"`
	IDGte              *string                 `json:"id_gte,omitempty"`
	IDContains         *string                 `json:"id_contains,omitempty"`
	IDNotContains      *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                 `json:"id_not_ends_with,omitempty"`
	Value              *string                 `json:"value,omitempty"`
	ValueNot           *string                 `json:"value_not,omitempty"`
	ValueIn            []string                `json:"value_in,omitempty"`
	ValueNotIn         []string                `json:"value_not_in,omitempty"`
	ValueLt            *string                 `json:"value_lt,omitempty"`
	ValueLte           *string                 `json:"value_lte,omitempty"`
	ValueGt            *string                 `json:"value_gt,omitempty"`
	ValueGte           *string                 `json:"value_gte,omitempty"`
	ValueContains      *string                 `json:"value_contains,omitempty"`
	ValueNotContains   *string                 `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string                 `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string                 `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string                 `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string                 `json:"value_not_ends_with,omitempty"`
	And                []AliasScalarWhereInput `json:"AND,omitempty"`
	Or                 []AliasScalarWhereInput `json:"OR,omitempty"`
	Not                []AliasScalarWhereInput `json:"NOT,omitempty"`
}

type AliasUpdateManyWithWhereNestedInput struct {
	Where AliasScalarWhereInput    `json:"where"`
	Data  AliasUpdateManyDataInput `json:"data"`
}

type AliasUpdateManyDataInput struct {
	Value *string `json:"value,omitempty"`
}

type BranchUpdateManyWithoutCompanyInput struct {
	Create     []BranchCreateWithoutCompanyInput                `json:"create,omitempty"`
	Delete     []BranchWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []BranchWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []BranchWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []BranchWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []BranchUpdateWithWhereUniqueWithoutCompanyInput `json:"update,omitempty"`
	Upsert     []BranchUpsertWithWhereUniqueWithoutCompanyInput `json:"upsert,omitempty"`
	DeleteMany []BranchScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []BranchUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type BranchUpdateWithWhereUniqueWithoutCompanyInput struct {
	Where BranchWhereUniqueInput              `json:"where"`
	Data  BranchUpdateWithoutCompanyDataInput `json:"data"`
}

type BranchUpdateWithoutCompanyDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput         `json:"name,omitempty"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput         `json:"welcomeMessage,omitempty"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         *string                                        `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                        `json:"imprint,omitempty"`
	Employees          *UserUpdateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourUpdateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsUpdateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotUpdateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchUpdateimagesInput struct {
	Set []string `json:"set,omitempty"`
}

type UserUpdateManyWithoutBranchInput struct {
	Create     []UserCreateWithoutBranchInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutBranchInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutBranchInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutBranchInput struct {
	Where UserWhereUniqueInput             `json:"where"`
	Data  UserUpdateWithoutBranchDataInput `json:"data"`
}

type UserUpdateWithoutBranchDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type CompanyUpdateOneWithoutUsersInput struct {
	Create     *CompanyCreateWithoutUsersInput     `json:"create,omitempty"`
	Update     *CompanyUpdateWithoutUsersDataInput `json:"update,omitempty"`
	Upsert     *CompanyUpsertWithoutUsersInput     `json:"upsert,omitempty"`
	Delete     *bool                               `json:"delete,omitempty"`
	Disconnect *bool                               `json:"disconnect,omitempty"`
	Connect    *CompanyWhereUniqueInput            `json:"connect,omitempty"`
}

type CompanyUpdateWithoutUsersDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	CustomUrls         *CustomUrlUpdateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasUpdateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       *LocalizedStringUpdateOneRequiredInput  `json:"pwaShortName,omitempty"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string                                 `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string                                 `json:"pwaBackgroundColor,omitempty"`
	Branches           *BranchUpdateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type CompanyUpsertWithoutUsersInput struct {
	Update CompanyUpdateWithoutUsersDataInput `json:"update"`
	Create CompanyCreateWithoutUsersInput     `json:"create"`
}

type WorkingHoursUpdateManyWithoutUserInput struct {
	Create     []WorkingHoursCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []WorkingHoursWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []WorkingHoursWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []WorkingHoursWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []WorkingHoursWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []WorkingHoursUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []WorkingHoursUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []WorkingHoursScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []WorkingHoursUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type WorkingHoursUpdateWithWhereUniqueWithoutUserInput struct {
	Where WorkingHoursWhereUniqueInput           `json:"where"`
	Data  WorkingHoursUpdateWithoutUserDataInput `json:"data"`
}

type WorkingHoursUpdateWithoutUserDataInput struct {
	Day            *DayOfWeek             `json:"day,omitempty"`
	NotWorking     *bool                  `json:"notWorking,omitempty"`
	Break          *bool                  `json:"break,omitempty"`
	StartForenoon  *string                `json:"startForenoon,omitempty"`
	EndForenoon    *string                `json:"endForenoon,omitempty"`
	StartAfternoon *string                `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                `json:"endAfternoon,omitempty"`
	Company        *CompanyUpdateOneInput `json:"company,omitempty"`
	Status         *AvailabilityStatus    `json:"status,omitempty"`
}

type WorkingHoursUpsertWithWhereUniqueWithoutUserInput struct {
	Where  WorkingHoursWhereUniqueInput           `json:"where"`
	Update WorkingHoursUpdateWithoutUserDataInput `json:"update"`
	Create WorkingHoursCreateWithoutUserInput     `json:"create"`
}

type WorkingHoursScalarWhereInput struct {
	ID                  *string                        `json:"id,omitempty"`
	IDNot               *string                        `json:"id_not,omitempty"`
	IDIn                []string                       `json:"id_in,omitempty"`
	IDNotIn             []string                       `json:"id_not_in,omitempty"`
	IDLt                *string                        `json:"id_lt,omitempty"`
	IDLte               *string                        `json:"id_lte,omitempty"`
	IDGt                *string                        `json:"id_gt,omitempty"`
	IDGte               *string                        `json:"id_gte,omitempty"`
	IDContains          *string                        `json:"id_contains,omitempty"`
	IDNotContains       *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt           *string                        `json:"createdAt,omitempty"`
	CreatedAtNot        *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                        `json:"updatedAt_gte,omitempty"`
	Day                 *DayOfWeek                     `json:"day,omitempty"`
	DayNot              *DayOfWeek                     `json:"day_not,omitempty"`
	DayIn               []DayOfWeek                    `json:"day_in,omitempty"`
	DayNotIn            []DayOfWeek                    `json:"day_not_in,omitempty"`
	NotWorking          *bool                          `json:"notWorking,omitempty"`
	NotWorkingNot       *bool                          `json:"notWorking_not,omitempty"`
	Break               *bool                          `json:"break,omitempty"`
	BreakNot            *bool                          `json:"break_not,omitempty"`
	StartForenoon       *string                        `json:"startForenoon,omitempty"`
	StartForenoonNot    *string                        `json:"startForenoon_not,omitempty"`
	StartForenoonIn     []string                       `json:"startForenoon_in,omitempty"`
	StartForenoonNotIn  []string                       `json:"startForenoon_not_in,omitempty"`
	StartForenoonLt     *string                        `json:"startForenoon_lt,omitempty"`
	StartForenoonLte    *string                        `json:"startForenoon_lte,omitempty"`
	StartForenoonGt     *string                        `json:"startForenoon_gt,omitempty"`
	StartForenoonGte    *string                        `json:"startForenoon_gte,omitempty"`
	EndForenoon         *string                        `json:"endForenoon,omitempty"`
	EndForenoonNot      *string                        `json:"endForenoon_not,omitempty"`
	EndForenoonIn       []string                       `json:"endForenoon_in,omitempty"`
	EndForenoonNotIn    []string                       `json:"endForenoon_not_in,omitempty"`
	EndForenoonLt       *string                        `json:"endForenoon_lt,omitempty"`
	EndForenoonLte      *string                        `json:"endForenoon_lte,omitempty"`
	EndForenoonGt       *string                        `json:"endForenoon_gt,omitempty"`
	EndForenoonGte      *string                        `json:"endForenoon_gte,omitempty"`
	StartAfternoon      *string                        `json:"startAfternoon,omitempty"`
	StartAfternoonNot   *string                        `json:"startAfternoon_not,omitempty"`
	StartAfternoonIn    []string                       `json:"startAfternoon_in,omitempty"`
	StartAfternoonNotIn []string                       `json:"startAfternoon_not_in,omitempty"`
	StartAfternoonLt    *string                        `json:"startAfternoon_lt,omitempty"`
	StartAfternoonLte   *string                        `json:"startAfternoon_lte,omitempty"`
	StartAfternoonGt    *string                        `json:"startAfternoon_gt,omitempty"`
	StartAfternoonGte   *string                        `json:"startAfternoon_gte,omitempty"`
	EndAfternoon        *string                        `json:"endAfternoon,omitempty"`
	EndAfternoonNot     *string                        `json:"endAfternoon_not,omitempty"`
	EndAfternoonIn      []string                       `json:"endAfternoon_in,omitempty"`
	EndAfternoonNotIn   []string                       `json:"endAfternoon_not_in,omitempty"`
	EndAfternoonLt      *string                        `json:"endAfternoon_lt,omitempty"`
	EndAfternoonLte     *string                        `json:"endAfternoon_lte,omitempty"`
	EndAfternoonGt      *string                        `json:"endAfternoon_gt,omitempty"`
	EndAfternoonGte     *string                        `json:"endAfternoon_gte,omitempty"`
	Status              *AvailabilityStatus            `json:"status,omitempty"`
	StatusNot           *AvailabilityStatus            `json:"status_not,omitempty"`
	StatusIn            []AvailabilityStatus           `json:"status_in,omitempty"`
	StatusNotIn         []AvailabilityStatus           `json:"status_not_in,omitempty"`
	And                 []WorkingHoursScalarWhereInput `json:"AND,omitempty"`
	Or                  []WorkingHoursScalarWhereInput `json:"OR,omitempty"`
	Not                 []WorkingHoursScalarWhereInput `json:"NOT,omitempty"`
}

type WorkingHoursUpdateManyWithWhereNestedInput struct {
	Where WorkingHoursScalarWhereInput    `json:"where"`
	Data  WorkingHoursUpdateManyDataInput `json:"data"`
}

type WorkingHoursUpdateManyDataInput struct {
	Day            *DayOfWeek          `json:"day,omitempty"`
	NotWorking     *bool               `json:"notWorking,omitempty"`
	Break          *bool               `json:"break,omitempty"`
	StartForenoon  *string             `json:"startForenoon,omitempty"`
	EndForenoon    *string             `json:"endForenoon,omitempty"`
	StartAfternoon *string             `json:"startAfternoon,omitempty"`
	EndAfternoon   *string             `json:"endAfternoon,omitempty"`
	Status         *AvailabilityStatus `json:"status,omitempty"`
}

type SessionUpdateManyWithoutUserInput struct {
	Create     []SessionCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []SessionWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []SessionWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []SessionWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []SessionWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []SessionUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []SessionUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []SessionScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []SessionUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type SessionUpdateWithWhereUniqueWithoutUserInput struct {
	Where SessionWhereUniqueInput           `json:"where"`
	Data  SessionUpdateWithoutUserDataInput `json:"data"`
}

type SessionUpdateWithoutUserDataInput struct {
	Token   *string                `json:"token,omitempty"`
	Company *CompanyUpdateOneInput `json:"company,omitempty"`
}

type SessionUpsertWithWhereUniqueWithoutUserInput struct {
	Where  SessionWhereUniqueInput           `json:"where"`
	Update SessionUpdateWithoutUserDataInput `json:"update"`
	Create SessionCreateWithoutUserInput     `json:"create"`
}

type SessionScalarWhereInput struct {
	ID                 *string                   `json:"id,omitempty"`
	IDNot              *string                   `json:"id_not,omitempty"`
	IDIn               []string                  `json:"id_in,omitempty"`
	IDNotIn            []string                  `json:"id_not_in,omitempty"`
	IDLt               *string                   `json:"id_lt,omitempty"`
	IDLte              *string                   `json:"id_lte,omitempty"`
	IDGt               *string                   `json:"id_gt,omitempty"`
	IDGte              *string                   `json:"id_gte,omitempty"`
	IDContains         *string                   `json:"id_contains,omitempty"`
	IDNotContains      *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                   `json:"createdAt,omitempty"`
	CreatedAtNot       *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                   `json:"updatedAt_gte,omitempty"`
	Token              *string                   `json:"token,omitempty"`
	TokenNot           *string                   `json:"token_not,omitempty"`
	TokenIn            []string                  `json:"token_in,omitempty"`
	TokenNotIn         []string                  `json:"token_not_in,omitempty"`
	TokenLt            *string                   `json:"token_lt,omitempty"`
	TokenLte           *string                   `json:"token_lte,omitempty"`
	TokenGt            *string                   `json:"token_gt,omitempty"`
	TokenGte           *string                   `json:"token_gte,omitempty"`
	TokenContains      *string                   `json:"token_contains,omitempty"`
	TokenNotContains   *string                   `json:"token_not_contains,omitempty"`
	TokenStartsWith    *string                   `json:"token_starts_with,omitempty"`
	TokenNotStartsWith *string                   `json:"token_not_starts_with,omitempty"`
	TokenEndsWith      *string                   `json:"token_ends_with,omitempty"`
	TokenNotEndsWith   *string                   `json:"token_not_ends_with,omitempty"`
	And                []SessionScalarWhereInput `json:"AND,omitempty"`
	Or                 []SessionScalarWhereInput `json:"OR,omitempty"`
	Not                []SessionScalarWhereInput `json:"NOT,omitempty"`
}

type SessionUpdateManyWithWhereNestedInput struct {
	Where SessionScalarWhereInput    `json:"where"`
	Data  SessionUpdateManyDataInput `json:"data"`
}

type SessionUpdateManyDataInput struct {
	Token *string `json:"token,omitempty"`
}

type PasswordTokenUpdateOneWithoutUserInput struct {
	Create     *PasswordTokenCreateWithoutUserInput     `json:"create,omitempty"`
	Update     *PasswordTokenUpdateWithoutUserDataInput `json:"update,omitempty"`
	Upsert     *PasswordTokenUpsertWithoutUserInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *PasswordTokenWhereUniqueInput           `json:"connect,omitempty"`
}

type PasswordTokenUpdateWithoutUserDataInput struct {
	Token *string `json:"token,omitempty"`
}

type PasswordTokenUpsertWithoutUserInput struct {
	Update PasswordTokenUpdateWithoutUserDataInput `json:"update"`
	Create PasswordTokenCreateWithoutUserInput     `json:"create"`
}

type UserUpsertWithWhereUniqueWithoutBranchInput struct {
	Where  UserWhereUniqueInput             `json:"where"`
	Update UserUpdateWithoutBranchDataInput `json:"update"`
	Create UserCreateWithoutBranchInput     `json:"create"`
}

type UserScalarWhereInput struct {
	ID                             *string                `json:"id,omitempty"`
	IDNot                          *string                `json:"id_not,omitempty"`
	IDIn                           []string               `json:"id_in,omitempty"`
	IDNotIn                        []string               `json:"id_not_in,omitempty"`
	IDLt                           *string                `json:"id_lt,omitempty"`
	IDLte                          *string                `json:"id_lte,omitempty"`
	IDGt                           *string                `json:"id_gt,omitempty"`
	IDGte                          *string                `json:"id_gte,omitempty"`
	IDContains                     *string                `json:"id_contains,omitempty"`
	IDNotContains                  *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                      *string                `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                `json:"updatedAt_gte,omitempty"`
	Type                           *UserType              `json:"type,omitempty"`
	TypeNot                        *UserType              `json:"type_not,omitempty"`
	TypeIn                         []UserType             `json:"type_in,omitempty"`
	TypeNotIn                      []UserType             `json:"type_not_in,omitempty"`
	Email                          *string                `json:"email,omitempty"`
	EmailNot                       *string                `json:"email_not,omitempty"`
	EmailIn                        []string               `json:"email_in,omitempty"`
	EmailNotIn                     []string               `json:"email_not_in,omitempty"`
	EmailLt                        *string                `json:"email_lt,omitempty"`
	EmailLte                       *string                `json:"email_lte,omitempty"`
	EmailGt                        *string                `json:"email_gt,omitempty"`
	EmailGte                       *string                `json:"email_gte,omitempty"`
	EmailContains                  *string                `json:"email_contains,omitempty"`
	EmailNotContains               *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith                *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith             *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith                  *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith               *string                `json:"email_not_ends_with,omitempty"`
	PasswordHash                   *string                `json:"passwordHash,omitempty"`
	PasswordHashNot                *string                `json:"passwordHash_not,omitempty"`
	PasswordHashIn                 []string               `json:"passwordHash_in,omitempty"`
	PasswordHashNotIn              []string               `json:"passwordHash_not_in,omitempty"`
	PasswordHashLt                 *string                `json:"passwordHash_lt,omitempty"`
	PasswordHashLte                *string                `json:"passwordHash_lte,omitempty"`
	PasswordHashGt                 *string                `json:"passwordHash_gt,omitempty"`
	PasswordHashGte                *string                `json:"passwordHash_gte,omitempty"`
	PasswordHashContains           *string                `json:"passwordHash_contains,omitempty"`
	PasswordHashNotContains        *string                `json:"passwordHash_not_contains,omitempty"`
	PasswordHashStartsWith         *string                `json:"passwordHash_starts_with,omitempty"`
	PasswordHashNotStartsWith      *string                `json:"passwordHash_not_starts_with,omitempty"`
	PasswordHashEndsWith           *string                `json:"passwordHash_ends_with,omitempty"`
	PasswordHashNotEndsWith        *string                `json:"passwordHash_not_ends_with,omitempty"`
	FirstName                      *string                `json:"firstName,omitempty"`
	FirstNameNot                   *string                `json:"firstName_not,omitempty"`
	FirstNameIn                    []string               `json:"firstName_in,omitempty"`
	FirstNameNotIn                 []string               `json:"firstName_not_in,omitempty"`
	FirstNameLt                    *string                `json:"firstName_lt,omitempty"`
	FirstNameLte                   *string                `json:"firstName_lte,omitempty"`
	FirstNameGt                    *string                `json:"firstName_gt,omitempty"`
	FirstNameGte                   *string                `json:"firstName_gte,omitempty"`
	FirstNameContains              *string                `json:"firstName_contains,omitempty"`
	FirstNameNotContains           *string                `json:"firstName_not_contains,omitempty"`
	FirstNameStartsWith            *string                `json:"firstName_starts_with,omitempty"`
	FirstNameNotStartsWith         *string                `json:"firstName_not_starts_with,omitempty"`
	FirstNameEndsWith              *string                `json:"firstName_ends_with,omitempty"`
	FirstNameNotEndsWith           *string                `json:"firstName_not_ends_with,omitempty"`
	LastName                       *string                `json:"lastName,omitempty"`
	LastNameNot                    *string                `json:"lastName_not,omitempty"`
	LastNameIn                     []string               `json:"lastName_in,omitempty"`
	LastNameNotIn                  []string               `json:"lastName_not_in,omitempty"`
	LastNameLt                     *string                `json:"lastName_lt,omitempty"`
	LastNameLte                    *string                `json:"lastName_lte,omitempty"`
	LastNameGt                     *string                `json:"lastName_gt,omitempty"`
	LastNameGte                    *string                `json:"lastName_gte,omitempty"`
	LastNameContains               *string                `json:"lastName_contains,omitempty"`
	LastNameNotContains            *string                `json:"lastName_not_contains,omitempty"`
	LastNameStartsWith             *string                `json:"lastName_starts_with,omitempty"`
	LastNameNotStartsWith          *string                `json:"lastName_not_starts_with,omitempty"`
	LastNameEndsWith               *string                `json:"lastName_ends_with,omitempty"`
	LastNameNotEndsWith            *string                `json:"lastName_not_ends_with,omitempty"`
	Gender                         *Gender                `json:"gender,omitempty"`
	GenderNot                      *Gender                `json:"gender_not,omitempty"`
	GenderIn                       []Gender               `json:"gender_in,omitempty"`
	GenderNotIn                    []Gender               `json:"gender_not_in,omitempty"`
	ZipCode                        *string                `json:"zipCode,omitempty"`
	ZipCodeNot                     *string                `json:"zipCode_not,omitempty"`
	ZipCodeIn                      []string               `json:"zipCode_in,omitempty"`
	ZipCodeNotIn                   []string               `json:"zipCode_not_in,omitempty"`
	ZipCodeLt                      *string                `json:"zipCode_lt,omitempty"`
	ZipCodeLte                     *string                `json:"zipCode_lte,omitempty"`
	ZipCodeGt                      *string                `json:"zipCode_gt,omitempty"`
	ZipCodeGte                     *string                `json:"zipCode_gte,omitempty"`
	ZipCodeContains                *string                `json:"zipCode_contains,omitempty"`
	ZipCodeNotContains             *string                `json:"zipCode_not_contains,omitempty"`
	ZipCodeStartsWith              *string                `json:"zipCode_starts_with,omitempty"`
	ZipCodeNotStartsWith           *string                `json:"zipCode_not_starts_with,omitempty"`
	ZipCodeEndsWith                *string                `json:"zipCode_ends_with,omitempty"`
	ZipCodeNotEndsWith             *string                `json:"zipCode_not_ends_with,omitempty"`
	Street                         *string                `json:"street,omitempty"`
	StreetNot                      *string                `json:"street_not,omitempty"`
	StreetIn                       []string               `json:"street_in,omitempty"`
	StreetNotIn                    []string               `json:"street_not_in,omitempty"`
	StreetLt                       *string                `json:"street_lt,omitempty"`
	StreetLte                      *string                `json:"street_lte,omitempty"`
	StreetGt                       *string                `json:"street_gt,omitempty"`
	StreetGte                      *string                `json:"street_gte,omitempty"`
	StreetContains                 *string                `json:"street_contains,omitempty"`
	StreetNotContains              *string                `json:"street_not_contains,omitempty"`
	StreetStartsWith               *string                `json:"street_starts_with,omitempty"`
	StreetNotStartsWith            *string                `json:"street_not_starts_with,omitempty"`
	StreetEndsWith                 *string                `json:"street_ends_with,omitempty"`
	StreetNotEndsWith              *string                `json:"street_not_ends_with,omitempty"`
	City                           *string                `json:"city,omitempty"`
	CityNot                        *string                `json:"city_not,omitempty"`
	CityIn                         []string               `json:"city_in,omitempty"`
	CityNotIn                      []string               `json:"city_not_in,omitempty"`
	CityLt                         *string                `json:"city_lt,omitempty"`
	CityLte                        *string                `json:"city_lte,omitempty"`
	CityGt                         *string                `json:"city_gt,omitempty"`
	CityGte                        *string                `json:"city_gte,omitempty"`
	CityContains                   *string                `json:"city_contains,omitempty"`
	CityNotContains                *string                `json:"city_not_contains,omitempty"`
	CityStartsWith                 *string                `json:"city_starts_with,omitempty"`
	CityNotStartsWith              *string                `json:"city_not_starts_with,omitempty"`
	CityEndsWith                   *string                `json:"city_ends_with,omitempty"`
	CityNotEndsWith                *string                `json:"city_not_ends_with,omitempty"`
	Birthday                       *string                `json:"birthday,omitempty"`
	BirthdayNot                    *string                `json:"birthday_not,omitempty"`
	BirthdayIn                     []string               `json:"birthday_in,omitempty"`
	BirthdayNotIn                  []string               `json:"birthday_not_in,omitempty"`
	BirthdayLt                     *string                `json:"birthday_lt,omitempty"`
	BirthdayLte                    *string                `json:"birthday_lte,omitempty"`
	BirthdayGt                     *string                `json:"birthday_gt,omitempty"`
	BirthdayGte                    *string                `json:"birthday_gte,omitempty"`
	Birthdate                      *string                `json:"birthdate,omitempty"`
	BirthdateNot                   *string                `json:"birthdate_not,omitempty"`
	BirthdateIn                    []string               `json:"birthdate_in,omitempty"`
	BirthdateNotIn                 []string               `json:"birthdate_not_in,omitempty"`
	BirthdateLt                    *string                `json:"birthdate_lt,omitempty"`
	BirthdateLte                   *string                `json:"birthdate_lte,omitempty"`
	BirthdateGt                    *string                `json:"birthdate_gt,omitempty"`
	BirthdateGte                   *string                `json:"birthdate_gte,omitempty"`
	BirthdateContains              *string                `json:"birthdate_contains,omitempty"`
	BirthdateNotContains           *string                `json:"birthdate_not_contains,omitempty"`
	BirthdateStartsWith            *string                `json:"birthdate_starts_with,omitempty"`
	BirthdateNotStartsWith         *string                `json:"birthdate_not_starts_with,omitempty"`
	BirthdateEndsWith              *string                `json:"birthdate_ends_with,omitempty"`
	BirthdateNotEndsWith           *string                `json:"birthdate_not_ends_with,omitempty"`
	PhoneNumber                    *string                `json:"phoneNumber,omitempty"`
	PhoneNumberNot                 *string                `json:"phoneNumber_not,omitempty"`
	PhoneNumberIn                  []string               `json:"phoneNumber_in,omitempty"`
	PhoneNumberNotIn               []string               `json:"phoneNumber_not_in,omitempty"`
	PhoneNumberLt                  *string                `json:"phoneNumber_lt,omitempty"`
	PhoneNumberLte                 *string                `json:"phoneNumber_lte,omitempty"`
	PhoneNumberGt                  *string                `json:"phoneNumber_gt,omitempty"`
	PhoneNumberGte                 *string                `json:"phoneNumber_gte,omitempty"`
	PhoneNumberContains            *string                `json:"phoneNumber_contains,omitempty"`
	PhoneNumberNotContains         *string                `json:"phoneNumber_not_contains,omitempty"`
	PhoneNumberStartsWith          *string                `json:"phoneNumber_starts_with,omitempty"`
	PhoneNumberNotStartsWith       *string                `json:"phoneNumber_not_starts_with,omitempty"`
	PhoneNumberEndsWith            *string                `json:"phoneNumber_ends_with,omitempty"`
	PhoneNumberNotEndsWith         *string                `json:"phoneNumber_not_ends_with,omitempty"`
	Image                          *string                `json:"image,omitempty"`
	ImageNot                       *string                `json:"image_not,omitempty"`
	ImageIn                        []string               `json:"image_in,omitempty"`
	ImageNotIn                     []string               `json:"image_not_in,omitempty"`
	ImageLt                        *string                `json:"image_lt,omitempty"`
	ImageLte                       *string                `json:"image_lte,omitempty"`
	ImageGt                        *string                `json:"image_gt,omitempty"`
	ImageGte                       *string                `json:"image_gte,omitempty"`
	ImageContains                  *string                `json:"image_contains,omitempty"`
	ImageNotContains               *string                `json:"image_not_contains,omitempty"`
	ImageStartsWith                *string                `json:"image_starts_with,omitempty"`
	ImageNotStartsWith             *string                `json:"image_not_starts_with,omitempty"`
	ImageEndsWith                  *string                `json:"image_ends_with,omitempty"`
	ImageNotEndsWith               *string                `json:"image_not_ends_with,omitempty"`
	Note                           *string                `json:"note,omitempty"`
	NoteNot                        *string                `json:"note_not,omitempty"`
	NoteIn                         []string               `json:"note_in,omitempty"`
	NoteNotIn                      []string               `json:"note_not_in,omitempty"`
	NoteLt                         *string                `json:"note_lt,omitempty"`
	NoteLte                        *string                `json:"note_lte,omitempty"`
	NoteGt                         *string                `json:"note_gt,omitempty"`
	NoteGte                        *string                `json:"note_gte,omitempty"`
	NoteContains                   *string                `json:"note_contains,omitempty"`
	NoteNotContains                *string                `json:"note_not_contains,omitempty"`
	NoteStartsWith                 *string                `json:"note_starts_with,omitempty"`
	NoteNotStartsWith              *string                `json:"note_not_starts_with,omitempty"`
	NoteEndsWith                   *string                `json:"note_ends_with,omitempty"`
	NoteNotEndsWith                *string                `json:"note_not_ends_with,omitempty"`
	AllowReviewSharing             *bool                  `json:"allowReviewSharing,omitempty"`
	AllowReviewSharingNot          *bool                  `json:"allowReviewSharing_not,omitempty"`
	NotificationToken              *string                `json:"notificationToken,omitempty"`
	NotificationTokenNot           *string                `json:"notificationToken_not,omitempty"`
	NotificationTokenIn            []string               `json:"notificationToken_in,omitempty"`
	NotificationTokenNotIn         []string               `json:"notificationToken_not_in,omitempty"`
	NotificationTokenLt            *string                `json:"notificationToken_lt,omitempty"`
	NotificationTokenLte           *string                `json:"notificationToken_lte,omitempty"`
	NotificationTokenGt            *string                `json:"notificationToken_gt,omitempty"`
	NotificationTokenGte           *string                `json:"notificationToken_gte,omitempty"`
	NotificationTokenContains      *string                `json:"notificationToken_contains,omitempty"`
	NotificationTokenNotContains   *string                `json:"notificationToken_not_contains,omitempty"`
	NotificationTokenStartsWith    *string                `json:"notificationToken_starts_with,omitempty"`
	NotificationTokenNotStartsWith *string                `json:"notificationToken_not_starts_with,omitempty"`
	NotificationTokenEndsWith      *string                `json:"notificationToken_ends_with,omitempty"`
	NotificationTokenNotEndsWith   *string                `json:"notificationToken_not_ends_with,omitempty"`
	Language                       *string                `json:"language,omitempty"`
	LanguageNot                    *string                `json:"language_not,omitempty"`
	LanguageIn                     []string               `json:"language_in,omitempty"`
	LanguageNotIn                  []string               `json:"language_not_in,omitempty"`
	LanguageLt                     *string                `json:"language_lt,omitempty"`
	LanguageLte                    *string                `json:"language_lte,omitempty"`
	LanguageGt                     *string                `json:"language_gt,omitempty"`
	LanguageGte                    *string                `json:"language_gte,omitempty"`
	LanguageContains               *string                `json:"language_contains,omitempty"`
	LanguageNotContains            *string                `json:"language_not_contains,omitempty"`
	LanguageStartsWith             *string                `json:"language_starts_with,omitempty"`
	LanguageNotStartsWith          *string                `json:"language_not_starts_with,omitempty"`
	LanguageEndsWith               *string                `json:"language_ends_with,omitempty"`
	LanguageNotEndsWith            *string                `json:"language_not_ends_with,omitempty"`
	Deleted                        *bool                  `json:"deleted,omitempty"`
	DeletedNot                     *bool                  `json:"deleted_not,omitempty"`
	Activated                      *bool                  `json:"activated,omitempty"`
	ActivatedNot                   *bool                  `json:"activated_not,omitempty"`
	ActivateToken                  *string                `json:"activateToken,omitempty"`
	ActivateTokenNot               *string                `json:"activateToken_not,omitempty"`
	ActivateTokenIn                []string               `json:"activateToken_in,omitempty"`
	ActivateTokenNotIn             []string               `json:"activateToken_not_in,omitempty"`
	ActivateTokenLt                *string                `json:"activateToken_lt,omitempty"`
	ActivateTokenLte               *string                `json:"activateToken_lte,omitempty"`
	ActivateTokenGt                *string                `json:"activateToken_gt,omitempty"`
	ActivateTokenGte               *string                `json:"activateToken_gte,omitempty"`
	ActivateTokenContains          *string                `json:"activateToken_contains,omitempty"`
	ActivateTokenNotContains       *string                `json:"activateToken_not_contains,omitempty"`
	ActivateTokenStartsWith        *string                `json:"activateToken_starts_with,omitempty"`
	ActivateTokenNotStartsWith     *string                `json:"activateToken_not_starts_with,omitempty"`
	ActivateTokenEndsWith          *string                `json:"activateToken_ends_with,omitempty"`
	ActivateTokenNotEndsWith       *string                `json:"activateToken_not_ends_with,omitempty"`
	And                            []UserScalarWhereInput `json:"AND,omitempty"`
	Or                             []UserScalarWhereInput `json:"OR,omitempty"`
	Not                            []UserScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyWithWhereNestedInput struct {
	Where UserScalarWhereInput    `json:"where"`
	Data  UserUpdateManyDataInput `json:"data"`
}

type UserUpdateManyDataInput struct {
	Type               *UserType `json:"type,omitempty"`
	Email              *string   `json:"email,omitempty"`
	PasswordHash       *string   `json:"passwordHash,omitempty"`
	FirstName          *string   `json:"firstName,omitempty"`
	LastName           *string   `json:"lastName,omitempty"`
	Gender             *Gender   `json:"gender,omitempty"`
	ZipCode            *string   `json:"zipCode,omitempty"`
	Street             *string   `json:"street,omitempty"`
	City               *string   `json:"city,omitempty"`
	Birthday           *string   `json:"birthday,omitempty"`
	Birthdate          *string   `json:"birthdate,omitempty"`
	PhoneNumber        *string   `json:"phoneNumber,omitempty"`
	Image              *string   `json:"image,omitempty"`
	Note               *string   `json:"note,omitempty"`
	AllowReviewSharing *bool     `json:"allowReviewSharing,omitempty"`
	NotificationToken  *string   `json:"notificationToken,omitempty"`
	Language           *string   `json:"language,omitempty"`
	Deleted            *bool     `json:"deleted,omitempty"`
	Activated          *bool     `json:"activated,omitempty"`
	ActivateToken      *string   `json:"activateToken,omitempty"`
}

type BranchOpeningHourUpdateManyWithoutBranchInput struct {
	Create     []BranchOpeningHourCreateWithoutBranchInput                `json:"create,omitempty"`
	Delete     []BranchOpeningHourWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []BranchOpeningHourWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []BranchOpeningHourWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []BranchOpeningHourWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []BranchOpeningHourUpdateWithWhereUniqueWithoutBranchInput `json:"update,omitempty"`
	Upsert     []BranchOpeningHourUpsertWithWhereUniqueWithoutBranchInput `json:"upsert,omitempty"`
	DeleteMany []BranchOpeningHourScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []BranchOpeningHourUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type BranchOpeningHourUpdateWithWhereUniqueWithoutBranchInput struct {
	Where BranchOpeningHourWhereUniqueInput             `json:"where"`
	Data  BranchOpeningHourUpdateWithoutBranchDataInput `json:"data"`
}

type BranchOpeningHourUpdateWithoutBranchDataInput struct {
	Company        *CompanyUpdateOneInput `json:"company,omitempty"`
	Day            *DayOfWeek             `json:"day,omitempty"`
	Closed         *bool                  `json:"closed,omitempty"`
	Break          *bool                  `json:"break,omitempty"`
	StartForenoon  *string                `json:"startForenoon,omitempty"`
	EndForenoon    *string                `json:"endForenoon,omitempty"`
	StartAfternoon *string                `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                `json:"endAfternoon,omitempty"`
}

type BranchOpeningHourUpsertWithWhereUniqueWithoutBranchInput struct {
	Where  BranchOpeningHourWhereUniqueInput             `json:"where"`
	Update BranchOpeningHourUpdateWithoutBranchDataInput `json:"update"`
	Create BranchOpeningHourCreateWithoutBranchInput     `json:"create"`
}

type BranchOpeningHourScalarWhereInput struct {
	ID                  *string                             `json:"id,omitempty"`
	IDNot               *string                             `json:"id_not,omitempty"`
	IDIn                []string                            `json:"id_in,omitempty"`
	IDNotIn             []string                            `json:"id_not_in,omitempty"`
	IDLt                *string                             `json:"id_lt,omitempty"`
	IDLte               *string                             `json:"id_lte,omitempty"`
	IDGt                *string                             `json:"id_gt,omitempty"`
	IDGte               *string                             `json:"id_gte,omitempty"`
	IDContains          *string                             `json:"id_contains,omitempty"`
	IDNotContains       *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                             `json:"id_not_ends_with,omitempty"`
	CreatedAt           *string                             `json:"createdAt,omitempty"`
	CreatedAtNot        *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                             `json:"updatedAt_gte,omitempty"`
	Day                 *DayOfWeek                          `json:"day,omitempty"`
	DayNot              *DayOfWeek                          `json:"day_not,omitempty"`
	DayIn               []DayOfWeek                         `json:"day_in,omitempty"`
	DayNotIn            []DayOfWeek                         `json:"day_not_in,omitempty"`
	Closed              *bool                               `json:"closed,omitempty"`
	ClosedNot           *bool                               `json:"closed_not,omitempty"`
	Break               *bool                               `json:"break,omitempty"`
	BreakNot            *bool                               `json:"break_not,omitempty"`
	StartForenoon       *string                             `json:"startForenoon,omitempty"`
	StartForenoonNot    *string                             `json:"startForenoon_not,omitempty"`
	StartForenoonIn     []string                            `json:"startForenoon_in,omitempty"`
	StartForenoonNotIn  []string                            `json:"startForenoon_not_in,omitempty"`
	StartForenoonLt     *string                             `json:"startForenoon_lt,omitempty"`
	StartForenoonLte    *string                             `json:"startForenoon_lte,omitempty"`
	StartForenoonGt     *string                             `json:"startForenoon_gt,omitempty"`
	StartForenoonGte    *string                             `json:"startForenoon_gte,omitempty"`
	EndForenoon         *string                             `json:"endForenoon,omitempty"`
	EndForenoonNot      *string                             `json:"endForenoon_not,omitempty"`
	EndForenoonIn       []string                            `json:"endForenoon_in,omitempty"`
	EndForenoonNotIn    []string                            `json:"endForenoon_not_in,omitempty"`
	EndForenoonLt       *string                             `json:"endForenoon_lt,omitempty"`
	EndForenoonLte      *string                             `json:"endForenoon_lte,omitempty"`
	EndForenoonGt       *string                             `json:"endForenoon_gt,omitempty"`
	EndForenoonGte      *string                             `json:"endForenoon_gte,omitempty"`
	StartAfternoon      *string                             `json:"startAfternoon,omitempty"`
	StartAfternoonNot   *string                             `json:"startAfternoon_not,omitempty"`
	StartAfternoonIn    []string                            `json:"startAfternoon_in,omitempty"`
	StartAfternoonNotIn []string                            `json:"startAfternoon_not_in,omitempty"`
	StartAfternoonLt    *string                             `json:"startAfternoon_lt,omitempty"`
	StartAfternoonLte   *string                             `json:"startAfternoon_lte,omitempty"`
	StartAfternoonGt    *string                             `json:"startAfternoon_gt,omitempty"`
	StartAfternoonGte   *string                             `json:"startAfternoon_gte,omitempty"`
	EndAfternoon        *string                             `json:"endAfternoon,omitempty"`
	EndAfternoonNot     *string                             `json:"endAfternoon_not,omitempty"`
	EndAfternoonIn      []string                            `json:"endAfternoon_in,omitempty"`
	EndAfternoonNotIn   []string                            `json:"endAfternoon_not_in,omitempty"`
	EndAfternoonLt      *string                             `json:"endAfternoon_lt,omitempty"`
	EndAfternoonLte     *string                             `json:"endAfternoon_lte,omitempty"`
	EndAfternoonGt      *string                             `json:"endAfternoon_gt,omitempty"`
	EndAfternoonGte     *string                             `json:"endAfternoon_gte,omitempty"`
	And                 []BranchOpeningHourScalarWhereInput `json:"AND,omitempty"`
	Or                  []BranchOpeningHourScalarWhereInput `json:"OR,omitempty"`
	Not                 []BranchOpeningHourScalarWhereInput `json:"NOT,omitempty"`
}

type BranchOpeningHourUpdateManyWithWhereNestedInput struct {
	Where BranchOpeningHourScalarWhereInput    `json:"where"`
	Data  BranchOpeningHourUpdateManyDataInput `json:"data"`
}

type BranchOpeningHourUpdateManyDataInput struct {
	Day            *DayOfWeek `json:"day,omitempty"`
	Closed         *bool      `json:"closed,omitempty"`
	Break          *bool      `json:"break,omitempty"`
	StartForenoon  *string    `json:"startForenoon,omitempty"`
	EndForenoon    *string    `json:"endForenoon,omitempty"`
	StartAfternoon *string    `json:"startAfternoon,omitempty"`
	EndAfternoon   *string    `json:"endAfternoon,omitempty"`
}

type NewsUpdateManyWithoutBranchInput struct {
	Create     []NewsCreateWithoutBranchInput                `json:"create,omitempty"`
	Delete     []NewsWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []NewsWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []NewsWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []NewsWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []NewsUpdateWithWhereUniqueWithoutBranchInput `json:"update,omitempty"`
	Upsert     []NewsUpsertWithWhereUniqueWithoutBranchInput `json:"upsert,omitempty"`
	DeleteMany []NewsScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []NewsUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type NewsUpdateWithWhereUniqueWithoutBranchInput struct {
	Where NewsWhereUniqueInput             `json:"where"`
	Data  NewsUpdateWithoutBranchDataInput `json:"data"`
}

type NewsUpdateWithoutBranchDataInput struct {
	Title   *LocalizedStringUpdateOneRequiredInput `json:"title,omitempty"`
	Image   *string                                `json:"image,omitempty"`
	Company *CompanyUpdateOneInput                 `json:"company,omitempty"`
}

type NewsUpsertWithWhereUniqueWithoutBranchInput struct {
	Where  NewsWhereUniqueInput             `json:"where"`
	Update NewsUpdateWithoutBranchDataInput `json:"update"`
	Create NewsCreateWithoutBranchInput     `json:"create"`
}

type NewsScalarWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                `json:"createdAt,omitempty"`
	CreatedAtNot       *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                `json:"updatedAt_gte,omitempty"`
	Image              *string                `json:"image,omitempty"`
	ImageNot           *string                `json:"image_not,omitempty"`
	ImageIn            []string               `json:"image_in,omitempty"`
	ImageNotIn         []string               `json:"image_not_in,omitempty"`
	ImageLt            *string                `json:"image_lt,omitempty"`
	ImageLte           *string                `json:"image_lte,omitempty"`
	ImageGt            *string                `json:"image_gt,omitempty"`
	ImageGte           *string                `json:"image_gte,omitempty"`
	ImageContains      *string                `json:"image_contains,omitempty"`
	ImageNotContains   *string                `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                `json:"image_not_ends_with,omitempty"`
	And                []NewsScalarWhereInput `json:"AND,omitempty"`
	Or                 []NewsScalarWhereInput `json:"OR,omitempty"`
	Not                []NewsScalarWhereInput `json:"NOT,omitempty"`
}

type NewsUpdateManyWithWhereNestedInput struct {
	Where NewsScalarWhereInput    `json:"where"`
	Data  NewsUpdateManyDataInput `json:"data"`
}

type NewsUpdateManyDataInput struct {
	Image *string `json:"image,omitempty"`
}

type BranchImageSlotUpdateManyWithoutBranchInput struct {
	Create     []BranchImageSlotCreateWithoutBranchInput                `json:"create,omitempty"`
	Delete     []BranchImageSlotWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []BranchImageSlotWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []BranchImageSlotWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []BranchImageSlotWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []BranchImageSlotUpdateWithWhereUniqueWithoutBranchInput `json:"update,omitempty"`
	Upsert     []BranchImageSlotUpsertWithWhereUniqueWithoutBranchInput `json:"upsert,omitempty"`
	DeleteMany []BranchImageSlotScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []BranchImageSlotUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type BranchImageSlotUpdateWithWhereUniqueWithoutBranchInput struct {
	Where BranchImageSlotWhereUniqueInput             `json:"where"`
	Data  BranchImageSlotUpdateWithoutBranchDataInput `json:"data"`
}

type BranchImageSlotUpdateWithoutBranchDataInput struct {
	SlotNumber *int32                 `json:"slotNumber,omitempty"`
	Company    *CompanyUpdateOneInput `json:"company,omitempty"`
	ImageUrl   *string                `json:"imageUrl,omitempty"`
}

type BranchImageSlotUpsertWithWhereUniqueWithoutBranchInput struct {
	Where  BranchImageSlotWhereUniqueInput             `json:"where"`
	Update BranchImageSlotUpdateWithoutBranchDataInput `json:"update"`
	Create BranchImageSlotCreateWithoutBranchInput     `json:"create"`
}

type BranchImageSlotScalarWhereInput struct {
	ID                    *string                           `json:"id,omitempty"`
	IDNot                 *string                           `json:"id_not,omitempty"`
	IDIn                  []string                          `json:"id_in,omitempty"`
	IDNotIn               []string                          `json:"id_not_in,omitempty"`
	IDLt                  *string                           `json:"id_lt,omitempty"`
	IDLte                 *string                           `json:"id_lte,omitempty"`
	IDGt                  *string                           `json:"id_gt,omitempty"`
	IDGte                 *string                           `json:"id_gte,omitempty"`
	IDContains            *string                           `json:"id_contains,omitempty"`
	IDNotContains         *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                           `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                           `json:"createdAt,omitempty"`
	CreatedAtNot          *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                           `json:"updatedAt_gte,omitempty"`
	SlotNumber            *int32                            `json:"slotNumber,omitempty"`
	SlotNumberNot         *int32                            `json:"slotNumber_not,omitempty"`
	SlotNumberIn          []int32                           `json:"slotNumber_in,omitempty"`
	SlotNumberNotIn       []int32                           `json:"slotNumber_not_in,omitempty"`
	SlotNumberLt          *int32                            `json:"slotNumber_lt,omitempty"`
	SlotNumberLte         *int32                            `json:"slotNumber_lte,omitempty"`
	SlotNumberGt          *int32                            `json:"slotNumber_gt,omitempty"`
	SlotNumberGte         *int32                            `json:"slotNumber_gte,omitempty"`
	ImageUrl              *string                           `json:"imageUrl,omitempty"`
	ImageUrlNot           *string                           `json:"imageUrl_not,omitempty"`
	ImageUrlIn            []string                          `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn         []string                          `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt            *string                           `json:"imageUrl_lt,omitempty"`
	ImageUrlLte           *string                           `json:"imageUrl_lte,omitempty"`
	ImageUrlGt            *string                           `json:"imageUrl_gt,omitempty"`
	ImageUrlGte           *string                           `json:"imageUrl_gte,omitempty"`
	ImageUrlContains      *string                           `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains   *string                           `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith    *string                           `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith *string                           `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith      *string                           `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith   *string                           `json:"imageUrl_not_ends_with,omitempty"`
	And                   []BranchImageSlotScalarWhereInput `json:"AND,omitempty"`
	Or                    []BranchImageSlotScalarWhereInput `json:"OR,omitempty"`
	Not                   []BranchImageSlotScalarWhereInput `json:"NOT,omitempty"`
}

type BranchImageSlotUpdateManyWithWhereNestedInput struct {
	Where BranchImageSlotScalarWhereInput    `json:"where"`
	Data  BranchImageSlotUpdateManyDataInput `json:"data"`
}

type BranchImageSlotUpdateManyDataInput struct {
	SlotNumber *int32  `json:"slotNumber,omitempty"`
	ImageUrl   *string `json:"imageUrl,omitempty"`
}

type BranchUpsertWithWhereUniqueWithoutCompanyInput struct {
	Where  BranchWhereUniqueInput              `json:"where"`
	Update BranchUpdateWithoutCompanyDataInput `json:"update"`
	Create BranchCreateWithoutCompanyInput     `json:"create"`
}

type BranchScalarWhereInput struct {
	ID                              *string                  `json:"id,omitempty"`
	IDNot                           *string                  `json:"id_not,omitempty"`
	IDIn                            []string                 `json:"id_in,omitempty"`
	IDNotIn                         []string                 `json:"id_not_in,omitempty"`
	IDLt                            *string                  `json:"id_lt,omitempty"`
	IDLte                           *string                  `json:"id_lte,omitempty"`
	IDGt                            *string                  `json:"id_gt,omitempty"`
	IDGte                           *string                  `json:"id_gte,omitempty"`
	IDContains                      *string                  `json:"id_contains,omitempty"`
	IDNotContains                   *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                    *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith                 *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                      *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                   *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                       *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                    *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                       *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                    *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                     []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                  []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                     *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                    *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                     *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                    *string                  `json:"updatedAt_gte,omitempty"`
	PhoneNumber                     *string                  `json:"phoneNumber,omitempty"`
	PhoneNumberNot                  *string                  `json:"phoneNumber_not,omitempty"`
	PhoneNumberIn                   []string                 `json:"phoneNumber_in,omitempty"`
	PhoneNumberNotIn                []string                 `json:"phoneNumber_not_in,omitempty"`
	PhoneNumberLt                   *string                  `json:"phoneNumber_lt,omitempty"`
	PhoneNumberLte                  *string                  `json:"phoneNumber_lte,omitempty"`
	PhoneNumberGt                   *string                  `json:"phoneNumber_gt,omitempty"`
	PhoneNumberGte                  *string                  `json:"phoneNumber_gte,omitempty"`
	PhoneNumberContains             *string                  `json:"phoneNumber_contains,omitempty"`
	PhoneNumberNotContains          *string                  `json:"phoneNumber_not_contains,omitempty"`
	PhoneNumberStartsWith           *string                  `json:"phoneNumber_starts_with,omitempty"`
	PhoneNumberNotStartsWith        *string                  `json:"phoneNumber_not_starts_with,omitempty"`
	PhoneNumberEndsWith             *string                  `json:"phoneNumber_ends_with,omitempty"`
	PhoneNumberNotEndsWith          *string                  `json:"phoneNumber_not_ends_with,omitempty"`
	Address                         *string                  `json:"address,omitempty"`
	AddressNot                      *string                  `json:"address_not,omitempty"`
	AddressIn                       []string                 `json:"address_in,omitempty"`
	AddressNotIn                    []string                 `json:"address_not_in,omitempty"`
	AddressLt                       *string                  `json:"address_lt,omitempty"`
	AddressLte                      *string                  `json:"address_lte,omitempty"`
	AddressGt                       *string                  `json:"address_gt,omitempty"`
	AddressGte                      *string                  `json:"address_gte,omitempty"`
	AddressContains                 *string                  `json:"address_contains,omitempty"`
	AddressNotContains              *string                  `json:"address_not_contains,omitempty"`
	AddressStartsWith               *string                  `json:"address_starts_with,omitempty"`
	AddressNotStartsWith            *string                  `json:"address_not_starts_with,omitempty"`
	AddressEndsWith                 *string                  `json:"address_ends_with,omitempty"`
	AddressNotEndsWith              *string                  `json:"address_not_ends_with,omitempty"`
	WebsiteUrl                      *string                  `json:"websiteUrl,omitempty"`
	WebsiteUrlNot                   *string                  `json:"websiteUrl_not,omitempty"`
	WebsiteUrlIn                    []string                 `json:"websiteUrl_in,omitempty"`
	WebsiteUrlNotIn                 []string                 `json:"websiteUrl_not_in,omitempty"`
	WebsiteUrlLt                    *string                  `json:"websiteUrl_lt,omitempty"`
	WebsiteUrlLte                   *string                  `json:"websiteUrl_lte,omitempty"`
	WebsiteUrlGt                    *string                  `json:"websiteUrl_gt,omitempty"`
	WebsiteUrlGte                   *string                  `json:"websiteUrl_gte,omitempty"`
	WebsiteUrlContains              *string                  `json:"websiteUrl_contains,omitempty"`
	WebsiteUrlNotContains           *string                  `json:"websiteUrl_not_contains,omitempty"`
	WebsiteUrlStartsWith            *string                  `json:"websiteUrl_starts_with,omitempty"`
	WebsiteUrlNotStartsWith         *string                  `json:"websiteUrl_not_starts_with,omitempty"`
	WebsiteUrlEndsWith              *string                  `json:"websiteUrl_ends_with,omitempty"`
	WebsiteUrlNotEndsWith           *string                  `json:"websiteUrl_not_ends_with,omitempty"`
	NavigationLink                  *string                  `json:"navigationLink,omitempty"`
	NavigationLinkNot               *string                  `json:"navigationLink_not,omitempty"`
	NavigationLinkIn                []string                 `json:"navigationLink_in,omitempty"`
	NavigationLinkNotIn             []string                 `json:"navigationLink_not_in,omitempty"`
	NavigationLinkLt                *string                  `json:"navigationLink_lt,omitempty"`
	NavigationLinkLte               *string                  `json:"navigationLink_lte,omitempty"`
	NavigationLinkGt                *string                  `json:"navigationLink_gt,omitempty"`
	NavigationLinkGte               *string                  `json:"navigationLink_gte,omitempty"`
	NavigationLinkContains          *string                  `json:"navigationLink_contains,omitempty"`
	NavigationLinkNotContains       *string                  `json:"navigationLink_not_contains,omitempty"`
	NavigationLinkStartsWith        *string                  `json:"navigationLink_starts_with,omitempty"`
	NavigationLinkNotStartsWith     *string                  `json:"navigationLink_not_starts_with,omitempty"`
	NavigationLinkEndsWith          *string                  `json:"navigationLink_ends_with,omitempty"`
	NavigationLinkNotEndsWith       *string                  `json:"navigationLink_not_ends_with,omitempty"`
	SharingRedirectUrl              *string                  `json:"sharingRedirectUrl,omitempty"`
	SharingRedirectUrlNot           *string                  `json:"sharingRedirectUrl_not,omitempty"`
	SharingRedirectUrlIn            []string                 `json:"sharingRedirectUrl_in,omitempty"`
	SharingRedirectUrlNotIn         []string                 `json:"sharingRedirectUrl_not_in,omitempty"`
	SharingRedirectUrlLt            *string                  `json:"sharingRedirectUrl_lt,omitempty"`
	SharingRedirectUrlLte           *string                  `json:"sharingRedirectUrl_lte,omitempty"`
	SharingRedirectUrlGt            *string                  `json:"sharingRedirectUrl_gt,omitempty"`
	SharingRedirectUrlGte           *string                  `json:"sharingRedirectUrl_gte,omitempty"`
	SharingRedirectUrlContains      *string                  `json:"sharingRedirectUrl_contains,omitempty"`
	SharingRedirectUrlNotContains   *string                  `json:"sharingRedirectUrl_not_contains,omitempty"`
	SharingRedirectUrlStartsWith    *string                  `json:"sharingRedirectUrl_starts_with,omitempty"`
	SharingRedirectUrlNotStartsWith *string                  `json:"sharingRedirectUrl_not_starts_with,omitempty"`
	SharingRedirectUrlEndsWith      *string                  `json:"sharingRedirectUrl_ends_with,omitempty"`
	SharingRedirectUrlNotEndsWith   *string                  `json:"sharingRedirectUrl_not_ends_with,omitempty"`
	Imprint                         *string                  `json:"imprint,omitempty"`
	ImprintNot                      *string                  `json:"imprint_not,omitempty"`
	ImprintIn                       []string                 `json:"imprint_in,omitempty"`
	ImprintNotIn                    []string                 `json:"imprint_not_in,omitempty"`
	ImprintLt                       *string                  `json:"imprint_lt,omitempty"`
	ImprintLte                      *string                  `json:"imprint_lte,omitempty"`
	ImprintGt                       *string                  `json:"imprint_gt,omitempty"`
	ImprintGte                      *string                  `json:"imprint_gte,omitempty"`
	ImprintContains                 *string                  `json:"imprint_contains,omitempty"`
	ImprintNotContains              *string                  `json:"imprint_not_contains,omitempty"`
	ImprintStartsWith               *string                  `json:"imprint_starts_with,omitempty"`
	ImprintNotStartsWith            *string                  `json:"imprint_not_starts_with,omitempty"`
	ImprintEndsWith                 *string                  `json:"imprint_ends_with,omitempty"`
	ImprintNotEndsWith              *string                  `json:"imprint_not_ends_with,omitempty"`
	Logo                            *string                  `json:"logo,omitempty"`
	LogoNot                         *string                  `json:"logo_not,omitempty"`
	LogoIn                          []string                 `json:"logo_in,omitempty"`
	LogoNotIn                       []string                 `json:"logo_not_in,omitempty"`
	LogoLt                          *string                  `json:"logo_lt,omitempty"`
	LogoLte                         *string                  `json:"logo_lte,omitempty"`
	LogoGt                          *string                  `json:"logo_gt,omitempty"`
	LogoGte                         *string                  `json:"logo_gte,omitempty"`
	LogoContains                    *string                  `json:"logo_contains,omitempty"`
	LogoNotContains                 *string                  `json:"logo_not_contains,omitempty"`
	LogoStartsWith                  *string                  `json:"logo_starts_with,omitempty"`
	LogoNotStartsWith               *string                  `json:"logo_not_starts_with,omitempty"`
	LogoEndsWith                    *string                  `json:"logo_ends_with,omitempty"`
	LogoNotEndsWith                 *string                  `json:"logo_not_ends_with,omitempty"`
	AppTheme                        *string                  `json:"appTheme,omitempty"`
	AppThemeNot                     *string                  `json:"appTheme_not,omitempty"`
	AppThemeIn                      []string                 `json:"appTheme_in,omitempty"`
	AppThemeNotIn                   []string                 `json:"appTheme_not_in,omitempty"`
	AppThemeLt                      *string                  `json:"appTheme_lt,omitempty"`
	AppThemeLte                     *string                  `json:"appTheme_lte,omitempty"`
	AppThemeGt                      *string                  `json:"appTheme_gt,omitempty"`
	AppThemeGte                     *string                  `json:"appTheme_gte,omitempty"`
	AppThemeContains                *string                  `json:"appTheme_contains,omitempty"`
	AppThemeNotContains             *string                  `json:"appTheme_not_contains,omitempty"`
	AppThemeStartsWith              *string                  `json:"appTheme_starts_with,omitempty"`
	AppThemeNotStartsWith           *string                  `json:"appTheme_not_starts_with,omitempty"`
	AppThemeEndsWith                *string                  `json:"appTheme_ends_with,omitempty"`
	AppThemeNotEndsWith             *string                  `json:"appTheme_not_ends_with,omitempty"`
	FacebookLink                    *string                  `json:"facebookLink,omitempty"`
	FacebookLinkNot                 *string                  `json:"facebookLink_not,omitempty"`
	FacebookLinkIn                  []string                 `json:"facebookLink_in,omitempty"`
	FacebookLinkNotIn               []string                 `json:"facebookLink_not_in,omitempty"`
	FacebookLinkLt                  *string                  `json:"facebookLink_lt,omitempty"`
	FacebookLinkLte                 *string                  `json:"facebookLink_lte,omitempty"`
	FacebookLinkGt                  *string                  `json:"facebookLink_gt,omitempty"`
	FacebookLinkGte                 *string                  `json:"facebookLink_gte,omitempty"`
	FacebookLinkContains            *string                  `json:"facebookLink_contains,omitempty"`
	FacebookLinkNotContains         *string                  `json:"facebookLink_not_contains,omitempty"`
	FacebookLinkStartsWith          *string                  `json:"facebookLink_starts_with,omitempty"`
	FacebookLinkNotStartsWith       *string                  `json:"facebookLink_not_starts_with,omitempty"`
	FacebookLinkEndsWith            *string                  `json:"facebookLink_ends_with,omitempty"`
	FacebookLinkNotEndsWith         *string                  `json:"facebookLink_not_ends_with,omitempty"`
	TiktokLink                      *string                  `json:"tiktokLink,omitempty"`
	TiktokLinkNot                   *string                  `json:"tiktokLink_not,omitempty"`
	TiktokLinkIn                    []string                 `json:"tiktokLink_in,omitempty"`
	TiktokLinkNotIn                 []string                 `json:"tiktokLink_not_in,omitempty"`
	TiktokLinkLt                    *string                  `json:"tiktokLink_lt,omitempty"`
	TiktokLinkLte                   *string                  `json:"tiktokLink_lte,omitempty"`
	TiktokLinkGt                    *string                  `json:"tiktokLink_gt,omitempty"`
	TiktokLinkGte                   *string                  `json:"tiktokLink_gte,omitempty"`
	TiktokLinkContains              *string                  `json:"tiktokLink_contains,omitempty"`
	TiktokLinkNotContains           *string                  `json:"tiktokLink_not_contains,omitempty"`
	TiktokLinkStartsWith            *string                  `json:"tiktokLink_starts_with,omitempty"`
	TiktokLinkNotStartsWith         *string                  `json:"tiktokLink_not_starts_with,omitempty"`
	TiktokLinkEndsWith              *string                  `json:"tiktokLink_ends_with,omitempty"`
	TiktokLinkNotEndsWith           *string                  `json:"tiktokLink_not_ends_with,omitempty"`
	InstagramLink                   *string                  `json:"instagramLink,omitempty"`
	InstagramLinkNot                *string                  `json:"instagramLink_not,omitempty"`
	InstagramLinkIn                 []string                 `json:"instagramLink_in,omitempty"`
	InstagramLinkNotIn              []string                 `json:"instagramLink_not_in,omitempty"`
	InstagramLinkLt                 *string                  `json:"instagramLink_lt,omitempty"`
	InstagramLinkLte                *string                  `json:"instagramLink_lte,omitempty"`
	InstagramLinkGt                 *string                  `json:"instagramLink_gt,omitempty"`
	InstagramLinkGte                *string                  `json:"instagramLink_gte,omitempty"`
	InstagramLinkContains           *string                  `json:"instagramLink_contains,omitempty"`
	InstagramLinkNotContains        *string                  `json:"instagramLink_not_contains,omitempty"`
	InstagramLinkStartsWith         *string                  `json:"instagramLink_starts_with,omitempty"`
	InstagramLinkNotStartsWith      *string                  `json:"instagramLink_not_starts_with,omitempty"`
	InstagramLinkEndsWith           *string                  `json:"instagramLink_ends_with,omitempty"`
	InstagramLinkNotEndsWith        *string                  `json:"instagramLink_not_ends_with,omitempty"`
	SmtpSendHost                    *string                  `json:"smtpSendHost,omitempty"`
	SmtpSendHostNot                 *string                  `json:"smtpSendHost_not,omitempty"`
	SmtpSendHostIn                  []string                 `json:"smtpSendHost_in,omitempty"`
	SmtpSendHostNotIn               []string                 `json:"smtpSendHost_not_in,omitempty"`
	SmtpSendHostLt                  *string                  `json:"smtpSendHost_lt,omitempty"`
	SmtpSendHostLte                 *string                  `json:"smtpSendHost_lte,omitempty"`
	SmtpSendHostGt                  *string                  `json:"smtpSendHost_gt,omitempty"`
	SmtpSendHostGte                 *string                  `json:"smtpSendHost_gte,omitempty"`
	SmtpSendHostContains            *string                  `json:"smtpSendHost_contains,omitempty"`
	SmtpSendHostNotContains         *string                  `json:"smtpSendHost_not_contains,omitempty"`
	SmtpSendHostStartsWith          *string                  `json:"smtpSendHost_starts_with,omitempty"`
	SmtpSendHostNotStartsWith       *string                  `json:"smtpSendHost_not_starts_with,omitempty"`
	SmtpSendHostEndsWith            *string                  `json:"smtpSendHost_ends_with,omitempty"`
	SmtpSendHostNotEndsWith         *string                  `json:"smtpSendHost_not_ends_with,omitempty"`
	SmtpSendPort                    *string                  `json:"smtpSendPort,omitempty"`
	SmtpSendPortNot                 *string                  `json:"smtpSendPort_not,omitempty"`
	SmtpSendPortIn                  []string                 `json:"smtpSendPort_in,omitempty"`
	SmtpSendPortNotIn               []string                 `json:"smtpSendPort_not_in,omitempty"`
	SmtpSendPortLt                  *string                  `json:"smtpSendPort_lt,omitempty"`
	SmtpSendPortLte                 *string                  `json:"smtpSendPort_lte,omitempty"`
	SmtpSendPortGt                  *string                  `json:"smtpSendPort_gt,omitempty"`
	SmtpSendPortGte                 *string                  `json:"smtpSendPort_gte,omitempty"`
	SmtpSendPortContains            *string                  `json:"smtpSendPort_contains,omitempty"`
	SmtpSendPortNotContains         *string                  `json:"smtpSendPort_not_contains,omitempty"`
	SmtpSendPortStartsWith          *string                  `json:"smtpSendPort_starts_with,omitempty"`
	SmtpSendPortNotStartsWith       *string                  `json:"smtpSendPort_not_starts_with,omitempty"`
	SmtpSendPortEndsWith            *string                  `json:"smtpSendPort_ends_with,omitempty"`
	SmtpSendPortNotEndsWith         *string                  `json:"smtpSendPort_not_ends_with,omitempty"`
	SmtpUsername                    *string                  `json:"smtpUsername,omitempty"`
	SmtpUsernameNot                 *string                  `json:"smtpUsername_not,omitempty"`
	SmtpUsernameIn                  []string                 `json:"smtpUsername_in,omitempty"`
	SmtpUsernameNotIn               []string                 `json:"smtpUsername_not_in,omitempty"`
	SmtpUsernameLt                  *string                  `json:"smtpUsername_lt,omitempty"`
	SmtpUsernameLte                 *string                  `json:"smtpUsername_lte,omitempty"`
	SmtpUsernameGt                  *string                  `json:"smtpUsername_gt,omitempty"`
	SmtpUsernameGte                 *string                  `json:"smtpUsername_gte,omitempty"`
	SmtpUsernameContains            *string                  `json:"smtpUsername_contains,omitempty"`
	SmtpUsernameNotContains         *string                  `json:"smtpUsername_not_contains,omitempty"`
	SmtpUsernameStartsWith          *string                  `json:"smtpUsername_starts_with,omitempty"`
	SmtpUsernameNotStartsWith       *string                  `json:"smtpUsername_not_starts_with,omitempty"`
	SmtpUsernameEndsWith            *string                  `json:"smtpUsername_ends_with,omitempty"`
	SmtpUsernameNotEndsWith         *string                  `json:"smtpUsername_not_ends_with,omitempty"`
	SmtpPassword                    *string                  `json:"smtpPassword,omitempty"`
	SmtpPasswordNot                 *string                  `json:"smtpPassword_not,omitempty"`
	SmtpPasswordIn                  []string                 `json:"smtpPassword_in,omitempty"`
	SmtpPasswordNotIn               []string                 `json:"smtpPassword_not_in,omitempty"`
	SmtpPasswordLt                  *string                  `json:"smtpPassword_lt,omitempty"`
	SmtpPasswordLte                 *string                  `json:"smtpPassword_lte,omitempty"`
	SmtpPasswordGt                  *string                  `json:"smtpPassword_gt,omitempty"`
	SmtpPasswordGte                 *string                  `json:"smtpPassword_gte,omitempty"`
	SmtpPasswordContains            *string                  `json:"smtpPassword_contains,omitempty"`
	SmtpPasswordNotContains         *string                  `json:"smtpPassword_not_contains,omitempty"`
	SmtpPasswordStartsWith          *string                  `json:"smtpPassword_starts_with,omitempty"`
	SmtpPasswordNotStartsWith       *string                  `json:"smtpPassword_not_starts_with,omitempty"`
	SmtpPasswordEndsWith            *string                  `json:"smtpPassword_ends_with,omitempty"`
	SmtpPasswordNotEndsWith         *string                  `json:"smtpPassword_not_ends_with,omitempty"`
	FromEmail                       *string                  `json:"fromEmail,omitempty"`
	FromEmailNot                    *string                  `json:"fromEmail_not,omitempty"`
	FromEmailIn                     []string                 `json:"fromEmail_in,omitempty"`
	FromEmailNotIn                  []string                 `json:"fromEmail_not_in,omitempty"`
	FromEmailLt                     *string                  `json:"fromEmail_lt,omitempty"`
	FromEmailLte                    *string                  `json:"fromEmail_lte,omitempty"`
	FromEmailGt                     *string                  `json:"fromEmail_gt,omitempty"`
	FromEmailGte                    *string                  `json:"fromEmail_gte,omitempty"`
	FromEmailContains               *string                  `json:"fromEmail_contains,omitempty"`
	FromEmailNotContains            *string                  `json:"fromEmail_not_contains,omitempty"`
	FromEmailStartsWith             *string                  `json:"fromEmail_starts_with,omitempty"`
	FromEmailNotStartsWith          *string                  `json:"fromEmail_not_starts_with,omitempty"`
	FromEmailEndsWith               *string                  `json:"fromEmail_ends_with,omitempty"`
	FromEmailNotEndsWith            *string                  `json:"fromEmail_not_ends_with,omitempty"`
	MailchimpApiKey                 *string                  `json:"mailchimpApiKey,omitempty"`
	MailchimpApiKeyNot              *string                  `json:"mailchimpApiKey_not,omitempty"`
	MailchimpApiKeyIn               []string                 `json:"mailchimpApiKey_in,omitempty"`
	MailchimpApiKeyNotIn            []string                 `json:"mailchimpApiKey_not_in,omitempty"`
	MailchimpApiKeyLt               *string                  `json:"mailchimpApiKey_lt,omitempty"`
	MailchimpApiKeyLte              *string                  `json:"mailchimpApiKey_lte,omitempty"`
	MailchimpApiKeyGt               *string                  `json:"mailchimpApiKey_gt,omitempty"`
	MailchimpApiKeyGte              *string                  `json:"mailchimpApiKey_gte,omitempty"`
	MailchimpApiKeyContains         *string                  `json:"mailchimpApiKey_contains,omitempty"`
	MailchimpApiKeyNotContains      *string                  `json:"mailchimpApiKey_not_contains,omitempty"`
	MailchimpApiKeyStartsWith       *string                  `json:"mailchimpApiKey_starts_with,omitempty"`
	MailchimpApiKeyNotStartsWith    *string                  `json:"mailchimpApiKey_not_starts_with,omitempty"`
	MailchimpApiKeyEndsWith         *string                  `json:"mailchimpApiKey_ends_with,omitempty"`
	MailchimpApiKeyNotEndsWith      *string                  `json:"mailchimpApiKey_not_ends_with,omitempty"`
	MailchimpListId                 *string                  `json:"mailchimpListId,omitempty"`
	MailchimpListIdNot              *string                  `json:"mailchimpListId_not,omitempty"`
	MailchimpListIdIn               []string                 `json:"mailchimpListId_in,omitempty"`
	MailchimpListIdNotIn            []string                 `json:"mailchimpListId_not_in,omitempty"`
	MailchimpListIdLt               *string                  `json:"mailchimpListId_lt,omitempty"`
	MailchimpListIdLte              *string                  `json:"mailchimpListId_lte,omitempty"`
	MailchimpListIdGt               *string                  `json:"mailchimpListId_gt,omitempty"`
	MailchimpListIdGte              *string                  `json:"mailchimpListId_gte,omitempty"`
	MailchimpListIdContains         *string                  `json:"mailchimpListId_contains,omitempty"`
	MailchimpListIdNotContains      *string                  `json:"mailchimpListId_not_contains,omitempty"`
	MailchimpListIdStartsWith       *string                  `json:"mailchimpListId_starts_with,omitempty"`
	MailchimpListIdNotStartsWith    *string                  `json:"mailchimpListId_not_starts_with,omitempty"`
	MailchimpListIdEndsWith         *string                  `json:"mailchimpListId_ends_with,omitempty"`
	MailchimpListIdNotEndsWith      *string                  `json:"mailchimpListId_not_ends_with,omitempty"`
	And                             []BranchScalarWhereInput `json:"AND,omitempty"`
	Or                              []BranchScalarWhereInput `json:"OR,omitempty"`
	Not                             []BranchScalarWhereInput `json:"NOT,omitempty"`
}

type BranchUpdateManyWithWhereNestedInput struct {
	Where BranchScalarWhereInput    `json:"where"`
	Data  BranchUpdateManyDataInput `json:"data"`
}

type BranchUpdateManyDataInput struct {
	PhoneNumber        *string                  `json:"phoneNumber,omitempty"`
	Address            *string                  `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput `json:"images,omitempty"`
	WebsiteUrl         *string                  `json:"websiteUrl,omitempty"`
	NavigationLink     *string                  `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                  `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                  `json:"imprint,omitempty"`
	Logo               *string                  `json:"logo,omitempty"`
	AppTheme           *string                  `json:"appTheme,omitempty"`
	FacebookLink       *string                  `json:"facebookLink,omitempty"`
	TiktokLink         *string                  `json:"tiktokLink,omitempty"`
	InstagramLink      *string                  `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                  `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                  `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                  `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                  `json:"smtpPassword,omitempty"`
	FromEmail          *string                  `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                  `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                  `json:"mailchimpListId,omitempty"`
}

type CompanyUpsertNestedInput struct {
	Update CompanyUpdateDataInput `json:"update"`
	Create CompanyCreateInput     `json:"create"`
}

type ServiceUpdateManyWithoutSubCategoryInput struct {
	Create     []ServiceCreateWithoutSubCategoryInput                `json:"create,omitempty"`
	Delete     []ServiceWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []ServiceWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []ServiceWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []ServiceWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []ServiceUpdateWithWhereUniqueWithoutSubCategoryInput `json:"update,omitempty"`
	Upsert     []ServiceUpsertWithWhereUniqueWithoutSubCategoryInput `json:"upsert,omitempty"`
	DeleteMany []ServiceScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []ServiceUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type ServiceUpdateWithWhereUniqueWithoutSubCategoryInput struct {
	Where ServiceWhereUniqueInput                  `json:"where"`
	Data  ServiceUpdateWithoutSubCategoryDataInput `json:"data"`
}

type ServiceUpdateWithoutSubCategoryDataInput struct {
	Name         *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc         *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price        *int32                                                `json:"price,omitempty"`
	Duration     *int32                                                `json:"duration,omitempty"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeUpdateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryUpdateOneInput                        `json:"category,omitempty"`
	Branch       *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company      *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Reviews      *ReviewUpdateManyWithoutServiceInput                  `json:"reviews,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ProductServiceAttributeUpdateManyWithoutServiceInput struct {
	Create     []ProductServiceAttributeCreateWithoutServiceInput                `json:"create,omitempty"`
	Delete     []ProductServiceAttributeWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []ProductServiceAttributeWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []ProductServiceAttributeWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []ProductServiceAttributeWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []ProductServiceAttributeUpdateWithWhereUniqueWithoutServiceInput `json:"update,omitempty"`
	Upsert     []ProductServiceAttributeUpsertWithWhereUniqueWithoutServiceInput `json:"upsert,omitempty"`
	DeleteMany []ProductServiceAttributeScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []ProductServiceAttributeUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type ProductServiceAttributeUpdateWithWhereUniqueWithoutServiceInput struct {
	Where ProductServiceAttributeWhereUniqueInput              `json:"where"`
	Data  ProductServiceAttributeUpdateWithoutServiceDataInput `json:"data"`
}

type ProductServiceAttributeUpdateWithoutServiceDataInput struct {
	Product *ProductUpdateOneWithoutAttributesInput `json:"product,omitempty"`
	Key     *string                                 `json:"key,omitempty"`
	Name    *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	Value   *LocalizedStringUpdateOneRequiredInput  `json:"value,omitempty"`
	Company *CompanyUpdateOneInput                  `json:"company,omitempty"`
}

type ProductUpdateOneWithoutAttributesInput struct {
	Create     *ProductCreateWithoutAttributesInput     `json:"create,omitempty"`
	Update     *ProductUpdateWithoutAttributesDataInput `json:"update,omitempty"`
	Upsert     *ProductUpsertWithoutAttributesInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *ProductWhereUniqueInput                 `json:"connect,omitempty"`
}

type ProductUpdateWithoutAttributesDataInput struct {
	Name        *LocalizedStringUpdateOneRequiredInput           `json:"name,omitempty"`
	Desc        *LocalizedStringUpdateOneRequiredInput           `json:"desc,omitempty"`
	Price       *int32                                           `json:"price,omitempty"`
	Capacity    *string                                          `json:"capacity,omitempty"`
	Category    *ProductCategoryUpdateOneInput                   `json:"category,omitempty"`
	SubCategory *ProductSubCategoryUpdateOneWithoutProductsInput `json:"subCategory,omitempty"`
	Image       *string                                          `json:"image,omitempty"`
	Branch      *BranchUpdateOneRequiredInput                    `json:"branch,omitempty"`
	Company     *CompanyUpdateOneInput                           `json:"company,omitempty"`
	Reviews     *ReviewUpdateManyWithoutProductInput             `json:"reviews,omitempty"`
	Deleted     *bool                                            `json:"deleted,omitempty"`
	Active      *bool                                            `json:"active,omitempty"`
}

type ProductSubCategoryUpdateOneWithoutProductsInput struct {
	Create     *ProductSubCategoryCreateWithoutProductsInput     `json:"create,omitempty"`
	Update     *ProductSubCategoryUpdateWithoutProductsDataInput `json:"update,omitempty"`
	Upsert     *ProductSubCategoryUpsertWithoutProductsInput     `json:"upsert,omitempty"`
	Delete     *bool                                             `json:"delete,omitempty"`
	Disconnect *bool                                             `json:"disconnect,omitempty"`
	Connect    *ProductSubCategoryWhereUniqueInput               `json:"connect,omitempty"`
}

type ProductSubCategoryUpdateWithoutProductsDataInput struct {
	Name     *string                                            `json:"name,omitempty"`
	Category *ProductCategoryUpdateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Company  *CompanyUpdateOneInput                             `json:"company,omitempty"`
}

type ProductCategoryUpdateOneWithoutSubCategoriesInput struct {
	Create     *ProductCategoryCreateWithoutSubCategoriesInput     `json:"create,omitempty"`
	Update     *ProductCategoryUpdateWithoutSubCategoriesDataInput `json:"update,omitempty"`
	Upsert     *ProductCategoryUpsertWithoutSubCategoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                               `json:"delete,omitempty"`
	Disconnect *bool                                               `json:"disconnect,omitempty"`
	Connect    *ProductCategoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type ProductCategoryUpdateWithoutSubCategoriesDataInput struct {
	Name    *string                `json:"name,omitempty"`
	Company *CompanyUpdateOneInput `json:"company,omitempty"`
}

type ProductCategoryUpsertWithoutSubCategoriesInput struct {
	Update ProductCategoryUpdateWithoutSubCategoriesDataInput `json:"update"`
	Create ProductCategoryCreateWithoutSubCategoriesInput     `json:"create"`
}

type ProductSubCategoryUpsertWithoutProductsInput struct {
	Update ProductSubCategoryUpdateWithoutProductsDataInput `json:"update"`
	Create ProductSubCategoryCreateWithoutProductsInput     `json:"create"`
}

type BranchUpdateOneRequiredInput struct {
	Create  *BranchCreateInput       `json:"create,omitempty"`
	Update  *BranchUpdateDataInput   `json:"update,omitempty"`
	Upsert  *BranchUpsertNestedInput `json:"upsert,omitempty"`
	Connect *BranchWhereUniqueInput  `json:"connect,omitempty"`
}

type BranchUpdateDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput         `json:"name,omitempty"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput         `json:"welcomeMessage,omitempty"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         *string                                        `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                        `json:"imprint,omitempty"`
	Company            *CompanyUpdateOneRequiredWithoutBranchesInput  `json:"company,omitempty"`
	Employees          *UserUpdateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourUpdateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsUpdateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotUpdateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type CompanyUpdateOneRequiredWithoutBranchesInput struct {
	Create  *CompanyCreateWithoutBranchesInput     `json:"create,omitempty"`
	Update  *CompanyUpdateWithoutBranchesDataInput `json:"update,omitempty"`
	Upsert  *CompanyUpsertWithoutBranchesInput     `json:"upsert,omitempty"`
	Connect *CompanyWhereUniqueInput               `json:"connect,omitempty"`
}

type CompanyUpdateWithoutBranchesDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	CustomUrls         *CustomUrlUpdateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasUpdateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       *LocalizedStringUpdateOneRequiredInput  `json:"pwaShortName,omitempty"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string                                 `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string                                 `json:"pwaBackgroundColor,omitempty"`
	Users              *UserUpdateManyWithoutCompanyInput      `json:"users,omitempty"`
}

type CompanyUpsertWithoutBranchesInput struct {
	Update CompanyUpdateWithoutBranchesDataInput `json:"update"`
	Create CompanyCreateWithoutBranchesInput     `json:"create"`
}

type BranchUpsertNestedInput struct {
	Update BranchUpdateDataInput `json:"update"`
	Create BranchCreateInput     `json:"create"`
}

type ReviewUpdateManyWithoutProductInput struct {
	Create     []ReviewCreateWithoutProductInput                `json:"create,omitempty"`
	Delete     []ReviewWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []ReviewWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []ReviewWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []ReviewWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []ReviewUpdateWithWhereUniqueWithoutProductInput `json:"update,omitempty"`
	Upsert     []ReviewUpsertWithWhereUniqueWithoutProductInput `json:"upsert,omitempty"`
	DeleteMany []ReviewScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []ReviewUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type ReviewUpdateWithWhereUniqueWithoutProductInput struct {
	Where ReviewWhereUniqueInput              `json:"where"`
	Data  ReviewUpdateWithoutProductDataInput `json:"data"`
}

type ReviewUpdateWithoutProductDataInput struct {
	Type        *ReviewType                               `json:"type,omitempty"`
	Stars       *float64                                  `json:"stars,omitempty"`
	Title       *string                                   `json:"title,omitempty"`
	Text        *string                                   `json:"text,omitempty"`
	Status      *ReviewStatus                             `json:"status,omitempty"`
	Customer    *UserUpdateOneRequiredWithoutReviewsInput `json:"customer,omitempty"`
	Service     *ServiceUpdateOneWithoutReviewsInput      `json:"service,omitempty"`
	Appointment *AppointmentUpdateOneWithoutReviewInput   `json:"appointment,omitempty"`
	Company     *CompanyUpdateOneInput                    `json:"company,omitempty"`
}

type UserUpdateOneRequiredWithoutReviewsInput struct {
	Create  *UserCreateWithoutReviewsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutReviewsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutReviewsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput              `json:"connect,omitempty"`
}

type UserUpdateWithoutReviewsDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type BranchUpdateOneWithoutEmployeesInput struct {
	Create     *BranchCreateWithoutEmployeesInput     `json:"create,omitempty"`
	Update     *BranchUpdateWithoutEmployeesDataInput `json:"update,omitempty"`
	Upsert     *BranchUpsertWithoutEmployeesInput     `json:"upsert,omitempty"`
	Delete     *bool                                  `json:"delete,omitempty"`
	Disconnect *bool                                  `json:"disconnect,omitempty"`
	Connect    *BranchWhereUniqueInput                `json:"connect,omitempty"`
}

type BranchUpdateWithoutEmployeesDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput         `json:"name,omitempty"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput         `json:"welcomeMessage,omitempty"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         *string                                        `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                        `json:"imprint,omitempty"`
	Company            *CompanyUpdateOneRequiredWithoutBranchesInput  `json:"company,omitempty"`
	OpeningHours       *BranchOpeningHourUpdateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsUpdateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotUpdateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchUpsertWithoutEmployeesInput struct {
	Update BranchUpdateWithoutEmployeesDataInput `json:"update"`
	Create BranchCreateWithoutEmployeesInput     `json:"create"`
}

type UserUpsertWithoutReviewsInput struct {
	Update UserUpdateWithoutReviewsDataInput `json:"update"`
	Create UserCreateWithoutReviewsInput     `json:"create"`
}

type ServiceUpdateOneWithoutReviewsInput struct {
	Create     *ServiceCreateWithoutReviewsInput     `json:"create,omitempty"`
	Update     *ServiceUpdateWithoutReviewsDataInput `json:"update,omitempty"`
	Upsert     *ServiceUpsertWithoutReviewsInput     `json:"upsert,omitempty"`
	Delete     *bool                                 `json:"delete,omitempty"`
	Disconnect *bool                                 `json:"disconnect,omitempty"`
	Connect    *ServiceWhereUniqueInput              `json:"connect,omitempty"`
}

type ServiceUpdateWithoutReviewsDataInput struct {
	Name         *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc         *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price        *int32                                                `json:"price,omitempty"`
	Duration     *int32                                                `json:"duration,omitempty"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeUpdateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryUpdateOneInput                        `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryUpdateOneWithoutServicesInput      `json:"subCategory,omitempty"`
	Branch       *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company      *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ServiceSubCategoryUpdateOneWithoutServicesInput struct {
	Create     *ServiceSubCategoryCreateWithoutServicesInput     `json:"create,omitempty"`
	Update     *ServiceSubCategoryUpdateWithoutServicesDataInput `json:"update,omitempty"`
	Upsert     *ServiceSubCategoryUpsertWithoutServicesInput     `json:"upsert,omitempty"`
	Delete     *bool                                             `json:"delete,omitempty"`
	Disconnect *bool                                             `json:"disconnect,omitempty"`
	Connect    *ServiceSubCategoryWhereUniqueInput               `json:"connect,omitempty"`
}

type ServiceSubCategoryUpdateWithoutServicesDataInput struct {
	Name     *string                                            `json:"name,omitempty"`
	Category *ServiceCategoryUpdateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Company  *CompanyUpdateOneInput                             `json:"company,omitempty"`
}

type ServiceCategoryUpdateOneWithoutSubCategoriesInput struct {
	Create     *ServiceCategoryCreateWithoutSubCategoriesInput     `json:"create,omitempty"`
	Update     *ServiceCategoryUpdateWithoutSubCategoriesDataInput `json:"update,omitempty"`
	Upsert     *ServiceCategoryUpsertWithoutSubCategoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                               `json:"delete,omitempty"`
	Disconnect *bool                                               `json:"disconnect,omitempty"`
	Connect    *ServiceCategoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type ServiceCategoryUpdateWithoutSubCategoriesDataInput struct {
	Name    *string                `json:"name,omitempty"`
	Company *CompanyUpdateOneInput `json:"company,omitempty"`
}

type ServiceCategoryUpsertWithoutSubCategoriesInput struct {
	Update ServiceCategoryUpdateWithoutSubCategoriesDataInput `json:"update"`
	Create ServiceCategoryCreateWithoutSubCategoriesInput     `json:"create"`
}

type ServiceSubCategoryUpsertWithoutServicesInput struct {
	Update ServiceSubCategoryUpdateWithoutServicesDataInput `json:"update"`
	Create ServiceSubCategoryCreateWithoutServicesInput     `json:"create"`
}

type ServiceUpsertWithoutReviewsInput struct {
	Update ServiceUpdateWithoutReviewsDataInput `json:"update"`
	Create ServiceCreateWithoutReviewsInput     `json:"create"`
}

type AppointmentUpdateOneWithoutReviewInput struct {
	Create     *AppointmentCreateWithoutReviewInput     `json:"create,omitempty"`
	Update     *AppointmentUpdateWithoutReviewDataInput `json:"update,omitempty"`
	Upsert     *AppointmentUpsertWithoutReviewInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *AppointmentWhereUniqueInput             `json:"connect,omitempty"`
}

type AppointmentUpdateWithoutReviewDataInput struct {
	Desc                         *LocalizedStringUpdateOneInput                           `json:"desc,omitempty"`
	Start                        *string                                                  `json:"start,omitempty"`
	End                          *string                                                  `json:"end,omitempty"`
	Price                        *int32                                                   `json:"price,omitempty"`
	Status                       *AppointmentStatus                                       `json:"status,omitempty"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       *BranchUpdateOneRequiredInput                            `json:"branch,omitempty"`
	Company                      *CompanyUpdateOneInput                                   `json:"company,omitempty"`
	Employee                     *UserUpdateOneRequiredInput                              `json:"employee,omitempty"`
	Customer                     *UserUpdateOneRequiredInput                              `json:"customer,omitempty"`
	Products                     *AppointmentProductLinkUpdateManyWithoutAppointmentInput `json:"products,omitempty"`
	Services                     *AppointmentServiceLinkUpdateManyWithoutAppointmentInput `json:"services,omitempty"`
}

type LocalizedStringUpdateOneInput struct {
	Create     *LocalizedStringCreateInput       `json:"create,omitempty"`
	Update     *LocalizedStringUpdateDataInput   `json:"update,omitempty"`
	Upsert     *LocalizedStringUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *LocalizedStringWhereUniqueInput  `json:"connect,omitempty"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type UserUpdateDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type AppointmentProductLinkUpdateManyWithoutAppointmentInput struct {
	Create     []AppointmentProductLinkCreateWithoutAppointmentInput                `json:"create,omitempty"`
	Delete     []AppointmentProductLinkWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []AppointmentProductLinkWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []AppointmentProductLinkWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []AppointmentProductLinkWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []AppointmentProductLinkUpdateWithWhereUniqueWithoutAppointmentInput `json:"update,omitempty"`
	Upsert     []AppointmentProductLinkUpsertWithWhereUniqueWithoutAppointmentInput `json:"upsert,omitempty"`
	DeleteMany []AppointmentProductLinkScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []AppointmentProductLinkUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type AppointmentProductLinkUpdateWithWhereUniqueWithoutAppointmentInput struct {
	Where AppointmentProductLinkWhereUniqueInput                  `json:"where"`
	Data  AppointmentProductLinkUpdateWithoutAppointmentDataInput `json:"data"`
}

type AppointmentProductLinkUpdateWithoutAppointmentDataInput struct {
	Product *ProductUpdateOneRequiredInput `json:"product,omitempty"`
	Count   *int32                         `json:"count,omitempty"`
}

type ProductUpdateOneRequiredInput struct {
	Create  *ProductCreateInput       `json:"create,omitempty"`
	Update  *ProductUpdateDataInput   `json:"update,omitempty"`
	Upsert  *ProductUpsertNestedInput `json:"upsert,omitempty"`
	Connect *ProductWhereUniqueInput  `json:"connect,omitempty"`
}

type ProductUpdateDataInput struct {
	Name        *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc        *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price       *int32                                                `json:"price,omitempty"`
	Capacity    *string                                               `json:"capacity,omitempty"`
	Category    *ProductCategoryUpdateOneInput                        `json:"category,omitempty"`
	SubCategory *ProductSubCategoryUpdateOneWithoutProductsInput      `json:"subCategory,omitempty"`
	Image       *string                                               `json:"image,omitempty"`
	Attributes  *ProductServiceAttributeUpdateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch      *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company     *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Reviews     *ReviewUpdateManyWithoutProductInput                  `json:"reviews,omitempty"`
	Deleted     *bool                                                 `json:"deleted,omitempty"`
	Active      *bool                                                 `json:"active,omitempty"`
}

type ProductUpsertNestedInput struct {
	Update ProductUpdateDataInput `json:"update"`
	Create ProductCreateInput     `json:"create"`
}

type AppointmentProductLinkUpsertWithWhereUniqueWithoutAppointmentInput struct {
	Where  AppointmentProductLinkWhereUniqueInput                  `json:"where"`
	Update AppointmentProductLinkUpdateWithoutAppointmentDataInput `json:"update"`
	Create AppointmentProductLinkCreateWithoutAppointmentInput     `json:"create"`
}

type AppointmentProductLinkScalarWhereInput struct {
	ID              *string                                  `json:"id,omitempty"`
	IDNot           *string                                  `json:"id_not,omitempty"`
	IDIn            []string                                 `json:"id_in,omitempty"`
	IDNotIn         []string                                 `json:"id_not_in,omitempty"`
	IDLt            *string                                  `json:"id_lt,omitempty"`
	IDLte           *string                                  `json:"id_lte,omitempty"`
	IDGt            *string                                  `json:"id_gt,omitempty"`
	IDGte           *string                                  `json:"id_gte,omitempty"`
	IDContains      *string                                  `json:"id_contains,omitempty"`
	IDNotContains   *string                                  `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                                  `json:"id_not_ends_with,omitempty"`
	Count           *int32                                   `json:"count,omitempty"`
	CountNot        *int32                                   `json:"count_not,omitempty"`
	CountIn         []int32                                  `json:"count_in,omitempty"`
	CountNotIn      []int32                                  `json:"count_not_in,omitempty"`
	CountLt         *int32                                   `json:"count_lt,omitempty"`
	CountLte        *int32                                   `json:"count_lte,omitempty"`
	CountGt         *int32                                   `json:"count_gt,omitempty"`
	CountGte        *int32                                   `json:"count_gte,omitempty"`
	And             []AppointmentProductLinkScalarWhereInput `json:"AND,omitempty"`
	Or              []AppointmentProductLinkScalarWhereInput `json:"OR,omitempty"`
	Not             []AppointmentProductLinkScalarWhereInput `json:"NOT,omitempty"`
}

type AppointmentProductLinkUpdateManyWithWhereNestedInput struct {
	Where AppointmentProductLinkScalarWhereInput    `json:"where"`
	Data  AppointmentProductLinkUpdateManyDataInput `json:"data"`
}

type AppointmentProductLinkUpdateManyDataInput struct {
	Count *int32 `json:"count,omitempty"`
}

type AppointmentServiceLinkUpdateManyWithoutAppointmentInput struct {
	Create     []AppointmentServiceLinkCreateWithoutAppointmentInput                `json:"create,omitempty"`
	Delete     []AppointmentServiceLinkWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []AppointmentServiceLinkWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []AppointmentServiceLinkWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []AppointmentServiceLinkWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []AppointmentServiceLinkUpdateWithWhereUniqueWithoutAppointmentInput `json:"update,omitempty"`
	Upsert     []AppointmentServiceLinkUpsertWithWhereUniqueWithoutAppointmentInput `json:"upsert,omitempty"`
	DeleteMany []AppointmentServiceLinkScalarWhereInput                             `json:"deleteMany,omitempty"`
}

type AppointmentServiceLinkUpdateWithWhereUniqueWithoutAppointmentInput struct {
	Where AppointmentServiceLinkWhereUniqueInput                  `json:"where"`
	Data  AppointmentServiceLinkUpdateWithoutAppointmentDataInput `json:"data"`
}

type AppointmentServiceLinkUpdateWithoutAppointmentDataInput struct {
	Service *ServiceUpdateOneRequiredInput `json:"service,omitempty"`
}

type ServiceUpdateOneRequiredInput struct {
	Create  *ServiceCreateInput       `json:"create,omitempty"`
	Update  *ServiceUpdateDataInput   `json:"update,omitempty"`
	Upsert  *ServiceUpsertNestedInput `json:"upsert,omitempty"`
	Connect *ServiceWhereUniqueInput  `json:"connect,omitempty"`
}

type ServiceUpdateDataInput struct {
	Name         *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc         *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price        *int32                                                `json:"price,omitempty"`
	Duration     *int32                                                `json:"duration,omitempty"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeUpdateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryUpdateOneInput                        `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryUpdateOneWithoutServicesInput      `json:"subCategory,omitempty"`
	Branch       *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company      *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Reviews      *ReviewUpdateManyWithoutServiceInput                  `json:"reviews,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ReviewUpdateManyWithoutServiceInput struct {
	Create     []ReviewCreateWithoutServiceInput                `json:"create,omitempty"`
	Delete     []ReviewWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []ReviewWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []ReviewWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []ReviewWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []ReviewUpdateWithWhereUniqueWithoutServiceInput `json:"update,omitempty"`
	Upsert     []ReviewUpsertWithWhereUniqueWithoutServiceInput `json:"upsert,omitempty"`
	DeleteMany []ReviewScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []ReviewUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type ReviewUpdateWithWhereUniqueWithoutServiceInput struct {
	Where ReviewWhereUniqueInput              `json:"where"`
	Data  ReviewUpdateWithoutServiceDataInput `json:"data"`
}

type ReviewUpdateWithoutServiceDataInput struct {
	Type        *ReviewType                               `json:"type,omitempty"`
	Stars       *float64                                  `json:"stars,omitempty"`
	Title       *string                                   `json:"title,omitempty"`
	Text        *string                                   `json:"text,omitempty"`
	Status      *ReviewStatus                             `json:"status,omitempty"`
	Customer    *UserUpdateOneRequiredWithoutReviewsInput `json:"customer,omitempty"`
	Product     *ProductUpdateOneWithoutReviewsInput      `json:"product,omitempty"`
	Appointment *AppointmentUpdateOneWithoutReviewInput   `json:"appointment,omitempty"`
	Company     *CompanyUpdateOneInput                    `json:"company,omitempty"`
}

type ReviewUpsertWithWhereUniqueWithoutServiceInput struct {
	Where  ReviewWhereUniqueInput              `json:"where"`
	Update ReviewUpdateWithoutServiceDataInput `json:"update"`
	Create ReviewCreateWithoutServiceInput     `json:"create"`
}

type ReviewScalarWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	Type               *ReviewType              `json:"type,omitempty"`
	TypeNot            *ReviewType              `json:"type_not,omitempty"`
	TypeIn             []ReviewType             `json:"type_in,omitempty"`
	TypeNotIn          []ReviewType             `json:"type_not_in,omitempty"`
	Stars              *float64                 `json:"stars,omitempty"`
	StarsNot           *float64                 `json:"stars_not,omitempty"`
	StarsIn            []float64                `json:"stars_in,omitempty"`
	StarsNotIn         []float64                `json:"stars_not_in,omitempty"`
	StarsLt            *float64                 `json:"stars_lt,omitempty"`
	StarsLte           *float64                 `json:"stars_lte,omitempty"`
	StarsGt            *float64                 `json:"stars_gt,omitempty"`
	StarsGte           *float64                 `json:"stars_gte,omitempty"`
	Title              *string                  `json:"title,omitempty"`
	TitleNot           *string                  `json:"title_not,omitempty"`
	TitleIn            []string                 `json:"title_in,omitempty"`
	TitleNotIn         []string                 `json:"title_not_in,omitempty"`
	TitleLt            *string                  `json:"title_lt,omitempty"`
	TitleLte           *string                  `json:"title_lte,omitempty"`
	TitleGt            *string                  `json:"title_gt,omitempty"`
	TitleGte           *string                  `json:"title_gte,omitempty"`
	TitleContains      *string                  `json:"title_contains,omitempty"`
	TitleNotContains   *string                  `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string                  `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string                  `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string                  `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string                  `json:"title_not_ends_with,omitempty"`
	Text               *string                  `json:"text,omitempty"`
	TextNot            *string                  `json:"text_not,omitempty"`
	TextIn             []string                 `json:"text_in,omitempty"`
	TextNotIn          []string                 `json:"text_not_in,omitempty"`
	TextLt             *string                  `json:"text_lt,omitempty"`
	TextLte            *string                  `json:"text_lte,omitempty"`
	TextGt             *string                  `json:"text_gt,omitempty"`
	TextGte            *string                  `json:"text_gte,omitempty"`
	TextContains       *string                  `json:"text_contains,omitempty"`
	TextNotContains    *string                  `json:"text_not_contains,omitempty"`
	TextStartsWith     *string                  `json:"text_starts_with,omitempty"`
	TextNotStartsWith  *string                  `json:"text_not_starts_with,omitempty"`
	TextEndsWith       *string                  `json:"text_ends_with,omitempty"`
	TextNotEndsWith    *string                  `json:"text_not_ends_with,omitempty"`
	Status             *ReviewStatus            `json:"status,omitempty"`
	StatusNot          *ReviewStatus            `json:"status_not,omitempty"`
	StatusIn           []ReviewStatus           `json:"status_in,omitempty"`
	StatusNotIn        []ReviewStatus           `json:"status_not_in,omitempty"`
	And                []ReviewScalarWhereInput `json:"AND,omitempty"`
	Or                 []ReviewScalarWhereInput `json:"OR,omitempty"`
	Not                []ReviewScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewUpdateManyWithWhereNestedInput struct {
	Where ReviewScalarWhereInput    `json:"where"`
	Data  ReviewUpdateManyDataInput `json:"data"`
}

type ReviewUpdateManyDataInput struct {
	Type   *ReviewType   `json:"type,omitempty"`
	Stars  *float64      `json:"stars,omitempty"`
	Title  *string       `json:"title,omitempty"`
	Text   *string       `json:"text,omitempty"`
	Status *ReviewStatus `json:"status,omitempty"`
}

type ServiceUpsertNestedInput struct {
	Update ServiceUpdateDataInput `json:"update"`
	Create ServiceCreateInput     `json:"create"`
}

type AppointmentServiceLinkUpsertWithWhereUniqueWithoutAppointmentInput struct {
	Where  AppointmentServiceLinkWhereUniqueInput                  `json:"where"`
	Update AppointmentServiceLinkUpdateWithoutAppointmentDataInput `json:"update"`
	Create AppointmentServiceLinkCreateWithoutAppointmentInput     `json:"create"`
}

type AppointmentServiceLinkScalarWhereInput struct {
	ID              *string                                  `json:"id,omitempty"`
	IDNot           *string                                  `json:"id_not,omitempty"`
	IDIn            []string                                 `json:"id_in,omitempty"`
	IDNotIn         []string                                 `json:"id_not_in,omitempty"`
	IDLt            *string                                  `json:"id_lt,omitempty"`
	IDLte           *string                                  `json:"id_lte,omitempty"`
	IDGt            *string                                  `json:"id_gt,omitempty"`
	IDGte           *string                                  `json:"id_gte,omitempty"`
	IDContains      *string                                  `json:"id_contains,omitempty"`
	IDNotContains   *string                                  `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                                  `json:"id_not_ends_with,omitempty"`
	And             []AppointmentServiceLinkScalarWhereInput `json:"AND,omitempty"`
	Or              []AppointmentServiceLinkScalarWhereInput `json:"OR,omitempty"`
	Not             []AppointmentServiceLinkScalarWhereInput `json:"NOT,omitempty"`
}

type AppointmentUpsertWithoutReviewInput struct {
	Update AppointmentUpdateWithoutReviewDataInput `json:"update"`
	Create AppointmentCreateWithoutReviewInput     `json:"create"`
}

type ReviewUpsertWithWhereUniqueWithoutProductInput struct {
	Where  ReviewWhereUniqueInput              `json:"where"`
	Update ReviewUpdateWithoutProductDataInput `json:"update"`
	Create ReviewCreateWithoutProductInput     `json:"create"`
}

type ProductUpsertWithoutAttributesInput struct {
	Update ProductUpdateWithoutAttributesDataInput `json:"update"`
	Create ProductCreateWithoutAttributesInput     `json:"create"`
}

type ProductServiceAttributeUpsertWithWhereUniqueWithoutServiceInput struct {
	Where  ProductServiceAttributeWhereUniqueInput              `json:"where"`
	Update ProductServiceAttributeUpdateWithoutServiceDataInput `json:"update"`
	Create ProductServiceAttributeCreateWithoutServiceInput     `json:"create"`
}

type ProductServiceAttributeScalarWhereInput struct {
	ID               *string                                   `json:"id,omitempty"`
	IDNot            *string                                   `json:"id_not,omitempty"`
	IDIn             []string                                  `json:"id_in,omitempty"`
	IDNotIn          []string                                  `json:"id_not_in,omitempty"`
	IDLt             *string                                   `json:"id_lt,omitempty"`
	IDLte            *string                                   `json:"id_lte,omitempty"`
	IDGt             *string                                   `json:"id_gt,omitempty"`
	IDGte            *string                                   `json:"id_gte,omitempty"`
	IDContains       *string                                   `json:"id_contains,omitempty"`
	IDNotContains    *string                                   `json:"id_not_contains,omitempty"`
	IDStartsWith     *string                                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith  *string                                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith       *string                                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith    *string                                   `json:"id_not_ends_with,omitempty"`
	Key              *string                                   `json:"key,omitempty"`
	KeyNot           *string                                   `json:"key_not,omitempty"`
	KeyIn            []string                                  `json:"key_in,omitempty"`
	KeyNotIn         []string                                  `json:"key_not_in,omitempty"`
	KeyLt            *string                                   `json:"key_lt,omitempty"`
	KeyLte           *string                                   `json:"key_lte,omitempty"`
	KeyGt            *string                                   `json:"key_gt,omitempty"`
	KeyGte           *string                                   `json:"key_gte,omitempty"`
	KeyContains      *string                                   `json:"key_contains,omitempty"`
	KeyNotContains   *string                                   `json:"key_not_contains,omitempty"`
	KeyStartsWith    *string                                   `json:"key_starts_with,omitempty"`
	KeyNotStartsWith *string                                   `json:"key_not_starts_with,omitempty"`
	KeyEndsWith      *string                                   `json:"key_ends_with,omitempty"`
	KeyNotEndsWith   *string                                   `json:"key_not_ends_with,omitempty"`
	And              []ProductServiceAttributeScalarWhereInput `json:"AND,omitempty"`
	Or               []ProductServiceAttributeScalarWhereInput `json:"OR,omitempty"`
	Not              []ProductServiceAttributeScalarWhereInput `json:"NOT,omitempty"`
}

type ProductServiceAttributeUpdateManyWithWhereNestedInput struct {
	Where ProductServiceAttributeScalarWhereInput    `json:"where"`
	Data  ProductServiceAttributeUpdateManyDataInput `json:"data"`
}

type ProductServiceAttributeUpdateManyDataInput struct {
	Key *string `json:"key,omitempty"`
}

type ServiceUpsertWithWhereUniqueWithoutSubCategoryInput struct {
	Where  ServiceWhereUniqueInput                  `json:"where"`
	Update ServiceUpdateWithoutSubCategoryDataInput `json:"update"`
	Create ServiceCreateWithoutSubCategoryInput     `json:"create"`
}

type ServiceScalarWhereInput struct {
	ID                 *string                   `json:"id,omitempty"`
	IDNot              *string                   `json:"id_not,omitempty"`
	IDIn               []string                  `json:"id_in,omitempty"`
	IDNotIn            []string                  `json:"id_not_in,omitempty"`
	IDLt               *string                   `json:"id_lt,omitempty"`
	IDLte              *string                   `json:"id_lte,omitempty"`
	IDGt               *string                   `json:"id_gt,omitempty"`
	IDGte              *string                   `json:"id_gte,omitempty"`
	IDContains         *string                   `json:"id_contains,omitempty"`
	IDNotContains      *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                   `json:"createdAt,omitempty"`
	CreatedAtNot       *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                   `json:"updatedAt_gte,omitempty"`
	Price              *int32                    `json:"price,omitempty"`
	PriceNot           *int32                    `json:"price_not,omitempty"`
	PriceIn            []int32                   `json:"price_in,omitempty"`
	PriceNotIn         []int32                   `json:"price_not_in,omitempty"`
	PriceLt            *int32                    `json:"price_lt,omitempty"`
	PriceLte           *int32                    `json:"price_lte,omitempty"`
	PriceGt            *int32                    `json:"price_gt,omitempty"`
	PriceGte           *int32                    `json:"price_gte,omitempty"`
	Duration           *int32                    `json:"duration,omitempty"`
	DurationNot        *int32                    `json:"duration_not,omitempty"`
	DurationIn         []int32                   `json:"duration_in,omitempty"`
	DurationNotIn      []int32                   `json:"duration_not_in,omitempty"`
	DurationLt         *int32                    `json:"duration_lt,omitempty"`
	DurationLte        *int32                    `json:"duration_lte,omitempty"`
	DurationGt         *int32                    `json:"duration_gt,omitempty"`
	DurationGte        *int32                    `json:"duration_gte,omitempty"`
	Image              *string                   `json:"image,omitempty"`
	ImageNot           *string                   `json:"image_not,omitempty"`
	ImageIn            []string                  `json:"image_in,omitempty"`
	ImageNotIn         []string                  `json:"image_not_in,omitempty"`
	ImageLt            *string                   `json:"image_lt,omitempty"`
	ImageLte           *string                   `json:"image_lte,omitempty"`
	ImageGt            *string                   `json:"image_gt,omitempty"`
	ImageGte           *string                   `json:"image_gte,omitempty"`
	ImageContains      *string                   `json:"image_contains,omitempty"`
	ImageNotContains   *string                   `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                   `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                   `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                   `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                   `json:"image_not_ends_with,omitempty"`
	GenderTarget       *GenderTarget             `json:"genderTarget,omitempty"`
	GenderTargetNot    *GenderTarget             `json:"genderTarget_not,omitempty"`
	GenderTargetIn     []GenderTarget            `json:"genderTarget_in,omitempty"`
	GenderTargetNotIn  []GenderTarget            `json:"genderTarget_not_in,omitempty"`
	Deleted            *bool                     `json:"deleted,omitempty"`
	DeletedNot         *bool                     `json:"deleted_not,omitempty"`
	Active             *bool                     `json:"active,omitempty"`
	ActiveNot          *bool                     `json:"active_not,omitempty"`
	And                []ServiceScalarWhereInput `json:"AND,omitempty"`
	Or                 []ServiceScalarWhereInput `json:"OR,omitempty"`
	Not                []ServiceScalarWhereInput `json:"NOT,omitempty"`
}

type ServiceUpdateManyWithWhereNestedInput struct {
	Where ServiceScalarWhereInput    `json:"where"`
	Data  ServiceUpdateManyDataInput `json:"data"`
}

type ServiceUpdateManyDataInput struct {
	Price        *int32        `json:"price,omitempty"`
	Duration     *int32        `json:"duration,omitempty"`
	Image        *string       `json:"image,omitempty"`
	GenderTarget *GenderTarget `json:"genderTarget,omitempty"`
	Deleted      *bool         `json:"deleted,omitempty"`
	Active       *bool         `json:"active,omitempty"`
}

type ServiceSubCategoryUpsertWithWhereUniqueWithoutCategoryInput struct {
	Where  ServiceSubCategoryWhereUniqueInput               `json:"where"`
	Update ServiceSubCategoryUpdateWithoutCategoryDataInput `json:"update"`
	Create ServiceSubCategoryCreateWithoutCategoryInput     `json:"create"`
}

type ServiceSubCategoryScalarWhereInput struct {
	ID                *string                              `json:"id,omitempty"`
	IDNot             *string                              `json:"id_not,omitempty"`
	IDIn              []string                             `json:"id_in,omitempty"`
	IDNotIn           []string                             `json:"id_not_in,omitempty"`
	IDLt              *string                              `json:"id_lt,omitempty"`
	IDLte             *string                              `json:"id_lte,omitempty"`
	IDGt              *string                              `json:"id_gt,omitempty"`
	IDGte             *string                              `json:"id_gte,omitempty"`
	IDContains        *string                              `json:"id_contains,omitempty"`
	IDNotContains     *string                              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                              `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                              `json:"createdAt,omitempty"`
	CreatedAtNot      *string                              `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                              `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                              `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                              `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                              `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                              `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                              `json:"updatedAt_gte,omitempty"`
	Name              *string                              `json:"name,omitempty"`
	NameNot           *string                              `json:"name_not,omitempty"`
	NameIn            []string                             `json:"name_in,omitempty"`
	NameNotIn         []string                             `json:"name_not_in,omitempty"`
	NameLt            *string                              `json:"name_lt,omitempty"`
	NameLte           *string                              `json:"name_lte,omitempty"`
	NameGt            *string                              `json:"name_gt,omitempty"`
	NameGte           *string                              `json:"name_gte,omitempty"`
	NameContains      *string                              `json:"name_contains,omitempty"`
	NameNotContains   *string                              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                              `json:"name_not_ends_with,omitempty"`
	And               []ServiceSubCategoryScalarWhereInput `json:"AND,omitempty"`
	Or                []ServiceSubCategoryScalarWhereInput `json:"OR,omitempty"`
	Not               []ServiceSubCategoryScalarWhereInput `json:"NOT,omitempty"`
}

type ServiceSubCategoryUpdateManyWithWhereNestedInput struct {
	Where ServiceSubCategoryScalarWhereInput    `json:"where"`
	Data  ServiceSubCategoryUpdateManyDataInput `json:"data"`
}

type ServiceSubCategoryUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
}

type ServiceCategoryUpsertNestedInput struct {
	Update ServiceCategoryUpdateDataInput `json:"update"`
	Create ServiceCategoryCreateInput     `json:"create"`
}

type ServiceUpsertWithoutAttributesInput struct {
	Update ServiceUpdateWithoutAttributesDataInput `json:"update"`
	Create ServiceCreateWithoutAttributesInput     `json:"create"`
}

type ProductServiceAttributeUpsertWithWhereUniqueWithoutProductInput struct {
	Where  ProductServiceAttributeWhereUniqueInput              `json:"where"`
	Update ProductServiceAttributeUpdateWithoutProductDataInput `json:"update"`
	Create ProductServiceAttributeCreateWithoutProductInput     `json:"create"`
}

type ProductUpsertWithWhereUniqueWithoutSubCategoryInput struct {
	Where  ProductWhereUniqueInput                  `json:"where"`
	Update ProductUpdateWithoutSubCategoryDataInput `json:"update"`
	Create ProductCreateWithoutSubCategoryInput     `json:"create"`
}

type ProductScalarWhereInput struct {
	ID                    *string                   `json:"id,omitempty"`
	IDNot                 *string                   `json:"id_not,omitempty"`
	IDIn                  []string                  `json:"id_in,omitempty"`
	IDNotIn               []string                  `json:"id_not_in,omitempty"`
	IDLt                  *string                   `json:"id_lt,omitempty"`
	IDLte                 *string                   `json:"id_lte,omitempty"`
	IDGt                  *string                   `json:"id_gt,omitempty"`
	IDGte                 *string                   `json:"id_gte,omitempty"`
	IDContains            *string                   `json:"id_contains,omitempty"`
	IDNotContains         *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                   `json:"createdAt,omitempty"`
	CreatedAtNot          *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                   `json:"updatedAt_gte,omitempty"`
	Price                 *int32                    `json:"price,omitempty"`
	PriceNot              *int32                    `json:"price_not,omitempty"`
	PriceIn               []int32                   `json:"price_in,omitempty"`
	PriceNotIn            []int32                   `json:"price_not_in,omitempty"`
	PriceLt               *int32                    `json:"price_lt,omitempty"`
	PriceLte              *int32                    `json:"price_lte,omitempty"`
	PriceGt               *int32                    `json:"price_gt,omitempty"`
	PriceGte              *int32                    `json:"price_gte,omitempty"`
	Capacity              *string                   `json:"capacity,omitempty"`
	CapacityNot           *string                   `json:"capacity_not,omitempty"`
	CapacityIn            []string                  `json:"capacity_in,omitempty"`
	CapacityNotIn         []string                  `json:"capacity_not_in,omitempty"`
	CapacityLt            *string                   `json:"capacity_lt,omitempty"`
	CapacityLte           *string                   `json:"capacity_lte,omitempty"`
	CapacityGt            *string                   `json:"capacity_gt,omitempty"`
	CapacityGte           *string                   `json:"capacity_gte,omitempty"`
	CapacityContains      *string                   `json:"capacity_contains,omitempty"`
	CapacityNotContains   *string                   `json:"capacity_not_contains,omitempty"`
	CapacityStartsWith    *string                   `json:"capacity_starts_with,omitempty"`
	CapacityNotStartsWith *string                   `json:"capacity_not_starts_with,omitempty"`
	CapacityEndsWith      *string                   `json:"capacity_ends_with,omitempty"`
	CapacityNotEndsWith   *string                   `json:"capacity_not_ends_with,omitempty"`
	Image                 *string                   `json:"image,omitempty"`
	ImageNot              *string                   `json:"image_not,omitempty"`
	ImageIn               []string                  `json:"image_in,omitempty"`
	ImageNotIn            []string                  `json:"image_not_in,omitempty"`
	ImageLt               *string                   `json:"image_lt,omitempty"`
	ImageLte              *string                   `json:"image_lte,omitempty"`
	ImageGt               *string                   `json:"image_gt,omitempty"`
	ImageGte              *string                   `json:"image_gte,omitempty"`
	ImageContains         *string                   `json:"image_contains,omitempty"`
	ImageNotContains      *string                   `json:"image_not_contains,omitempty"`
	ImageStartsWith       *string                   `json:"image_starts_with,omitempty"`
	ImageNotStartsWith    *string                   `json:"image_not_starts_with,omitempty"`
	ImageEndsWith         *string                   `json:"image_ends_with,omitempty"`
	ImageNotEndsWith      *string                   `json:"image_not_ends_with,omitempty"`
	Deleted               *bool                     `json:"deleted,omitempty"`
	DeletedNot            *bool                     `json:"deleted_not,omitempty"`
	Active                *bool                     `json:"active,omitempty"`
	ActiveNot             *bool                     `json:"active_not,omitempty"`
	And                   []ProductScalarWhereInput `json:"AND,omitempty"`
	Or                    []ProductScalarWhereInput `json:"OR,omitempty"`
	Not                   []ProductScalarWhereInput `json:"NOT,omitempty"`
}

type ProductUpdateManyWithWhereNestedInput struct {
	Where ProductScalarWhereInput    `json:"where"`
	Data  ProductUpdateManyDataInput `json:"data"`
}

type ProductUpdateManyDataInput struct {
	Price    *int32  `json:"price,omitempty"`
	Capacity *string `json:"capacity,omitempty"`
	Image    *string `json:"image,omitempty"`
	Deleted  *bool   `json:"deleted,omitempty"`
	Active   *bool   `json:"active,omitempty"`
}

type ProductSubCategoryUpsertWithWhereUniqueWithoutCategoryInput struct {
	Where  ProductSubCategoryWhereUniqueInput               `json:"where"`
	Update ProductSubCategoryUpdateWithoutCategoryDataInput `json:"update"`
	Create ProductSubCategoryCreateWithoutCategoryInput     `json:"create"`
}

type ProductSubCategoryScalarWhereInput struct {
	ID                *string                              `json:"id,omitempty"`
	IDNot             *string                              `json:"id_not,omitempty"`
	IDIn              []string                             `json:"id_in,omitempty"`
	IDNotIn           []string                             `json:"id_not_in,omitempty"`
	IDLt              *string                              `json:"id_lt,omitempty"`
	IDLte             *string                              `json:"id_lte,omitempty"`
	IDGt              *string                              `json:"id_gt,omitempty"`
	IDGte             *string                              `json:"id_gte,omitempty"`
	IDContains        *string                              `json:"id_contains,omitempty"`
	IDNotContains     *string                              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                              `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string                              `json:"createdAt,omitempty"`
	CreatedAtNot      *string                              `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                              `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                              `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                              `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                              `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                              `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                              `json:"updatedAt_gte,omitempty"`
	Name              *string                              `json:"name,omitempty"`
	NameNot           *string                              `json:"name_not,omitempty"`
	NameIn            []string                             `json:"name_in,omitempty"`
	NameNotIn         []string                             `json:"name_not_in,omitempty"`
	NameLt            *string                              `json:"name_lt,omitempty"`
	NameLte           *string                              `json:"name_lte,omitempty"`
	NameGt            *string                              `json:"name_gt,omitempty"`
	NameGte           *string                              `json:"name_gte,omitempty"`
	NameContains      *string                              `json:"name_contains,omitempty"`
	NameNotContains   *string                              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                              `json:"name_not_ends_with,omitempty"`
	And               []ProductSubCategoryScalarWhereInput `json:"AND,omitempty"`
	Or                []ProductSubCategoryScalarWhereInput `json:"OR,omitempty"`
	Not               []ProductSubCategoryScalarWhereInput `json:"NOT,omitempty"`
}

type ProductSubCategoryUpdateManyWithWhereNestedInput struct {
	Where ProductSubCategoryScalarWhereInput    `json:"where"`
	Data  ProductSubCategoryUpdateManyDataInput `json:"data"`
}

type ProductSubCategoryUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
}

type ProductCategoryUpsertNestedInput struct {
	Update ProductCategoryUpdateDataInput `json:"update"`
	Create ProductCategoryCreateInput     `json:"create"`
}

type ProductUpsertWithoutReviewsInput struct {
	Update ProductUpdateWithoutReviewsDataInput `json:"update"`
	Create ProductCreateWithoutReviewsInput     `json:"create"`
}

type ReviewUpsertWithWhereUniqueWithoutCustomerInput struct {
	Where  ReviewWhereUniqueInput               `json:"where"`
	Update ReviewUpdateWithoutCustomerDataInput `json:"update"`
	Create ReviewCreateWithoutCustomerInput     `json:"create"`
}

type UserUpsertWithWhereUniqueWithoutCompanyInput struct {
	Where  UserWhereUniqueInput              `json:"where"`
	Update UserUpdateWithoutCompanyDataInput `json:"update"`
	Create UserCreateWithoutCompanyInput     `json:"create"`
}

type CompanyUpsertWithoutAliasesInput struct {
	Update CompanyUpdateWithoutAliasesDataInput `json:"update"`
	Create CompanyCreateWithoutAliasesInput     `json:"create"`
}

type AliasUpdateManyMutationInput struct {
	Value *string `json:"value,omitempty"`
}

type AppointmentCreateInput struct {
	ID                           *string                                                  `json:"id,omitempty"`
	Desc                         *LocalizedStringCreateOneInput                           `json:"desc,omitempty"`
	Start                        string                                                   `json:"start"`
	End                          string                                                   `json:"end"`
	Price                        int32                                                    `json:"price"`
	Status                       AppointmentStatus                                        `json:"status"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       BranchCreateOneInput                                     `json:"branch"`
	Company                      *CompanyCreateOneInput                                   `json:"company,omitempty"`
	Employee                     UserCreateOneInput                                       `json:"employee"`
	Customer                     UserCreateOneInput                                       `json:"customer"`
	Products                     *AppointmentProductLinkCreateManyWithoutAppointmentInput `json:"products,omitempty"`
	Services                     *AppointmentServiceLinkCreateManyWithoutAppointmentInput `json:"services,omitempty"`
	Review                       *ReviewCreateOneWithoutAppointmentInput                  `json:"review,omitempty"`
}

type ReviewCreateOneWithoutAppointmentInput struct {
	Create  *ReviewCreateWithoutAppointmentInput `json:"create,omitempty"`
	Connect *ReviewWhereUniqueInput              `json:"connect,omitempty"`
}

type ReviewCreateWithoutAppointmentInput struct {
	ID       *string                              `json:"id,omitempty"`
	Type     ReviewType                           `json:"type"`
	Stars    float64                              `json:"stars"`
	Title    string                               `json:"title"`
	Text     string                               `json:"text"`
	Status   *ReviewStatus                        `json:"status,omitempty"`
	Customer UserCreateOneWithoutReviewsInput     `json:"customer"`
	Product  *ProductCreateOneWithoutReviewsInput `json:"product,omitempty"`
	Service  *ServiceCreateOneWithoutReviewsInput `json:"service,omitempty"`
	Company  *CompanyCreateOneInput               `json:"company,omitempty"`
}

type AppointmentUpdateInput struct {
	Desc                         *LocalizedStringUpdateOneInput                           `json:"desc,omitempty"`
	Start                        *string                                                  `json:"start,omitempty"`
	End                          *string                                                  `json:"end,omitempty"`
	Price                        *int32                                                   `json:"price,omitempty"`
	Status                       *AppointmentStatus                                       `json:"status,omitempty"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       *BranchUpdateOneRequiredInput                            `json:"branch,omitempty"`
	Company                      *CompanyUpdateOneInput                                   `json:"company,omitempty"`
	Employee                     *UserUpdateOneRequiredInput                              `json:"employee,omitempty"`
	Customer                     *UserUpdateOneRequiredInput                              `json:"customer,omitempty"`
	Products                     *AppointmentProductLinkUpdateManyWithoutAppointmentInput `json:"products,omitempty"`
	Services                     *AppointmentServiceLinkUpdateManyWithoutAppointmentInput `json:"services,omitempty"`
	Review                       *ReviewUpdateOneWithoutAppointmentInput                  `json:"review,omitempty"`
}

type ReviewUpdateOneWithoutAppointmentInput struct {
	Create     *ReviewCreateWithoutAppointmentInput     `json:"create,omitempty"`
	Update     *ReviewUpdateWithoutAppointmentDataInput `json:"update,omitempty"`
	Upsert     *ReviewUpsertWithoutAppointmentInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *ReviewWhereUniqueInput                  `json:"connect,omitempty"`
}

type ReviewUpdateWithoutAppointmentDataInput struct {
	Type     *ReviewType                               `json:"type,omitempty"`
	Stars    *float64                                  `json:"stars,omitempty"`
	Title    *string                                   `json:"title,omitempty"`
	Text     *string                                   `json:"text,omitempty"`
	Status   *ReviewStatus                             `json:"status,omitempty"`
	Customer *UserUpdateOneRequiredWithoutReviewsInput `json:"customer,omitempty"`
	Product  *ProductUpdateOneWithoutReviewsInput      `json:"product,omitempty"`
	Service  *ServiceUpdateOneWithoutReviewsInput      `json:"service,omitempty"`
	Company  *CompanyUpdateOneInput                    `json:"company,omitempty"`
}

type ReviewUpsertWithoutAppointmentInput struct {
	Update ReviewUpdateWithoutAppointmentDataInput `json:"update"`
	Create ReviewCreateWithoutAppointmentInput     `json:"create"`
}

type AppointmentUpdateManyMutationInput struct {
	Start                        *string            `json:"start,omitempty"`
	End                          *string            `json:"end,omitempty"`
	Price                        *int32             `json:"price,omitempty"`
	Status                       *AppointmentStatus `json:"status,omitempty"`
	CustomerNotified             *bool              `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool              `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string            `json:"note,omitempty"`
	BeforeImage                  *string            `json:"beforeImage,omitempty"`
	AfterImage                   *string            `json:"afterImage,omitempty"`
}

type AppointmentProductLinkCreateInput struct {
	ID          *string                                  `json:"id,omitempty"`
	Appointment AppointmentCreateOneWithoutProductsInput `json:"appointment"`
	Product     ProductCreateOneInput                    `json:"product"`
	Count       int32                                    `json:"count"`
}

type AppointmentCreateOneWithoutProductsInput struct {
	Create  *AppointmentCreateWithoutProductsInput `json:"create,omitempty"`
	Connect *AppointmentWhereUniqueInput           `json:"connect,omitempty"`
}

type AppointmentCreateWithoutProductsInput struct {
	ID                           *string                                                  `json:"id,omitempty"`
	Desc                         *LocalizedStringCreateOneInput                           `json:"desc,omitempty"`
	Start                        string                                                   `json:"start"`
	End                          string                                                   `json:"end"`
	Price                        int32                                                    `json:"price"`
	Status                       AppointmentStatus                                        `json:"status"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       BranchCreateOneInput                                     `json:"branch"`
	Company                      *CompanyCreateOneInput                                   `json:"company,omitempty"`
	Employee                     UserCreateOneInput                                       `json:"employee"`
	Customer                     UserCreateOneInput                                       `json:"customer"`
	Services                     *AppointmentServiceLinkCreateManyWithoutAppointmentInput `json:"services,omitempty"`
	Review                       *ReviewCreateOneWithoutAppointmentInput                  `json:"review,omitempty"`
}

type AppointmentProductLinkUpdateInput struct {
	Appointment *AppointmentUpdateOneRequiredWithoutProductsInput `json:"appointment,omitempty"`
	Product     *ProductUpdateOneRequiredInput                    `json:"product,omitempty"`
	Count       *int32                                            `json:"count,omitempty"`
}

type AppointmentUpdateOneRequiredWithoutProductsInput struct {
	Create  *AppointmentCreateWithoutProductsInput     `json:"create,omitempty"`
	Update  *AppointmentUpdateWithoutProductsDataInput `json:"update,omitempty"`
	Upsert  *AppointmentUpsertWithoutProductsInput     `json:"upsert,omitempty"`
	Connect *AppointmentWhereUniqueInput               `json:"connect,omitempty"`
}

type AppointmentUpdateWithoutProductsDataInput struct {
	Desc                         *LocalizedStringUpdateOneInput                           `json:"desc,omitempty"`
	Start                        *string                                                  `json:"start,omitempty"`
	End                          *string                                                  `json:"end,omitempty"`
	Price                        *int32                                                   `json:"price,omitempty"`
	Status                       *AppointmentStatus                                       `json:"status,omitempty"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       *BranchUpdateOneRequiredInput                            `json:"branch,omitempty"`
	Company                      *CompanyUpdateOneInput                                   `json:"company,omitempty"`
	Employee                     *UserUpdateOneRequiredInput                              `json:"employee,omitempty"`
	Customer                     *UserUpdateOneRequiredInput                              `json:"customer,omitempty"`
	Services                     *AppointmentServiceLinkUpdateManyWithoutAppointmentInput `json:"services,omitempty"`
	Review                       *ReviewUpdateOneWithoutAppointmentInput                  `json:"review,omitempty"`
}

type AppointmentUpsertWithoutProductsInput struct {
	Update AppointmentUpdateWithoutProductsDataInput `json:"update"`
	Create AppointmentCreateWithoutProductsInput     `json:"create"`
}

type AppointmentProductLinkUpdateManyMutationInput struct {
	Count *int32 `json:"count,omitempty"`
}

type AppointmentServiceLinkCreateInput struct {
	ID          *string                                  `json:"id,omitempty"`
	Appointment AppointmentCreateOneWithoutServicesInput `json:"appointment"`
	Service     ServiceCreateOneInput                    `json:"service"`
}

type AppointmentCreateOneWithoutServicesInput struct {
	Create  *AppointmentCreateWithoutServicesInput `json:"create,omitempty"`
	Connect *AppointmentWhereUniqueInput           `json:"connect,omitempty"`
}

type AppointmentCreateWithoutServicesInput struct {
	ID                           *string                                                  `json:"id,omitempty"`
	Desc                         *LocalizedStringCreateOneInput                           `json:"desc,omitempty"`
	Start                        string                                                   `json:"start"`
	End                          string                                                   `json:"end"`
	Price                        int32                                                    `json:"price"`
	Status                       AppointmentStatus                                        `json:"status"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       BranchCreateOneInput                                     `json:"branch"`
	Company                      *CompanyCreateOneInput                                   `json:"company,omitempty"`
	Employee                     UserCreateOneInput                                       `json:"employee"`
	Customer                     UserCreateOneInput                                       `json:"customer"`
	Products                     *AppointmentProductLinkCreateManyWithoutAppointmentInput `json:"products,omitempty"`
	Review                       *ReviewCreateOneWithoutAppointmentInput                  `json:"review,omitempty"`
}

type AppointmentServiceLinkUpdateInput struct {
	Appointment *AppointmentUpdateOneRequiredWithoutServicesInput `json:"appointment,omitempty"`
	Service     *ServiceUpdateOneRequiredInput                    `json:"service,omitempty"`
}

type AppointmentUpdateOneRequiredWithoutServicesInput struct {
	Create  *AppointmentCreateWithoutServicesInput     `json:"create,omitempty"`
	Update  *AppointmentUpdateWithoutServicesDataInput `json:"update,omitempty"`
	Upsert  *AppointmentUpsertWithoutServicesInput     `json:"upsert,omitempty"`
	Connect *AppointmentWhereUniqueInput               `json:"connect,omitempty"`
}

type AppointmentUpdateWithoutServicesDataInput struct {
	Desc                         *LocalizedStringUpdateOneInput                           `json:"desc,omitempty"`
	Start                        *string                                                  `json:"start,omitempty"`
	End                          *string                                                  `json:"end,omitempty"`
	Price                        *int32                                                   `json:"price,omitempty"`
	Status                       *AppointmentStatus                                       `json:"status,omitempty"`
	CustomerNotified             *bool                                                    `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool                                                    `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string                                                  `json:"note,omitempty"`
	BeforeImage                  *string                                                  `json:"beforeImage,omitempty"`
	AfterImage                   *string                                                  `json:"afterImage,omitempty"`
	Branch                       *BranchUpdateOneRequiredInput                            `json:"branch,omitempty"`
	Company                      *CompanyUpdateOneInput                                   `json:"company,omitempty"`
	Employee                     *UserUpdateOneRequiredInput                              `json:"employee,omitempty"`
	Customer                     *UserUpdateOneRequiredInput                              `json:"customer,omitempty"`
	Products                     *AppointmentProductLinkUpdateManyWithoutAppointmentInput `json:"products,omitempty"`
	Review                       *ReviewUpdateOneWithoutAppointmentInput                  `json:"review,omitempty"`
}

type AppointmentUpsertWithoutServicesInput struct {
	Update AppointmentUpdateWithoutServicesDataInput `json:"update"`
	Create AppointmentCreateWithoutServicesInput     `json:"create"`
}

type BranchUpdateInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput         `json:"name,omitempty"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput         `json:"welcomeMessage,omitempty"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         *string                                        `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                        `json:"imprint,omitempty"`
	Company            *CompanyUpdateOneRequiredWithoutBranchesInput  `json:"company,omitempty"`
	Employees          *UserUpdateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourUpdateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsUpdateManyWithoutBranchInput              `json:"news,omitempty"`
	Slots              *BranchImageSlotUpdateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchUpdateManyMutationInput struct {
	PhoneNumber        *string                  `json:"phoneNumber,omitempty"`
	Address            *string                  `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput `json:"images,omitempty"`
	WebsiteUrl         *string                  `json:"websiteUrl,omitempty"`
	NavigationLink     *string                  `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                  `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                  `json:"imprint,omitempty"`
	Logo               *string                  `json:"logo,omitempty"`
	AppTheme           *string                  `json:"appTheme,omitempty"`
	FacebookLink       *string                  `json:"facebookLink,omitempty"`
	TiktokLink         *string                  `json:"tiktokLink,omitempty"`
	InstagramLink      *string                  `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                  `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                  `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                  `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                  `json:"smtpPassword,omitempty"`
	FromEmail          *string                  `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                  `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                  `json:"mailchimpListId,omitempty"`
}

type BranchImageSlotCreateInput struct {
	ID         *string                           `json:"id,omitempty"`
	SlotNumber int32                             `json:"slotNumber"`
	Branch     *BranchCreateOneWithoutSlotsInput `json:"branch,omitempty"`
	Company    *CompanyCreateOneInput            `json:"company,omitempty"`
	ImageUrl   string                            `json:"imageUrl"`
}

type BranchCreateOneWithoutSlotsInput struct {
	Create  *BranchCreateWithoutSlotsInput `json:"create,omitempty"`
	Connect *BranchWhereUniqueInput        `json:"connect,omitempty"`
}

type BranchCreateWithoutSlotsInput struct {
	ID                 *string                                        `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput                  `json:"name"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     LocalizedStringCreateOneInput                  `json:"welcomeMessage"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchCreateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         string                                         `json:"websiteUrl"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            string                                         `json:"imprint"`
	Company            CompanyCreateOneWithoutBranchesInput           `json:"company"`
	Employees          *UserCreateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourCreateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsCreateManyWithoutBranchInput              `json:"news,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchImageSlotUpdateInput struct {
	SlotNumber *int32                            `json:"slotNumber,omitempty"`
	Branch     *BranchUpdateOneWithoutSlotsInput `json:"branch,omitempty"`
	Company    *CompanyUpdateOneInput            `json:"company,omitempty"`
	ImageUrl   *string                           `json:"imageUrl,omitempty"`
}

type BranchUpdateOneWithoutSlotsInput struct {
	Create     *BranchCreateWithoutSlotsInput     `json:"create,omitempty"`
	Update     *BranchUpdateWithoutSlotsDataInput `json:"update,omitempty"`
	Upsert     *BranchUpsertWithoutSlotsInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *BranchWhereUniqueInput            `json:"connect,omitempty"`
}

type BranchUpdateWithoutSlotsDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput         `json:"name,omitempty"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput         `json:"welcomeMessage,omitempty"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         *string                                        `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                        `json:"imprint,omitempty"`
	Company            *CompanyUpdateOneRequiredWithoutBranchesInput  `json:"company,omitempty"`
	Employees          *UserUpdateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourUpdateManyWithoutBranchInput `json:"openingHours,omitempty"`
	News               *NewsUpdateManyWithoutBranchInput              `json:"news,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchUpsertWithoutSlotsInput struct {
	Update BranchUpdateWithoutSlotsDataInput `json:"update"`
	Create BranchCreateWithoutSlotsInput     `json:"create"`
}

type BranchImageSlotUpdateManyMutationInput struct {
	SlotNumber *int32  `json:"slotNumber,omitempty"`
	ImageUrl   *string `json:"imageUrl,omitempty"`
}

type BranchOpeningHourCreateInput struct {
	ID             *string                                 `json:"id,omitempty"`
	Branch         BranchCreateOneWithoutOpeningHoursInput `json:"branch"`
	Company        *CompanyCreateOneInput                  `json:"company,omitempty"`
	Day            DayOfWeek                               `json:"day"`
	Closed         *bool                                   `json:"closed,omitempty"`
	Break          *bool                                   `json:"break,omitempty"`
	StartForenoon  *string                                 `json:"startForenoon,omitempty"`
	EndForenoon    *string                                 `json:"endForenoon,omitempty"`
	StartAfternoon *string                                 `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                                 `json:"endAfternoon,omitempty"`
}

type BranchCreateOneWithoutOpeningHoursInput struct {
	Create  *BranchCreateWithoutOpeningHoursInput `json:"create,omitempty"`
	Connect *BranchWhereUniqueInput               `json:"connect,omitempty"`
}

type BranchCreateWithoutOpeningHoursInput struct {
	ID                 *string                                      `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput                `json:"name"`
	PhoneNumber        *string                                      `json:"phoneNumber,omitempty"`
	WelcomeMessage     LocalizedStringCreateOneInput                `json:"welcomeMessage"`
	Address            *string                                      `json:"address,omitempty"`
	Images             *BranchCreateimagesInput                     `json:"images,omitempty"`
	WebsiteUrl         string                                       `json:"websiteUrl"`
	NavigationLink     *string                                      `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                      `json:"sharingRedirectUrl,omitempty"`
	Imprint            string                                       `json:"imprint"`
	Company            CompanyCreateOneWithoutBranchesInput         `json:"company"`
	Employees          *UserCreateManyWithoutBranchInput            `json:"employees,omitempty"`
	News               *NewsCreateManyWithoutBranchInput            `json:"news,omitempty"`
	Slots              *BranchImageSlotCreateManyWithoutBranchInput `json:"slots,omitempty"`
	Logo               *string                                      `json:"logo,omitempty"`
	AppTheme           *string                                      `json:"appTheme,omitempty"`
	FacebookLink       *string                                      `json:"facebookLink,omitempty"`
	TiktokLink         *string                                      `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                      `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                      `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                      `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                      `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                      `json:"smtpPassword,omitempty"`
	FromEmail          *string                                      `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                      `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                      `json:"mailchimpListId,omitempty"`
}

type BranchOpeningHourUpdateInput struct {
	Branch         *BranchUpdateOneRequiredWithoutOpeningHoursInput `json:"branch,omitempty"`
	Company        *CompanyUpdateOneInput                           `json:"company,omitempty"`
	Day            *DayOfWeek                                       `json:"day,omitempty"`
	Closed         *bool                                            `json:"closed,omitempty"`
	Break          *bool                                            `json:"break,omitempty"`
	StartForenoon  *string                                          `json:"startForenoon,omitempty"`
	EndForenoon    *string                                          `json:"endForenoon,omitempty"`
	StartAfternoon *string                                          `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                                          `json:"endAfternoon,omitempty"`
}

type BranchUpdateOneRequiredWithoutOpeningHoursInput struct {
	Create  *BranchCreateWithoutOpeningHoursInput     `json:"create,omitempty"`
	Update  *BranchUpdateWithoutOpeningHoursDataInput `json:"update,omitempty"`
	Upsert  *BranchUpsertWithoutOpeningHoursInput     `json:"upsert,omitempty"`
	Connect *BranchWhereUniqueInput                   `json:"connect,omitempty"`
}

type BranchUpdateWithoutOpeningHoursDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput        `json:"name,omitempty"`
	PhoneNumber        *string                                       `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput        `json:"welcomeMessage,omitempty"`
	Address            *string                                       `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                      `json:"images,omitempty"`
	WebsiteUrl         *string                                       `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                       `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                       `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                       `json:"imprint,omitempty"`
	Company            *CompanyUpdateOneRequiredWithoutBranchesInput `json:"company,omitempty"`
	Employees          *UserUpdateManyWithoutBranchInput             `json:"employees,omitempty"`
	News               *NewsUpdateManyWithoutBranchInput             `json:"news,omitempty"`
	Slots              *BranchImageSlotUpdateManyWithoutBranchInput  `json:"slots,omitempty"`
	Logo               *string                                       `json:"logo,omitempty"`
	AppTheme           *string                                       `json:"appTheme,omitempty"`
	FacebookLink       *string                                       `json:"facebookLink,omitempty"`
	TiktokLink         *string                                       `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                       `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                       `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                       `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                       `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                       `json:"smtpPassword,omitempty"`
	FromEmail          *string                                       `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                       `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                       `json:"mailchimpListId,omitempty"`
}

type BranchUpsertWithoutOpeningHoursInput struct {
	Update BranchUpdateWithoutOpeningHoursDataInput `json:"update"`
	Create BranchCreateWithoutOpeningHoursInput     `json:"create"`
}

type BranchOpeningHourUpdateManyMutationInput struct {
	Day            *DayOfWeek `json:"day,omitempty"`
	Closed         *bool      `json:"closed,omitempty"`
	Break          *bool      `json:"break,omitempty"`
	StartForenoon  *string    `json:"startForenoon,omitempty"`
	EndForenoon    *string    `json:"endForenoon,omitempty"`
	StartAfternoon *string    `json:"startAfternoon,omitempty"`
	EndAfternoon   *string    `json:"endAfternoon,omitempty"`
}

type CompanyUpdateInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	CustomUrls         *CustomUrlUpdateManyWithoutCompanyInput `json:"customUrls,omitempty"`
	Aliases            *AliasUpdateManyWithoutCompanyInput     `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                 `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                 `json:"logo,omitempty"`
	AppTheme           *string                                 `json:"appTheme,omitempty"`
	PwaShortName       *LocalizedStringUpdateOneRequiredInput  `json:"pwaShortName,omitempty"`
	PwaIcon            *string                                 `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string                                 `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string                                 `json:"pwaBackgroundColor,omitempty"`
	Users              *UserUpdateManyWithoutCompanyInput      `json:"users,omitempty"`
	Branches           *BranchUpdateManyWithoutCompanyInput    `json:"branches,omitempty"`
}

type CompanyUpdateManyMutationInput struct {
	SharingRedirectUrl *string `json:"sharingRedirectUrl,omitempty"`
	Logo               *string `json:"logo,omitempty"`
	AppTheme           *string `json:"appTheme,omitempty"`
	PwaIcon            *string `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string `json:"pwaBackgroundColor,omitempty"`
}

type CustomUrlCreateInput struct {
	ID      *string                                `json:"id,omitempty"`
	Company CompanyCreateOneWithoutCustomUrlsInput `json:"company"`
	Value   string                                 `json:"value"`
}

type CompanyCreateOneWithoutCustomUrlsInput struct {
	Create  *CompanyCreateWithoutCustomUrlsInput `json:"create,omitempty"`
	Connect *CompanyWhereUniqueInput             `json:"connect,omitempty"`
}

type CompanyCreateWithoutCustomUrlsInput struct {
	ID                 *string                              `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput        `json:"name"`
	Aliases            *AliasCreateManyWithoutCompanyInput  `json:"aliases,omitempty"`
	SharingRedirectUrl *string                              `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                              `json:"logo,omitempty"`
	AppTheme           *string                              `json:"appTheme,omitempty"`
	PwaShortName       LocalizedStringCreateOneInput        `json:"pwaShortName"`
	PwaIcon            *string                              `json:"pwaIcon,omitempty"`
	PwaThemeColor      string                               `json:"pwaThemeColor"`
	PwaBackgroundColor string                               `json:"pwaBackgroundColor"`
	Users              *UserCreateManyWithoutCompanyInput   `json:"users,omitempty"`
	Branches           *BranchCreateManyWithoutCompanyInput `json:"branches,omitempty"`
}

type CustomUrlUpdateInput struct {
	Company *CompanyUpdateOneRequiredWithoutCustomUrlsInput `json:"company,omitempty"`
	Value   *string                                         `json:"value,omitempty"`
}

type CompanyUpdateOneRequiredWithoutCustomUrlsInput struct {
	Create  *CompanyCreateWithoutCustomUrlsInput     `json:"create,omitempty"`
	Update  *CompanyUpdateWithoutCustomUrlsDataInput `json:"update,omitempty"`
	Upsert  *CompanyUpsertWithoutCustomUrlsInput     `json:"upsert,omitempty"`
	Connect *CompanyWhereUniqueInput                 `json:"connect,omitempty"`
}

type CompanyUpdateWithoutCustomUrlsDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput `json:"name,omitempty"`
	Aliases            *AliasUpdateManyWithoutCompanyInput    `json:"aliases,omitempty"`
	SharingRedirectUrl *string                                `json:"sharingRedirectUrl,omitempty"`
	Logo               *string                                `json:"logo,omitempty"`
	AppTheme           *string                                `json:"appTheme,omitempty"`
	PwaShortName       *LocalizedStringUpdateOneRequiredInput `json:"pwaShortName,omitempty"`
	PwaIcon            *string                                `json:"pwaIcon,omitempty"`
	PwaThemeColor      *string                                `json:"pwaThemeColor,omitempty"`
	PwaBackgroundColor *string                                `json:"pwaBackgroundColor,omitempty"`
	Users              *UserUpdateManyWithoutCompanyInput     `json:"users,omitempty"`
	Branches           *BranchUpdateManyWithoutCompanyInput   `json:"branches,omitempty"`
}

type CompanyUpsertWithoutCustomUrlsInput struct {
	Update CompanyUpdateWithoutCustomUrlsDataInput `json:"update"`
	Create CompanyCreateWithoutCustomUrlsInput     `json:"create"`
}

type CustomUrlUpdateManyMutationInput struct {
	Value *string `json:"value,omitempty"`
}

type EmailTemplateCreateInput struct {
	ID      *string                       `json:"id,omitempty"`
	Name    string                        `json:"name"`
	Content LocalizedStringCreateOneInput `json:"content"`
	Title   LocalizedStringCreateOneInput `json:"title"`
	Company *CompanyCreateOneInput        `json:"company,omitempty"`
}

type EmailTemplateUpdateInput struct {
	Name    *string                                `json:"name,omitempty"`
	Content *LocalizedStringUpdateOneRequiredInput `json:"content,omitempty"`
	Title   *LocalizedStringUpdateOneRequiredInput `json:"title,omitempty"`
	Company *CompanyUpdateOneInput                 `json:"company,omitempty"`
}

type EmailTemplateUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type FavoriteCreateInput struct {
	ID      *string                `json:"id,omitempty"`
	User    UserCreateOneInput     `json:"user"`
	Product *ProductCreateOneInput `json:"product,omitempty"`
	Service *ServiceCreateOneInput `json:"service,omitempty"`
	Company *CompanyCreateOneInput `json:"company,omitempty"`
}

type FavoriteUpdateInput struct {
	User    *UserUpdateOneRequiredInput `json:"user,omitempty"`
	Product *ProductUpdateOneInput      `json:"product,omitempty"`
	Service *ServiceUpdateOneInput      `json:"service,omitempty"`
	Company *CompanyUpdateOneInput      `json:"company,omitempty"`
}

type ProductUpdateOneInput struct {
	Create     *ProductCreateInput       `json:"create,omitempty"`
	Update     *ProductUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ProductUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                     `json:"delete,omitempty"`
	Disconnect *bool                     `json:"disconnect,omitempty"`
	Connect    *ProductWhereUniqueInput  `json:"connect,omitempty"`
}

type ServiceUpdateOneInput struct {
	Create     *ServiceCreateInput       `json:"create,omitempty"`
	Update     *ServiceUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ServiceUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                     `json:"delete,omitempty"`
	Disconnect *bool                     `json:"disconnect,omitempty"`
	Connect    *ServiceWhereUniqueInput  `json:"connect,omitempty"`
}

type LocalizedStringUpdateInput struct {
	De *string `json:"de,omitempty"`
	En *string `json:"en,omitempty"`
	Tr *string `json:"tr,omitempty"`
}

type LocalizedStringUpdateManyMutationInput struct {
	De *string `json:"de,omitempty"`
	En *string `json:"en,omitempty"`
	Tr *string `json:"tr,omitempty"`
}

type NewsCreateInput struct {
	ID      *string                         `json:"id,omitempty"`
	Title   LocalizedStringCreateOneInput   `json:"title"`
	Image   *string                         `json:"image,omitempty"`
	Branch  BranchCreateOneWithoutNewsInput `json:"branch"`
	Company *CompanyCreateOneInput          `json:"company,omitempty"`
}

type BranchCreateOneWithoutNewsInput struct {
	Create  *BranchCreateWithoutNewsInput `json:"create,omitempty"`
	Connect *BranchWhereUniqueInput       `json:"connect,omitempty"`
}

type BranchCreateWithoutNewsInput struct {
	ID                 *string                                        `json:"id,omitempty"`
	Name               LocalizedStringCreateOneInput                  `json:"name"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     LocalizedStringCreateOneInput                  `json:"welcomeMessage"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchCreateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         string                                         `json:"websiteUrl"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            string                                         `json:"imprint"`
	Company            CompanyCreateOneWithoutBranchesInput           `json:"company"`
	Employees          *UserCreateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourCreateManyWithoutBranchInput `json:"openingHours,omitempty"`
	Slots              *BranchImageSlotCreateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type NewsUpdateInput struct {
	Title   *LocalizedStringUpdateOneRequiredInput   `json:"title,omitempty"`
	Image   *string                                  `json:"image,omitempty"`
	Branch  *BranchUpdateOneRequiredWithoutNewsInput `json:"branch,omitempty"`
	Company *CompanyUpdateOneInput                   `json:"company,omitempty"`
}

type BranchUpdateOneRequiredWithoutNewsInput struct {
	Create  *BranchCreateWithoutNewsInput     `json:"create,omitempty"`
	Update  *BranchUpdateWithoutNewsDataInput `json:"update,omitempty"`
	Upsert  *BranchUpsertWithoutNewsInput     `json:"upsert,omitempty"`
	Connect *BranchWhereUniqueInput           `json:"connect,omitempty"`
}

type BranchUpdateWithoutNewsDataInput struct {
	Name               *LocalizedStringUpdateOneRequiredInput         `json:"name,omitempty"`
	PhoneNumber        *string                                        `json:"phoneNumber,omitempty"`
	WelcomeMessage     *LocalizedStringUpdateOneRequiredInput         `json:"welcomeMessage,omitempty"`
	Address            *string                                        `json:"address,omitempty"`
	Images             *BranchUpdateimagesInput                       `json:"images,omitempty"`
	WebsiteUrl         *string                                        `json:"websiteUrl,omitempty"`
	NavigationLink     *string                                        `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string                                        `json:"sharingRedirectUrl,omitempty"`
	Imprint            *string                                        `json:"imprint,omitempty"`
	Company            *CompanyUpdateOneRequiredWithoutBranchesInput  `json:"company,omitempty"`
	Employees          *UserUpdateManyWithoutBranchInput              `json:"employees,omitempty"`
	OpeningHours       *BranchOpeningHourUpdateManyWithoutBranchInput `json:"openingHours,omitempty"`
	Slots              *BranchImageSlotUpdateManyWithoutBranchInput   `json:"slots,omitempty"`
	Logo               *string                                        `json:"logo,omitempty"`
	AppTheme           *string                                        `json:"appTheme,omitempty"`
	FacebookLink       *string                                        `json:"facebookLink,omitempty"`
	TiktokLink         *string                                        `json:"tiktokLink,omitempty"`
	InstagramLink      *string                                        `json:"instagramLink,omitempty"`
	SmtpSendHost       *string                                        `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string                                        `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string                                        `json:"smtpUsername,omitempty"`
	SmtpPassword       *string                                        `json:"smtpPassword,omitempty"`
	FromEmail          *string                                        `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string                                        `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string                                        `json:"mailchimpListId,omitempty"`
}

type BranchUpsertWithoutNewsInput struct {
	Update BranchUpdateWithoutNewsDataInput `json:"update"`
	Create BranchCreateWithoutNewsInput     `json:"create"`
}

type NewsUpdateManyMutationInput struct {
	Image *string `json:"image,omitempty"`
}

type PasswordTokenCreateInput struct {
	ID    *string                                `json:"id,omitempty"`
	Token string                                 `json:"token"`
	User  UserCreateOneWithoutPasswordTokenInput `json:"user"`
}

type UserCreateOneWithoutPasswordTokenInput struct {
	Create  *UserCreateWithoutPasswordTokenInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                `json:"connect,omitempty"`
}

type UserCreateWithoutPasswordTokenInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyCreateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewCreateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchCreateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursCreateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionCreateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type PasswordTokenUpdateInput struct {
	Token *string                                         `json:"token,omitempty"`
	User  *UserUpdateOneRequiredWithoutPasswordTokenInput `json:"user,omitempty"`
}

type UserUpdateOneRequiredWithoutPasswordTokenInput struct {
	Create  *UserCreateWithoutPasswordTokenInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutPasswordTokenDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutPasswordTokenInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                    `json:"connect,omitempty"`
}

type UserUpdateWithoutPasswordTokenDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type UserUpsertWithoutPasswordTokenInput struct {
	Update UserUpdateWithoutPasswordTokenDataInput `json:"update"`
	Create UserCreateWithoutPasswordTokenInput     `json:"create"`
}

type PasswordTokenUpdateManyMutationInput struct {
	Token *string `json:"token,omitempty"`
}

type ProductUpdateInput struct {
	Name        *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc        *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price       *int32                                                `json:"price,omitempty"`
	Capacity    *string                                               `json:"capacity,omitempty"`
	Category    *ProductCategoryUpdateOneInput                        `json:"category,omitempty"`
	SubCategory *ProductSubCategoryUpdateOneWithoutProductsInput      `json:"subCategory,omitempty"`
	Image       *string                                               `json:"image,omitempty"`
	Attributes  *ProductServiceAttributeUpdateManyWithoutProductInput `json:"attributes,omitempty"`
	Branch      *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company     *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Reviews     *ReviewUpdateManyWithoutProductInput                  `json:"reviews,omitempty"`
	Deleted     *bool                                                 `json:"deleted,omitempty"`
	Active      *bool                                                 `json:"active,omitempty"`
}

type ProductUpdateManyMutationInput struct {
	Price    *int32  `json:"price,omitempty"`
	Capacity *string `json:"capacity,omitempty"`
	Image    *string `json:"image,omitempty"`
	Deleted  *bool   `json:"deleted,omitempty"`
	Active   *bool   `json:"active,omitempty"`
}

type ProductCategoryUpdateInput struct {
	Name          *string                                           `json:"name,omitempty"`
	SubCategories *ProductSubCategoryUpdateManyWithoutCategoryInput `json:"subCategories,omitempty"`
	Company       *CompanyUpdateOneInput                            `json:"company,omitempty"`
}

type ProductCategoryUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type ProductServiceAttributeCreateInput struct {
	ID      *string                                 `json:"id,omitempty"`
	Service *ServiceCreateOneWithoutAttributesInput `json:"service,omitempty"`
	Product *ProductCreateOneWithoutAttributesInput `json:"product,omitempty"`
	Key     string                                  `json:"key"`
	Name    LocalizedStringCreateOneInput           `json:"name"`
	Value   LocalizedStringCreateOneInput           `json:"value"`
	Company *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type ProductServiceAttributeUpdateInput struct {
	Service *ServiceUpdateOneWithoutAttributesInput `json:"service,omitempty"`
	Product *ProductUpdateOneWithoutAttributesInput `json:"product,omitempty"`
	Key     *string                                 `json:"key,omitempty"`
	Name    *LocalizedStringUpdateOneRequiredInput  `json:"name,omitempty"`
	Value   *LocalizedStringUpdateOneRequiredInput  `json:"value,omitempty"`
	Company *CompanyUpdateOneInput                  `json:"company,omitempty"`
}

type ProductServiceAttributeUpdateManyMutationInput struct {
	Key *string `json:"key,omitempty"`
}

type ProductSubCategoryCreateInput struct {
	ID       *string                                            `json:"id,omitempty"`
	Name     string                                             `json:"name"`
	Category *ProductCategoryCreateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Products *ProductCreateManyWithoutSubCategoryInput          `json:"products,omitempty"`
	Company  *CompanyCreateOneInput                             `json:"company,omitempty"`
}

type ProductSubCategoryUpdateInput struct {
	Name     *string                                            `json:"name,omitempty"`
	Category *ProductCategoryUpdateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Products *ProductUpdateManyWithoutSubCategoryInput          `json:"products,omitempty"`
	Company  *CompanyUpdateOneInput                             `json:"company,omitempty"`
}

type ProductSubCategoryUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type ReviewCreateInput struct {
	ID          *string                                 `json:"id,omitempty"`
	Type        ReviewType                              `json:"type"`
	Stars       float64                                 `json:"stars"`
	Title       string                                  `json:"title"`
	Text        string                                  `json:"text"`
	Status      *ReviewStatus                           `json:"status,omitempty"`
	Customer    UserCreateOneWithoutReviewsInput        `json:"customer"`
	Product     *ProductCreateOneWithoutReviewsInput    `json:"product,omitempty"`
	Service     *ServiceCreateOneWithoutReviewsInput    `json:"service,omitempty"`
	Appointment *AppointmentCreateOneWithoutReviewInput `json:"appointment,omitempty"`
	Company     *CompanyCreateOneInput                  `json:"company,omitempty"`
}

type ReviewUpdateInput struct {
	Type        *ReviewType                               `json:"type,omitempty"`
	Stars       *float64                                  `json:"stars,omitempty"`
	Title       *string                                   `json:"title,omitempty"`
	Text        *string                                   `json:"text,omitempty"`
	Status      *ReviewStatus                             `json:"status,omitempty"`
	Customer    *UserUpdateOneRequiredWithoutReviewsInput `json:"customer,omitempty"`
	Product     *ProductUpdateOneWithoutReviewsInput      `json:"product,omitempty"`
	Service     *ServiceUpdateOneWithoutReviewsInput      `json:"service,omitempty"`
	Appointment *AppointmentUpdateOneWithoutReviewInput   `json:"appointment,omitempty"`
	Company     *CompanyUpdateOneInput                    `json:"company,omitempty"`
}

type ReviewUpdateManyMutationInput struct {
	Type   *ReviewType   `json:"type,omitempty"`
	Stars  *float64      `json:"stars,omitempty"`
	Title  *string       `json:"title,omitempty"`
	Text   *string       `json:"text,omitempty"`
	Status *ReviewStatus `json:"status,omitempty"`
}

type ServiceUpdateInput struct {
	Name         *LocalizedStringUpdateOneRequiredInput                `json:"name,omitempty"`
	Desc         *LocalizedStringUpdateOneRequiredInput                `json:"desc,omitempty"`
	Price        *int32                                                `json:"price,omitempty"`
	Duration     *int32                                                `json:"duration,omitempty"`
	Image        *string                                               `json:"image,omitempty"`
	GenderTarget *GenderTarget                                         `json:"genderTarget,omitempty"`
	Attributes   *ProductServiceAttributeUpdateManyWithoutServiceInput `json:"attributes,omitempty"`
	Category     *ServiceCategoryUpdateOneInput                        `json:"category,omitempty"`
	SubCategory  *ServiceSubCategoryUpdateOneWithoutServicesInput      `json:"subCategory,omitempty"`
	Branch       *BranchUpdateOneRequiredInput                         `json:"branch,omitempty"`
	Company      *CompanyUpdateOneInput                                `json:"company,omitempty"`
	Reviews      *ReviewUpdateManyWithoutServiceInput                  `json:"reviews,omitempty"`
	Deleted      *bool                                                 `json:"deleted,omitempty"`
	Active       *bool                                                 `json:"active,omitempty"`
}

type ServiceUpdateManyMutationInput struct {
	Price        *int32        `json:"price,omitempty"`
	Duration     *int32        `json:"duration,omitempty"`
	Image        *string       `json:"image,omitempty"`
	GenderTarget *GenderTarget `json:"genderTarget,omitempty"`
	Deleted      *bool         `json:"deleted,omitempty"`
	Active       *bool         `json:"active,omitempty"`
}

type ServiceCategoryUpdateInput struct {
	Name          *string                                           `json:"name,omitempty"`
	SubCategories *ServiceSubCategoryUpdateManyWithoutCategoryInput `json:"subCategories,omitempty"`
	Company       *CompanyUpdateOneInput                            `json:"company,omitempty"`
}

type ServiceCategoryUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type ServiceSubCategoryCreateInput struct {
	ID       *string                                            `json:"id,omitempty"`
	Name     string                                             `json:"name"`
	Category *ServiceCategoryCreateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Company  *CompanyCreateOneInput                             `json:"company,omitempty"`
	Services *ServiceCreateManyWithoutSubCategoryInput          `json:"services,omitempty"`
}

type ServiceSubCategoryUpdateInput struct {
	Name     *string                                            `json:"name,omitempty"`
	Category *ServiceCategoryUpdateOneWithoutSubCategoriesInput `json:"category,omitempty"`
	Company  *CompanyUpdateOneInput                             `json:"company,omitempty"`
	Services *ServiceUpdateManyWithoutSubCategoryInput          `json:"services,omitempty"`
}

type ServiceSubCategoryUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type SessionCreateInput struct {
	ID      *string                           `json:"id,omitempty"`
	Token   string                            `json:"token"`
	User    UserCreateOneWithoutSessionsInput `json:"user"`
	Company *CompanyCreateOneInput            `json:"company,omitempty"`
}

type UserCreateOneWithoutSessionsInput struct {
	Create  *UserCreateWithoutSessionsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserCreateWithoutSessionsInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyCreateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewCreateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchCreateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursCreateManyWithoutUserInput `json:"workingHours,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenCreateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type SessionUpdateInput struct {
	Token   *string                                    `json:"token,omitempty"`
	User    *UserUpdateOneRequiredWithoutSessionsInput `json:"user,omitempty"`
	Company *CompanyUpdateOneInput                     `json:"company,omitempty"`
}

type UserUpdateOneRequiredWithoutSessionsInput struct {
	Create  *UserCreateWithoutSessionsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutSessionsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutSessionsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserUpdateWithoutSessionsDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type UserUpsertWithoutSessionsInput struct {
	Update UserUpdateWithoutSessionsDataInput `json:"update"`
	Create UserCreateWithoutSessionsInput     `json:"create"`
}

type SessionUpdateManyMutationInput struct {
	Token *string `json:"token,omitempty"`
}

type UserUpdateInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	WorkingHours       *WorkingHoursUpdateManyWithoutUserInput `json:"workingHours,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Type               *UserType `json:"type,omitempty"`
	Email              *string   `json:"email,omitempty"`
	PasswordHash       *string   `json:"passwordHash,omitempty"`
	FirstName          *string   `json:"firstName,omitempty"`
	LastName           *string   `json:"lastName,omitempty"`
	Gender             *Gender   `json:"gender,omitempty"`
	ZipCode            *string   `json:"zipCode,omitempty"`
	Street             *string   `json:"street,omitempty"`
	City               *string   `json:"city,omitempty"`
	Birthday           *string   `json:"birthday,omitempty"`
	Birthdate          *string   `json:"birthdate,omitempty"`
	PhoneNumber        *string   `json:"phoneNumber,omitempty"`
	Image              *string   `json:"image,omitempty"`
	Note               *string   `json:"note,omitempty"`
	AllowReviewSharing *bool     `json:"allowReviewSharing,omitempty"`
	NotificationToken  *string   `json:"notificationToken,omitempty"`
	Language           *string   `json:"language,omitempty"`
	Deleted            *bool     `json:"deleted,omitempty"`
	Activated          *bool     `json:"activated,omitempty"`
	ActivateToken      *string   `json:"activateToken,omitempty"`
}

type WorkingHoursCreateInput struct {
	ID             *string                               `json:"id,omitempty"`
	User           UserCreateOneWithoutWorkingHoursInput `json:"user"`
	Day            DayOfWeek                             `json:"day"`
	NotWorking     *bool                                 `json:"notWorking,omitempty"`
	Break          *bool                                 `json:"break,omitempty"`
	StartForenoon  *string                               `json:"startForenoon,omitempty"`
	EndForenoon    *string                               `json:"endForenoon,omitempty"`
	StartAfternoon *string                               `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                               `json:"endAfternoon,omitempty"`
	Company        *CompanyCreateOneInput                `json:"company,omitempty"`
	Status         *AvailabilityStatus                   `json:"status,omitempty"`
}

type UserCreateOneWithoutWorkingHoursInput struct {
	Create  *UserCreateWithoutWorkingHoursInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutWorkingHoursInput struct {
	ID                 *string                                 `json:"id,omitempty"`
	Type               UserType                                `json:"type"`
	Email              string                                  `json:"email"`
	PasswordHash       string                                  `json:"passwordHash"`
	FirstName          string                                  `json:"firstName"`
	LastName           string                                  `json:"lastName"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyCreateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewCreateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchCreateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	Sessions           *SessionCreateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenCreateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type WorkingHoursUpdateInput struct {
	User           *UserUpdateOneRequiredWithoutWorkingHoursInput `json:"user,omitempty"`
	Day            *DayOfWeek                                     `json:"day,omitempty"`
	NotWorking     *bool                                          `json:"notWorking,omitempty"`
	Break          *bool                                          `json:"break,omitempty"`
	StartForenoon  *string                                        `json:"startForenoon,omitempty"`
	EndForenoon    *string                                        `json:"endForenoon,omitempty"`
	StartAfternoon *string                                        `json:"startAfternoon,omitempty"`
	EndAfternoon   *string                                        `json:"endAfternoon,omitempty"`
	Company        *CompanyUpdateOneInput                         `json:"company,omitempty"`
	Status         *AvailabilityStatus                            `json:"status,omitempty"`
}

type UserUpdateOneRequiredWithoutWorkingHoursInput struct {
	Create  *UserCreateWithoutWorkingHoursInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutWorkingHoursDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutWorkingHoursInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserUpdateWithoutWorkingHoursDataInput struct {
	Type               *UserType                               `json:"type,omitempty"`
	Email              *string                                 `json:"email,omitempty"`
	PasswordHash       *string                                 `json:"passwordHash,omitempty"`
	FirstName          *string                                 `json:"firstName,omitempty"`
	LastName           *string                                 `json:"lastName,omitempty"`
	Gender             *Gender                                 `json:"gender,omitempty"`
	ZipCode            *string                                 `json:"zipCode,omitempty"`
	Street             *string                                 `json:"street,omitempty"`
	City               *string                                 `json:"city,omitempty"`
	Birthday           *string                                 `json:"birthday,omitempty"`
	Birthdate          *string                                 `json:"birthdate,omitempty"`
	PhoneNumber        *string                                 `json:"phoneNumber,omitempty"`
	Image              *string                                 `json:"image,omitempty"`
	Company            *CompanyUpdateOneWithoutUsersInput      `json:"company,omitempty"`
	Note               *string                                 `json:"note,omitempty"`
	Reviews            *ReviewUpdateManyWithoutCustomerInput   `json:"reviews,omitempty"`
	AllowReviewSharing *bool                                   `json:"allowReviewSharing,omitempty"`
	Branch             *BranchUpdateOneWithoutEmployeesInput   `json:"branch,omitempty"`
	Sessions           *SessionUpdateManyWithoutUserInput      `json:"sessions,omitempty"`
	NotificationToken  *string                                 `json:"notificationToken,omitempty"`
	Language           *string                                 `json:"language,omitempty"`
	PasswordToken      *PasswordTokenUpdateOneWithoutUserInput `json:"passwordToken,omitempty"`
	Deleted            *bool                                   `json:"deleted,omitempty"`
	Activated          *bool                                   `json:"activated,omitempty"`
	ActivateToken      *string                                 `json:"activateToken,omitempty"`
}

type UserUpsertWithoutWorkingHoursInput struct {
	Update UserUpdateWithoutWorkingHoursDataInput `json:"update"`
	Create UserCreateWithoutWorkingHoursInput     `json:"create"`
}

type WorkingHoursUpdateManyMutationInput struct {
	Day            *DayOfWeek          `json:"day,omitempty"`
	NotWorking     *bool               `json:"notWorking,omitempty"`
	Break          *bool               `json:"break,omitempty"`
	StartForenoon  *string             `json:"startForenoon,omitempty"`
	EndForenoon    *string             `json:"endForenoon,omitempty"`
	StartAfternoon *string             `json:"startAfternoon,omitempty"`
	EndAfternoon   *string             `json:"endAfternoon,omitempty"`
	Status         *AvailabilityStatus `json:"status,omitempty"`
}

type AliasSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *AliasWhereInput              `json:"node,omitempty"`
	And                        []AliasSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AliasSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AliasSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AppointmentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *AppointmentWhereInput              `json:"node,omitempty"`
	And                        []AppointmentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AppointmentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AppointmentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AppointmentProductLinkSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *AppointmentProductLinkWhereInput              `json:"node,omitempty"`
	And                        []AppointmentProductLinkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AppointmentProductLinkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AppointmentProductLinkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AppointmentServiceLinkSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *AppointmentServiceLinkWhereInput              `json:"node,omitempty"`
	And                        []AppointmentServiceLinkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AppointmentServiceLinkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AppointmentServiceLinkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BranchSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *BranchWhereInput              `json:"node,omitempty"`
	And                        []BranchSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BranchSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BranchSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BranchImageSlotSubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *BranchImageSlotWhereInput              `json:"node,omitempty"`
	And                        []BranchImageSlotSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BranchImageSlotSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BranchImageSlotSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BranchOpeningHourSubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *BranchOpeningHourWhereInput              `json:"node,omitempty"`
	And                        []BranchOpeningHourSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BranchOpeningHourSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BranchOpeningHourSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CompanySubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *CompanyWhereInput              `json:"node,omitempty"`
	And                        []CompanySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CompanySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CompanySubscriptionWhereInput `json:"NOT,omitempty"`
}

type CustomUrlSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *CustomUrlWhereInput              `json:"node,omitempty"`
	And                        []CustomUrlSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CustomUrlSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CustomUrlSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EmailTemplateSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *EmailTemplateWhereInput              `json:"node,omitempty"`
	And                        []EmailTemplateSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EmailTemplateSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EmailTemplateSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FavoriteSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *FavoriteWhereInput              `json:"node,omitempty"`
	And                        []FavoriteSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FavoriteSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FavoriteSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LocalizedStringSubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *LocalizedStringWhereInput              `json:"node,omitempty"`
	And                        []LocalizedStringSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LocalizedStringSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LocalizedStringSubscriptionWhereInput `json:"NOT,omitempty"`
}

type NewsSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *NewsWhereInput              `json:"node,omitempty"`
	And                        []NewsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []NewsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []NewsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PasswordTokenSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *PasswordTokenWhereInput              `json:"node,omitempty"`
	And                        []PasswordTokenSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PasswordTokenSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PasswordTokenSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ProductSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProductWhereInput              `json:"node,omitempty"`
	And                        []ProductSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ProductSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ProductSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ProductCategorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProductCategoryWhereInput              `json:"node,omitempty"`
	And                        []ProductCategorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ProductCategorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ProductCategorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type ProductServiceAttributeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProductServiceAttributeWhereInput              `json:"node,omitempty"`
	And                        []ProductServiceAttributeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ProductServiceAttributeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ProductServiceAttributeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ProductSubCategorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                             `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                    `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                   `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                   `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProductSubCategoryWhereInput              `json:"node,omitempty"`
	And                        []ProductSubCategorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ProductSubCategorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ProductSubCategorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewWhereInput              `json:"node,omitempty"`
	And                        []ReviewSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ServiceSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ServiceWhereInput              `json:"node,omitempty"`
	And                        []ServiceSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ServiceSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ServiceSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ServiceCategorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *ServiceCategoryWhereInput              `json:"node,omitempty"`
	And                        []ServiceCategorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ServiceCategorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ServiceCategorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type ServiceSubCategorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                             `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                    `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                   `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                   `json:"updatedFields_contains_some,omitempty"`
	Node                       *ServiceSubCategoryWhereInput              `json:"node,omitempty"`
	And                        []ServiceSubCategorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ServiceSubCategorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ServiceSubCategorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type SessionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *SessionWhereInput              `json:"node,omitempty"`
	And                        []SessionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SessionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SessionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WorkingHoursSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *WorkingHoursWhereInput              `json:"node,omitempty"`
	And                        []WorkingHoursSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WorkingHoursSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WorkingHoursSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AliasExec struct {
	exec *prisma.Exec
}

func (instance *AliasExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance AliasExec) Exec(ctx context.Context) (*Alias, error) {
	var v Alias
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AliasExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AliasExecArray struct {
	exec *prisma.Exec
}

func (instance AliasExecArray) Exec(ctx context.Context) ([]Alias, error) {
	var v []Alias
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AliasFields = []string{"id", "value"}

type Alias struct {
	ID    string `json:"id"`
	Value string `json:"value"`
}

type CompanyExec struct {
	exec *prisma.Exec
}

func (instance *CompanyExec) Name() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"name",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

type CustomUrlsParamsExec struct {
	Where   *CustomUrlWhereInput
	OrderBy *CustomUrlOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CompanyExec) CustomUrls(params *CustomUrlsParamsExec) *CustomUrlExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CustomUrlWhereInput", "CustomUrlOrderByInput", "CustomUrl"},
		"customUrls",
		[]string{"id", "value"})

	return &CustomUrlExecArray{ret}
}

type AliasesParamsExec struct {
	Where   *AliasWhereInput
	OrderBy *AliasOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CompanyExec) Aliases(params *AliasesParamsExec) *AliasExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AliasWhereInput", "AliasOrderByInput", "Alias"},
		"aliases",
		[]string{"id", "value"})

	return &AliasExecArray{ret}
}

func (instance *CompanyExec) PwaShortName() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"pwaShortName",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

type UsersParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CompanyExec) Users(params *UsersParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExecArray{ret}
}

type BranchesParamsExec struct {
	Where   *BranchWhereInput
	OrderBy *BranchOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CompanyExec) Branches(params *BranchesParamsExec) *BranchExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"BranchWhereInput", "BranchOrderByInput", "Branch"},
		"branches",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExecArray{ret}
}

func (instance CompanyExec) Exec(ctx context.Context) (*Company, error) {
	var v Company
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyExecArray) Exec(ctx context.Context) ([]Company, error) {
	var v []Company
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyFields = []string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"}

type Company struct {
	ID                 string  `json:"id"`
	CreatedAt          string  `json:"createdAt"`
	UpdatedAt          string  `json:"updatedAt"`
	SharingRedirectUrl *string `json:"sharingRedirectUrl,omitempty"`
	Logo               *string `json:"logo,omitempty"`
	AppTheme           *string `json:"appTheme,omitempty"`
	PwaIcon            *string `json:"pwaIcon,omitempty"`
	PwaThemeColor      string  `json:"pwaThemeColor"`
	PwaBackgroundColor string  `json:"pwaBackgroundColor"`
}

type LocalizedStringExec struct {
	exec *prisma.Exec
}

func (instance LocalizedStringExec) Exec(ctx context.Context) (*LocalizedString, error) {
	var v LocalizedString
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocalizedStringExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocalizedStringExecArray struct {
	exec *prisma.Exec
}

func (instance LocalizedStringExecArray) Exec(ctx context.Context) ([]LocalizedString, error) {
	var v []LocalizedString
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LocalizedStringFields = []string{"id", "de", "en", "tr"}

type LocalizedString struct {
	ID string  `json:"id"`
	De *string `json:"de,omitempty"`
	En *string `json:"en,omitempty"`
	Tr *string `json:"tr,omitempty"`
}

type CustomUrlExec struct {
	exec *prisma.Exec
}

func (instance *CustomUrlExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance CustomUrlExec) Exec(ctx context.Context) (*CustomUrl, error) {
	var v CustomUrl
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CustomUrlExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CustomUrlExecArray struct {
	exec *prisma.Exec
}

func (instance CustomUrlExecArray) Exec(ctx context.Context) ([]CustomUrl, error) {
	var v []CustomUrl
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CustomUrlFields = []string{"id", "value"}

type CustomUrl struct {
	ID    string `json:"id"`
	Value string `json:"value"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance *UserExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

type ReviewsParamsExec struct {
	Where   *ReviewWhereInput
	OrderBy *ReviewOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Reviews(params *ReviewsParamsExec) *ReviewExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewWhereInput", "ReviewOrderByInput", "Review"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExecArray{ret}
}

func (instance *UserExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

type WorkingHoursParamsExec struct {
	Where   *WorkingHoursWhereInput
	OrderBy *WorkingHoursOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) WorkingHours(params *WorkingHoursParamsExec) *WorkingHoursExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"WorkingHoursWhereInput", "WorkingHoursOrderByInput", "WorkingHours"},
		"workingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExecArray{ret}
}

type SessionsParamsExec struct {
	Where   *SessionWhereInput
	OrderBy *SessionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Sessions(params *SessionsParamsExec) *SessionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessions",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExecArray{ret}
}

func (instance *UserExec) PasswordToken() *PasswordTokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PasswordToken"},
		"passwordToken",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"}

type User struct {
	ID                 string   `json:"id"`
	CreatedAt          string   `json:"createdAt"`
	UpdatedAt          string   `json:"updatedAt"`
	Type               UserType `json:"type"`
	Email              string   `json:"email"`
	PasswordHash       string   `json:"passwordHash"`
	FirstName          string   `json:"firstName"`
	LastName           string   `json:"lastName"`
	Gender             Gender   `json:"gender"`
	ZipCode            *string  `json:"zipCode,omitempty"`
	Street             *string  `json:"street,omitempty"`
	City               *string  `json:"city,omitempty"`
	Birthday           *string  `json:"birthday,omitempty"`
	Birthdate          *string  `json:"birthdate,omitempty"`
	PhoneNumber        *string  `json:"phoneNumber,omitempty"`
	Image              *string  `json:"image,omitempty"`
	Note               *string  `json:"note,omitempty"`
	AllowReviewSharing bool     `json:"allowReviewSharing"`
	NotificationToken  *string  `json:"notificationToken,omitempty"`
	Language           *string  `json:"language,omitempty"`
	Deleted            bool     `json:"deleted"`
	Activated          bool     `json:"activated"`
	ActivateToken      *string  `json:"activateToken,omitempty"`
}

type ReviewExec struct {
	exec *prisma.Exec
}

func (instance *ReviewExec) Customer() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"customer",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *ReviewExec) Product() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"product",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (instance *ReviewExec) Service() *ServiceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Service"},
		"service",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (instance *ReviewExec) Appointment() *AppointmentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Appointment"},
		"appointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (instance *ReviewExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance ReviewExec) Exec(ctx context.Context) (*Review, error) {
	var v Review
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewExecArray) Exec(ctx context.Context) ([]Review, error) {
	var v []Review
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewFields = []string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"}

type Review struct {
	ID        string       `json:"id"`
	CreatedAt string       `json:"createdAt"`
	UpdatedAt string       `json:"updatedAt"`
	Type      ReviewType   `json:"type"`
	Stars     float64      `json:"stars"`
	Title     string       `json:"title"`
	Text      string       `json:"text"`
	Status    ReviewStatus `json:"status"`
}

type ProductExec struct {
	exec *prisma.Exec
}

func (instance *ProductExec) Name() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"name",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *ProductExec) Desc() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"desc",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *ProductExec) Category() *ProductCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductCategory"},
		"category",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

func (instance *ProductExec) SubCategory() *ProductSubCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductSubCategory"},
		"subCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

type AttributesParamsExec struct {
	Where   *ProductServiceAttributeWhereInput
	OrderBy *ProductServiceAttributeOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ProductExec) Attributes(params *AttributesParamsExec) *ProductServiceAttributeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ProductServiceAttributeWhereInput", "ProductServiceAttributeOrderByInput", "ProductServiceAttribute"},
		"attributes",
		[]string{"id", "key"})

	return &ProductServiceAttributeExecArray{ret}
}

func (instance *ProductExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *ProductExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance *ProductExec) Reviews(params *ReviewsParamsExec) *ReviewExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewWhereInput", "ReviewOrderByInput", "Review"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExecArray{ret}
}

func (instance ProductExec) Exec(ctx context.Context) (*Product, error) {
	var v Product
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductExecArray struct {
	exec *prisma.Exec
}

func (instance ProductExecArray) Exec(ctx context.Context) ([]Product, error) {
	var v []Product
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductFields = []string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"}

type Product struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Price     int32   `json:"price"`
	Capacity  *string `json:"capacity,omitempty"`
	Image     *string `json:"image,omitempty"`
	Deleted   bool    `json:"deleted"`
	Active    bool    `json:"active"`
}

type ProductCategoryExec struct {
	exec *prisma.Exec
}

type SubCategoriesParamsExec struct {
	Where   *ProductSubCategoryWhereInput
	OrderBy *ProductSubCategoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ProductCategoryExec) SubCategories(params *SubCategoriesParamsExec) *ProductSubCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ProductSubCategoryWhereInput", "ProductSubCategoryOrderByInput", "ProductSubCategory"},
		"subCategories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExecArray{ret}
}

func (instance *ProductCategoryExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance ProductCategoryExec) Exec(ctx context.Context) (*ProductCategory, error) {
	var v ProductCategory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductCategoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductCategoryExecArray struct {
	exec *prisma.Exec
}

func (instance ProductCategoryExecArray) Exec(ctx context.Context) ([]ProductCategory, error) {
	var v []ProductCategory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductCategoryFields = []string{"id", "createdAt", "updatedAt", "name"}

type ProductCategory struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ProductSubCategoryExec struct {
	exec *prisma.Exec
}

func (instance *ProductSubCategoryExec) Category() *ProductCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductCategory"},
		"category",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

type ProductsParamsExec struct {
	Where   *ProductWhereInput
	OrderBy *ProductOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ProductSubCategoryExec) Products(params *ProductsParamsExec) *ProductExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "Product"},
		"products",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExecArray{ret}
}

func (instance *ProductSubCategoryExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance ProductSubCategoryExec) Exec(ctx context.Context) (*ProductSubCategory, error) {
	var v ProductSubCategory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductSubCategoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubCategoryExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubCategoryExecArray) Exec(ctx context.Context) ([]ProductSubCategory, error) {
	var v []ProductSubCategory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductSubCategoryFields = []string{"id", "createdAt", "updatedAt", "name"}

type ProductSubCategory struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ProductServiceAttributeExec struct {
	exec *prisma.Exec
}

func (instance *ProductServiceAttributeExec) Service() *ServiceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Service"},
		"service",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (instance *ProductServiceAttributeExec) Product() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"product",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (instance *ProductServiceAttributeExec) Name() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"name",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *ProductServiceAttributeExec) Value() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"value",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *ProductServiceAttributeExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance ProductServiceAttributeExec) Exec(ctx context.Context) (*ProductServiceAttribute, error) {
	var v ProductServiceAttribute
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductServiceAttributeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductServiceAttributeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductServiceAttributeExecArray) Exec(ctx context.Context) ([]ProductServiceAttribute, error) {
	var v []ProductServiceAttribute
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductServiceAttributeFields = []string{"id", "key"}

type ProductServiceAttribute struct {
	ID  string `json:"id"`
	Key string `json:"key"`
}

type ServiceExec struct {
	exec *prisma.Exec
}

func (instance *ServiceExec) Name() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"name",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *ServiceExec) Desc() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"desc",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *ServiceExec) Attributes(params *AttributesParamsExec) *ProductServiceAttributeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ProductServiceAttributeWhereInput", "ProductServiceAttributeOrderByInput", "ProductServiceAttribute"},
		"attributes",
		[]string{"id", "key"})

	return &ProductServiceAttributeExecArray{ret}
}

func (instance *ServiceExec) Category() *ServiceCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceCategory"},
		"category",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

func (instance *ServiceExec) SubCategory() *ServiceSubCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceSubCategory"},
		"subCategory",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

func (instance *ServiceExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *ServiceExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance *ServiceExec) Reviews(params *ReviewsParamsExec) *ReviewExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewWhereInput", "ReviewOrderByInput", "Review"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExecArray{ret}
}

func (instance ServiceExec) Exec(ctx context.Context) (*Service, error) {
	var v Service
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceExecArray) Exec(ctx context.Context) ([]Service, error) {
	var v []Service
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceFields = []string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"}

type Service struct {
	ID           string       `json:"id"`
	CreatedAt    string       `json:"createdAt"`
	UpdatedAt    string       `json:"updatedAt"`
	Price        int32        `json:"price"`
	Duration     int32        `json:"duration"`
	Image        *string      `json:"image,omitempty"`
	GenderTarget GenderTarget `json:"genderTarget"`
	Deleted      bool         `json:"deleted"`
	Active       bool         `json:"active"`
}

type ServiceCategoryExec struct {
	exec *prisma.Exec
}

func (instance *ServiceCategoryExec) SubCategories(params *SubCategoriesParamsExec) *ServiceSubCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ServiceSubCategoryWhereInput", "ServiceSubCategoryOrderByInput", "ServiceSubCategory"},
		"subCategories",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExecArray{ret}
}

func (instance *ServiceCategoryExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance ServiceCategoryExec) Exec(ctx context.Context) (*ServiceCategory, error) {
	var v ServiceCategory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceCategoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceCategoryExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceCategoryExecArray) Exec(ctx context.Context) ([]ServiceCategory, error) {
	var v []ServiceCategory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceCategoryFields = []string{"id", "createdAt", "updatedAt", "name"}

type ServiceCategory struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ServiceSubCategoryExec struct {
	exec *prisma.Exec
}

func (instance *ServiceSubCategoryExec) Category() *ServiceCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceCategory"},
		"category",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

func (instance *ServiceSubCategoryExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

type ServicesParamsExec struct {
	Where   *ServiceWhereInput
	OrderBy *ServiceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ServiceSubCategoryExec) Services(params *ServicesParamsExec) *ServiceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ServiceWhereInput", "ServiceOrderByInput", "Service"},
		"services",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExecArray{ret}
}

func (instance ServiceSubCategoryExec) Exec(ctx context.Context) (*ServiceSubCategory, error) {
	var v ServiceSubCategory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceSubCategoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceSubCategoryExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceSubCategoryExecArray) Exec(ctx context.Context) ([]ServiceSubCategory, error) {
	var v []ServiceSubCategory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceSubCategoryFields = []string{"id", "createdAt", "updatedAt", "name"}

type ServiceSubCategory struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type BranchExec struct {
	exec *prisma.Exec
}

func (instance *BranchExec) Name() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"name",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *BranchExec) WelcomeMessage() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"welcomeMessage",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *BranchExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

type EmployeesParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *BranchExec) Employees(params *EmployeesParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"employees",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExecArray{ret}
}

type OpeningHoursParamsExec struct {
	Where   *BranchOpeningHourWhereInput
	OrderBy *BranchOpeningHourOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *BranchExec) OpeningHours(params *OpeningHoursParamsExec) *BranchOpeningHourExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"BranchOpeningHourWhereInput", "BranchOpeningHourOrderByInput", "BranchOpeningHour"},
		"openingHours",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExecArray{ret}
}

type NewsParamsExec struct {
	Where   *NewsWhereInput
	OrderBy *NewsOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *BranchExec) News(params *NewsParamsExec) *NewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"NewsWhereInput", "NewsOrderByInput", "News"},
		"news",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExecArray{ret}
}

type SlotsParamsExec struct {
	Where   *BranchImageSlotWhereInput
	OrderBy *BranchImageSlotOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *BranchExec) Slots(params *SlotsParamsExec) *BranchImageSlotExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"BranchImageSlotWhereInput", "BranchImageSlotOrderByInput", "BranchImageSlot"},
		"slots",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExecArray{ret}
}

func (instance BranchExec) Exec(ctx context.Context) (*Branch, error) {
	var v Branch
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchExecArray struct {
	exec *prisma.Exec
}

func (instance BranchExecArray) Exec(ctx context.Context) ([]Branch, error) {
	var v []Branch
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchFields = []string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"}

type Branch struct {
	ID                 string   `json:"id"`
	CreatedAt          string   `json:"createdAt"`
	UpdatedAt          string   `json:"updatedAt"`
	PhoneNumber        *string  `json:"phoneNumber,omitempty"`
	Address            *string  `json:"address,omitempty"`
	Images             []string `json:"images,omitempty"`
	WebsiteUrl         string   `json:"websiteUrl"`
	NavigationLink     *string  `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string  `json:"sharingRedirectUrl,omitempty"`
	Imprint            string   `json:"imprint"`
	Logo               *string  `json:"logo,omitempty"`
	AppTheme           *string  `json:"appTheme,omitempty"`
	FacebookLink       *string  `json:"facebookLink,omitempty"`
	TiktokLink         *string  `json:"tiktokLink,omitempty"`
	InstagramLink      *string  `json:"instagramLink,omitempty"`
	SmtpSendHost       *string  `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string  `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string  `json:"smtpUsername,omitempty"`
	SmtpPassword       *string  `json:"smtpPassword,omitempty"`
	FromEmail          *string  `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string  `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string  `json:"mailchimpListId,omitempty"`
}

type BranchOpeningHourExec struct {
	exec *prisma.Exec
}

func (instance *BranchOpeningHourExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *BranchOpeningHourExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance BranchOpeningHourExec) Exec(ctx context.Context) (*BranchOpeningHour, error) {
	var v BranchOpeningHour
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchOpeningHourExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchOpeningHourExecArray struct {
	exec *prisma.Exec
}

func (instance BranchOpeningHourExecArray) Exec(ctx context.Context) ([]BranchOpeningHour, error) {
	var v []BranchOpeningHour
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchOpeningHourFields = []string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"}

type BranchOpeningHour struct {
	ID             string    `json:"id"`
	CreatedAt      string    `json:"createdAt"`
	UpdatedAt      string    `json:"updatedAt"`
	Day            DayOfWeek `json:"day"`
	Closed         bool      `json:"closed"`
	Break          bool      `json:"break"`
	StartForenoon  *string   `json:"startForenoon,omitempty"`
	EndForenoon    *string   `json:"endForenoon,omitempty"`
	StartAfternoon *string   `json:"startAfternoon,omitempty"`
	EndAfternoon   *string   `json:"endAfternoon,omitempty"`
}

type NewsExec struct {
	exec *prisma.Exec
}

func (instance *NewsExec) Title() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"title",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *NewsExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *NewsExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance NewsExec) Exec(ctx context.Context) (*News, error) {
	var v News
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsExecArray struct {
	exec *prisma.Exec
}

func (instance NewsExecArray) Exec(ctx context.Context) ([]News, error) {
	var v []News
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsFields = []string{"id", "createdAt", "updatedAt", "image"}

type News struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Image     *string `json:"image,omitempty"`
}

type BranchImageSlotExec struct {
	exec *prisma.Exec
}

func (instance *BranchImageSlotExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *BranchImageSlotExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance BranchImageSlotExec) Exec(ctx context.Context) (*BranchImageSlot, error) {
	var v BranchImageSlot
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchImageSlotExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchImageSlotExecArray struct {
	exec *prisma.Exec
}

func (instance BranchImageSlotExecArray) Exec(ctx context.Context) ([]BranchImageSlot, error) {
	var v []BranchImageSlot
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchImageSlotFields = []string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"}

type BranchImageSlot struct {
	ID         string `json:"id"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
	SlotNumber int32  `json:"slotNumber"`
	ImageUrl   string `json:"imageUrl"`
}

type AppointmentExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentExec) Desc() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"desc",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *AppointmentExec) Branch() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"branch",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *AppointmentExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance *AppointmentExec) Employee() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"employee",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *AppointmentExec) Customer() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"customer",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *AppointmentExec) Products(params *ProductsParamsExec) *AppointmentProductLinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AppointmentProductLinkWhereInput", "AppointmentProductLinkOrderByInput", "AppointmentProductLink"},
		"products",
		[]string{"id", "count"})

	return &AppointmentProductLinkExecArray{ret}
}

func (instance *AppointmentExec) Services(params *ServicesParamsExec) *AppointmentServiceLinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AppointmentServiceLinkWhereInput", "AppointmentServiceLinkOrderByInput", "AppointmentServiceLink"},
		"services",
		[]string{"id"})

	return &AppointmentServiceLinkExecArray{ret}
}

func (instance *AppointmentExec) Review() *ReviewExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Review"},
		"review",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

func (instance AppointmentExec) Exec(ctx context.Context) (*Appointment, error) {
	var v Appointment
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentExecArray) Exec(ctx context.Context) ([]Appointment, error) {
	var v []Appointment
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentFields = []string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"}

type Appointment struct {
	ID                           string            `json:"id"`
	CreatedAt                    string            `json:"createdAt"`
	UpdatedAt                    string            `json:"updatedAt"`
	Start                        string            `json:"start"`
	End                          string            `json:"end"`
	Price                        int32             `json:"price"`
	Status                       AppointmentStatus `json:"status"`
	CustomerNotified             *bool             `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool             `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string           `json:"note,omitempty"`
	BeforeImage                  *string           `json:"beforeImage,omitempty"`
	AfterImage                   *string           `json:"afterImage,omitempty"`
}

type AppointmentProductLinkExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentProductLinkExec) Appointment() *AppointmentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Appointment"},
		"appointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (instance *AppointmentProductLinkExec) Product() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"product",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (instance AppointmentProductLinkExec) Exec(ctx context.Context) (*AppointmentProductLink, error) {
	var v AppointmentProductLink
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentProductLinkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentProductLinkExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentProductLinkExecArray) Exec(ctx context.Context) ([]AppointmentProductLink, error) {
	var v []AppointmentProductLink
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentProductLinkFields = []string{"id", "count"}

type AppointmentProductLink struct {
	ID    string `json:"id"`
	Count int32  `json:"count"`
}

type AppointmentServiceLinkExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentServiceLinkExec) Appointment() *AppointmentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Appointment"},
		"appointment",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (instance *AppointmentServiceLinkExec) Service() *ServiceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Service"},
		"service",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (instance AppointmentServiceLinkExec) Exec(ctx context.Context) (*AppointmentServiceLink, error) {
	var v AppointmentServiceLink
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentServiceLinkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentServiceLinkExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentServiceLinkExecArray) Exec(ctx context.Context) ([]AppointmentServiceLink, error) {
	var v []AppointmentServiceLink
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentServiceLinkFields = []string{"id"}

type AppointmentServiceLink struct {
	ID string `json:"id"`
}

type WorkingHoursExec struct {
	exec *prisma.Exec
}

func (instance *WorkingHoursExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *WorkingHoursExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance WorkingHoursExec) Exec(ctx context.Context) (*WorkingHours, error) {
	var v WorkingHours
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkingHoursExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkingHoursExecArray struct {
	exec *prisma.Exec
}

func (instance WorkingHoursExecArray) Exec(ctx context.Context) ([]WorkingHours, error) {
	var v []WorkingHours
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WorkingHoursFields = []string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"}

type WorkingHours struct {
	ID             string             `json:"id"`
	CreatedAt      string             `json:"createdAt"`
	UpdatedAt      string             `json:"updatedAt"`
	Day            DayOfWeek          `json:"day"`
	NotWorking     bool               `json:"notWorking"`
	Break          bool               `json:"break"`
	StartForenoon  *string            `json:"startForenoon,omitempty"`
	EndForenoon    *string            `json:"endForenoon,omitempty"`
	StartAfternoon *string            `json:"startAfternoon,omitempty"`
	EndAfternoon   *string            `json:"endAfternoon,omitempty"`
	Status         AvailabilityStatus `json:"status"`
}

type SessionExec struct {
	exec *prisma.Exec
}

func (instance *SessionExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *SessionExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance SessionExec) Exec(ctx context.Context) (*Session, error) {
	var v Session
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionExecArray) Exec(ctx context.Context) ([]Session, error) {
	var v []Session
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionFields = []string{"id", "createdAt", "updatedAt", "token"}

type Session struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Token     string `json:"token"`
}

type PasswordTokenExec struct {
	exec *prisma.Exec
}

func (instance *PasswordTokenExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance PasswordTokenExec) Exec(ctx context.Context) (*PasswordToken, error) {
	var v PasswordToken
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PasswordTokenExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PasswordTokenExecArray struct {
	exec *prisma.Exec
}

func (instance PasswordTokenExecArray) Exec(ctx context.Context) ([]PasswordToken, error) {
	var v []PasswordToken
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PasswordTokenFields = []string{"id", "createdAt", "updatedAt", "token"}

type PasswordToken struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Token     string `json:"token"`
}

type AliasConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AliasConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AliasConnectionExec) Edges() *AliasEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AliasWhereInput", "AliasOrderByInput", "AliasEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Alias"},
		"node",
		AliasFields)

	return &AliasEdgeExecArray{nodes}
}

func (instance *AliasConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAlias"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AliasConnectionExec) Exec(ctx context.Context) (*AliasConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AliasConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AliasConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AliasConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AliasConnectionExecArray) Exec(ctx context.Context) ([]AliasConnection, error) {
	var v []AliasConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AliasConnectionFields = []string{}

type AliasConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []AliasEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type AliasEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AliasEdgeExec) Node() *AliasExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Alias"},
		"node",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

func (instance AliasEdgeExec) Exec(ctx context.Context) (*AliasEdge, error) {
	var v AliasEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AliasEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AliasEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AliasEdgeExecArray) Exec(ctx context.Context) ([]AliasEdge, error) {
	var v []AliasEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AliasEdgeFields = []string{"cursor"}

type AliasEdge struct {
	Node   Alias  `json:"node"`
	Cursor string `json:"cursor"`
}

type AppointmentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AppointmentConnectionExec) Edges() *AppointmentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AppointmentWhereInput", "AppointmentOrderByInput", "AppointmentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Appointment"},
		"node",
		AppointmentFields)

	return &AppointmentEdgeExecArray{nodes}
}

func (instance *AppointmentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAppointment"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AppointmentConnectionExec) Exec(ctx context.Context) (*AppointmentConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AppointmentConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AppointmentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentConnectionExecArray) Exec(ctx context.Context) ([]AppointmentConnection, error) {
	var v []AppointmentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentConnectionFields = []string{}

type AppointmentConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []AppointmentEdge `json:"edges"`
}

type AppointmentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentEdgeExec) Node() *AppointmentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Appointment"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (instance AppointmentEdgeExec) Exec(ctx context.Context) (*AppointmentEdge, error) {
	var v AppointmentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentEdgeExecArray) Exec(ctx context.Context) ([]AppointmentEdge, error) {
	var v []AppointmentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentEdgeFields = []string{"cursor"}

type AppointmentEdge struct {
	Node   Appointment `json:"node"`
	Cursor string      `json:"cursor"`
}

type AppointmentProductLinkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentProductLinkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AppointmentProductLinkConnectionExec) Edges() *AppointmentProductLinkEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AppointmentProductLinkWhereInput", "AppointmentProductLinkOrderByInput", "AppointmentProductLinkEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AppointmentProductLink"},
		"node",
		AppointmentProductLinkFields)

	return &AppointmentProductLinkEdgeExecArray{nodes}
}

func (instance *AppointmentProductLinkConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAppointmentProductLink"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AppointmentProductLinkConnectionExec) Exec(ctx context.Context) (*AppointmentProductLinkConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AppointmentProductLinkConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AppointmentProductLinkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentProductLinkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentProductLinkConnectionExecArray) Exec(ctx context.Context) ([]AppointmentProductLinkConnection, error) {
	var v []AppointmentProductLinkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentProductLinkConnectionFields = []string{}

type AppointmentProductLinkConnection struct {
	PageInfo PageInfo                     `json:"pageInfo"`
	Edges    []AppointmentProductLinkEdge `json:"edges"`
}

type AppointmentProductLinkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentProductLinkEdgeExec) Node() *AppointmentProductLinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentProductLink"},
		"node",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

func (instance AppointmentProductLinkEdgeExec) Exec(ctx context.Context) (*AppointmentProductLinkEdge, error) {
	var v AppointmentProductLinkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentProductLinkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentProductLinkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentProductLinkEdgeExecArray) Exec(ctx context.Context) ([]AppointmentProductLinkEdge, error) {
	var v []AppointmentProductLinkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentProductLinkEdgeFields = []string{"cursor"}

type AppointmentProductLinkEdge struct {
	Node   AppointmentProductLink `json:"node"`
	Cursor string                 `json:"cursor"`
}

type AppointmentServiceLinkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentServiceLinkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AppointmentServiceLinkConnectionExec) Edges() *AppointmentServiceLinkEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AppointmentServiceLinkWhereInput", "AppointmentServiceLinkOrderByInput", "AppointmentServiceLinkEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AppointmentServiceLink"},
		"node",
		AppointmentServiceLinkFields)

	return &AppointmentServiceLinkEdgeExecArray{nodes}
}

func (instance *AppointmentServiceLinkConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAppointmentServiceLink"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AppointmentServiceLinkConnectionExec) Exec(ctx context.Context) (*AppointmentServiceLinkConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AppointmentServiceLinkConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AppointmentServiceLinkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentServiceLinkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentServiceLinkConnectionExecArray) Exec(ctx context.Context) ([]AppointmentServiceLinkConnection, error) {
	var v []AppointmentServiceLinkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentServiceLinkConnectionFields = []string{}

type AppointmentServiceLinkConnection struct {
	PageInfo PageInfo                     `json:"pageInfo"`
	Edges    []AppointmentServiceLinkEdge `json:"edges"`
}

type AppointmentServiceLinkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentServiceLinkEdgeExec) Node() *AppointmentServiceLinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentServiceLink"},
		"node",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

func (instance AppointmentServiceLinkEdgeExec) Exec(ctx context.Context) (*AppointmentServiceLinkEdge, error) {
	var v AppointmentServiceLinkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentServiceLinkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentServiceLinkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentServiceLinkEdgeExecArray) Exec(ctx context.Context) ([]AppointmentServiceLinkEdge, error) {
	var v []AppointmentServiceLinkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentServiceLinkEdgeFields = []string{"cursor"}

type AppointmentServiceLinkEdge struct {
	Node   AppointmentServiceLink `json:"node"`
	Cursor string                 `json:"cursor"`
}

type BranchConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BranchConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BranchConnectionExec) Edges() *BranchEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BranchWhereInput", "BranchOrderByInput", "BranchEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Branch"},
		"node",
		BranchFields)

	return &BranchEdgeExecArray{nodes}
}

func (instance *BranchConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBranch"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BranchConnectionExec) Exec(ctx context.Context) (*BranchConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BranchConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BranchConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BranchConnectionExecArray) Exec(ctx context.Context) ([]BranchConnection, error) {
	var v []BranchConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchConnectionFields = []string{}

type BranchConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []BranchEdge `json:"edges"`
}

type BranchEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BranchEdgeExec) Node() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance BranchEdgeExec) Exec(ctx context.Context) (*BranchEdge, error) {
	var v BranchEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BranchEdgeExecArray) Exec(ctx context.Context) ([]BranchEdge, error) {
	var v []BranchEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchEdgeFields = []string{"cursor"}

type BranchEdge struct {
	Node   Branch `json:"node"`
	Cursor string `json:"cursor"`
}

type BranchImageSlotConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BranchImageSlotConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BranchImageSlotConnectionExec) Edges() *BranchImageSlotEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BranchImageSlotWhereInput", "BranchImageSlotOrderByInput", "BranchImageSlotEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "BranchImageSlot"},
		"node",
		BranchImageSlotFields)

	return &BranchImageSlotEdgeExecArray{nodes}
}

func (instance *BranchImageSlotConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBranchImageSlot"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BranchImageSlotConnectionExec) Exec(ctx context.Context) (*BranchImageSlotConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BranchImageSlotConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BranchImageSlotConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchImageSlotConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BranchImageSlotConnectionExecArray) Exec(ctx context.Context) ([]BranchImageSlotConnection, error) {
	var v []BranchImageSlotConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchImageSlotConnectionFields = []string{}

type BranchImageSlotConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []BranchImageSlotEdge `json:"edges"`
}

type BranchImageSlotEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BranchImageSlotEdgeExec) Node() *BranchImageSlotExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchImageSlot"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

func (instance BranchImageSlotEdgeExec) Exec(ctx context.Context) (*BranchImageSlotEdge, error) {
	var v BranchImageSlotEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchImageSlotEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchImageSlotEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BranchImageSlotEdgeExecArray) Exec(ctx context.Context) ([]BranchImageSlotEdge, error) {
	var v []BranchImageSlotEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchImageSlotEdgeFields = []string{"cursor"}

type BranchImageSlotEdge struct {
	Node   BranchImageSlot `json:"node"`
	Cursor string          `json:"cursor"`
}

type BranchOpeningHourConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BranchOpeningHourConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BranchOpeningHourConnectionExec) Edges() *BranchOpeningHourEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BranchOpeningHourWhereInput", "BranchOpeningHourOrderByInput", "BranchOpeningHourEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "BranchOpeningHour"},
		"node",
		BranchOpeningHourFields)

	return &BranchOpeningHourEdgeExecArray{nodes}
}

func (instance *BranchOpeningHourConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBranchOpeningHour"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BranchOpeningHourConnectionExec) Exec(ctx context.Context) (*BranchOpeningHourConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BranchOpeningHourConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BranchOpeningHourConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchOpeningHourConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BranchOpeningHourConnectionExecArray) Exec(ctx context.Context) ([]BranchOpeningHourConnection, error) {
	var v []BranchOpeningHourConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchOpeningHourConnectionFields = []string{}

type BranchOpeningHourConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []BranchOpeningHourEdge `json:"edges"`
}

type BranchOpeningHourEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BranchOpeningHourEdgeExec) Node() *BranchOpeningHourExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchOpeningHour"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

func (instance BranchOpeningHourEdgeExec) Exec(ctx context.Context) (*BranchOpeningHourEdge, error) {
	var v BranchOpeningHourEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchOpeningHourEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchOpeningHourEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BranchOpeningHourEdgeExecArray) Exec(ctx context.Context) ([]BranchOpeningHourEdge, error) {
	var v []BranchOpeningHourEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchOpeningHourEdgeFields = []string{"cursor"}

type BranchOpeningHourEdge struct {
	Node   BranchOpeningHour `json:"node"`
	Cursor string            `json:"cursor"`
}

type CompanyConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CompanyConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CompanyConnectionExec) Edges() *CompanyEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CompanyWhereInput", "CompanyOrderByInput", "CompanyEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Company"},
		"node",
		CompanyFields)

	return &CompanyEdgeExecArray{nodes}
}

func (instance *CompanyConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCompany"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CompanyConnectionExec) Exec(ctx context.Context) (*CompanyConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CompanyConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CompanyConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyConnectionExecArray) Exec(ctx context.Context) ([]CompanyConnection, error) {
	var v []CompanyConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyConnectionFields = []string{}

type CompanyConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []CompanyEdge `json:"edges"`
}

type CompanyEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CompanyEdgeExec) Node() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance CompanyEdgeExec) Exec(ctx context.Context) (*CompanyEdge, error) {
	var v CompanyEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyEdgeExecArray) Exec(ctx context.Context) ([]CompanyEdge, error) {
	var v []CompanyEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyEdgeFields = []string{"cursor"}

type CompanyEdge struct {
	Node   Company `json:"node"`
	Cursor string  `json:"cursor"`
}

type CustomUrlConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CustomUrlConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CustomUrlConnectionExec) Edges() *CustomUrlEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CustomUrlWhereInput", "CustomUrlOrderByInput", "CustomUrlEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "CustomUrl"},
		"node",
		CustomUrlFields)

	return &CustomUrlEdgeExecArray{nodes}
}

func (instance *CustomUrlConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCustomUrl"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CustomUrlConnectionExec) Exec(ctx context.Context) (*CustomUrlConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CustomUrlConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CustomUrlConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CustomUrlConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CustomUrlConnectionExecArray) Exec(ctx context.Context) ([]CustomUrlConnection, error) {
	var v []CustomUrlConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CustomUrlConnectionFields = []string{}

type CustomUrlConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []CustomUrlEdge `json:"edges"`
}

type CustomUrlEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CustomUrlEdgeExec) Node() *CustomUrlExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CustomUrl"},
		"node",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

func (instance CustomUrlEdgeExec) Exec(ctx context.Context) (*CustomUrlEdge, error) {
	var v CustomUrlEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CustomUrlEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CustomUrlEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CustomUrlEdgeExecArray) Exec(ctx context.Context) ([]CustomUrlEdge, error) {
	var v []CustomUrlEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CustomUrlEdgeFields = []string{"cursor"}

type CustomUrlEdge struct {
	Node   CustomUrl `json:"node"`
	Cursor string    `json:"cursor"`
}

type EmailTemplateExec struct {
	exec *prisma.Exec
}

func (instance *EmailTemplateExec) Content() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"content",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *EmailTemplateExec) Title() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"title",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *EmailTemplateExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance EmailTemplateExec) Exec(ctx context.Context) (*EmailTemplate, error) {
	var v EmailTemplate
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTemplateExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTemplateExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTemplateExecArray) Exec(ctx context.Context) ([]EmailTemplate, error) {
	var v []EmailTemplate
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var EmailTemplateFields = []string{"id", "createdAt", "updatedAt", "name"}

type EmailTemplate struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type EmailTemplateConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EmailTemplateConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EmailTemplateConnectionExec) Edges() *EmailTemplateEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"EmailTemplateWhereInput", "EmailTemplateOrderByInput", "EmailTemplateEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "EmailTemplate"},
		"node",
		EmailTemplateFields)

	return &EmailTemplateEdgeExecArray{nodes}
}

func (instance *EmailTemplateConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEmailTemplate"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance EmailTemplateConnectionExec) Exec(ctx context.Context) (*EmailTemplateConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &EmailTemplateConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance EmailTemplateConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTemplateConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTemplateConnectionExecArray) Exec(ctx context.Context) ([]EmailTemplateConnection, error) {
	var v []EmailTemplateConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var EmailTemplateConnectionFields = []string{}

type EmailTemplateConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []EmailTemplateEdge `json:"edges"`
}

type EmailTemplateEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EmailTemplateEdgeExec) Node() *EmailTemplateExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailTemplate"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

func (instance EmailTemplateEdgeExec) Exec(ctx context.Context) (*EmailTemplateEdge, error) {
	var v EmailTemplateEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTemplateEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTemplateEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTemplateEdgeExecArray) Exec(ctx context.Context) ([]EmailTemplateEdge, error) {
	var v []EmailTemplateEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var EmailTemplateEdgeFields = []string{"cursor"}

type EmailTemplateEdge struct {
	Node   EmailTemplate `json:"node"`
	Cursor string        `json:"cursor"`
}

type FavoriteExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *FavoriteExec) Product() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"product",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (instance *FavoriteExec) Service() *ServiceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Service"},
		"service",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (instance *FavoriteExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance FavoriteExec) Exec(ctx context.Context) (*Favorite, error) {
	var v Favorite
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteExecArray) Exec(ctx context.Context) ([]Favorite, error) {
	var v []Favorite
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteFields = []string{"id"}

type Favorite struct {
	ID string `json:"id"`
}

type FavoriteConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FavoriteConnectionExec) Edges() *FavoriteEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FavoriteWhereInput", "FavoriteOrderByInput", "FavoriteEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Favorite"},
		"node",
		FavoriteFields)

	return &FavoriteEdgeExecArray{nodes}
}

func (instance *FavoriteConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFavorite"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FavoriteConnectionExec) Exec(ctx context.Context) (*FavoriteConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &FavoriteConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance FavoriteConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteConnectionExecArray) Exec(ctx context.Context) ([]FavoriteConnection, error) {
	var v []FavoriteConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteConnectionFields = []string{}

type FavoriteConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []FavoriteEdge `json:"edges"`
}

type FavoriteEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteEdgeExec) Node() *FavoriteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Favorite"},
		"node",
		[]string{"id"})

	return &FavoriteExec{ret}
}

func (instance FavoriteEdgeExec) Exec(ctx context.Context) (*FavoriteEdge, error) {
	var v FavoriteEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteEdgeExecArray) Exec(ctx context.Context) ([]FavoriteEdge, error) {
	var v []FavoriteEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteEdgeFields = []string{"cursor"}

type FavoriteEdge struct {
	Node   Favorite `json:"node"`
	Cursor string   `json:"cursor"`
}

type LocalizedStringConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LocalizedStringConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LocalizedStringConnectionExec) Edges() *LocalizedStringEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"LocalizedStringWhereInput", "LocalizedStringOrderByInput", "LocalizedStringEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "LocalizedString"},
		"node",
		LocalizedStringFields)

	return &LocalizedStringEdgeExecArray{nodes}
}

func (instance *LocalizedStringConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLocalizedString"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance LocalizedStringConnectionExec) Exec(ctx context.Context) (*LocalizedStringConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &LocalizedStringConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance LocalizedStringConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocalizedStringConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LocalizedStringConnectionExecArray) Exec(ctx context.Context) ([]LocalizedStringConnection, error) {
	var v []LocalizedStringConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LocalizedStringConnectionFields = []string{}

type LocalizedStringConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []LocalizedStringEdge `json:"edges"`
}

type LocalizedStringEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LocalizedStringEdgeExec) Node() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"node",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance LocalizedStringEdgeExec) Exec(ctx context.Context) (*LocalizedStringEdge, error) {
	var v LocalizedStringEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocalizedStringEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocalizedStringEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LocalizedStringEdgeExecArray) Exec(ctx context.Context) ([]LocalizedStringEdge, error) {
	var v []LocalizedStringEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LocalizedStringEdgeFields = []string{"cursor"}

type LocalizedStringEdge struct {
	Node   LocalizedString `json:"node"`
	Cursor string          `json:"cursor"`
}

type NewsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *NewsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *NewsConnectionExec) Edges() *NewsEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"NewsWhereInput", "NewsOrderByInput", "NewsEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "News"},
		"node",
		NewsFields)

	return &NewsEdgeExecArray{nodes}
}

func (instance *NewsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateNews"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance NewsConnectionExec) Exec(ctx context.Context) (*NewsConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &NewsConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance NewsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance NewsConnectionExecArray) Exec(ctx context.Context) ([]NewsConnection, error) {
	var v []NewsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsConnectionFields = []string{}

type NewsConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []NewsEdge `json:"edges"`
}

type NewsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *NewsEdgeExec) Node() *NewsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "News"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

func (instance NewsEdgeExec) Exec(ctx context.Context) (*NewsEdge, error) {
	var v NewsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance NewsEdgeExecArray) Exec(ctx context.Context) ([]NewsEdge, error) {
	var v []NewsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsEdgeFields = []string{"cursor"}

type NewsEdge struct {
	Node   News   `json:"node"`
	Cursor string `json:"cursor"`
}

type PasswordTokenConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PasswordTokenConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PasswordTokenConnectionExec) Edges() *PasswordTokenEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PasswordTokenWhereInput", "PasswordTokenOrderByInput", "PasswordTokenEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PasswordToken"},
		"node",
		PasswordTokenFields)

	return &PasswordTokenEdgeExecArray{nodes}
}

func (instance *PasswordTokenConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePasswordToken"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PasswordTokenConnectionExec) Exec(ctx context.Context) (*PasswordTokenConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PasswordTokenConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PasswordTokenConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PasswordTokenConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PasswordTokenConnectionExecArray) Exec(ctx context.Context) ([]PasswordTokenConnection, error) {
	var v []PasswordTokenConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PasswordTokenConnectionFields = []string{}

type PasswordTokenConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []PasswordTokenEdge `json:"edges"`
}

type PasswordTokenEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PasswordTokenEdgeExec) Node() *PasswordTokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PasswordToken"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

func (instance PasswordTokenEdgeExec) Exec(ctx context.Context) (*PasswordTokenEdge, error) {
	var v PasswordTokenEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PasswordTokenEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PasswordTokenEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PasswordTokenEdgeExecArray) Exec(ctx context.Context) ([]PasswordTokenEdge, error) {
	var v []PasswordTokenEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PasswordTokenEdgeFields = []string{"cursor"}

type PasswordTokenEdge struct {
	Node   PasswordToken `json:"node"`
	Cursor string        `json:"cursor"`
}

type ProductConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProductConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProductConnectionExec) Edges() *ProductEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProductWhereInput", "ProductOrderByInput", "ProductEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Product"},
		"node",
		ProductFields)

	return &ProductEdgeExecArray{nodes}
}

func (instance *ProductConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProduct"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProductConnectionExec) Exec(ctx context.Context) (*ProductConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ProductConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ProductConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProductConnectionExecArray) Exec(ctx context.Context) ([]ProductConnection, error) {
	var v []ProductConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductConnectionFields = []string{}

type ProductConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []ProductEdge `json:"edges"`
}

type ProductEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProductEdgeExec) Node() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (instance ProductEdgeExec) Exec(ctx context.Context) (*ProductEdge, error) {
	var v ProductEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEdgeExecArray) Exec(ctx context.Context) ([]ProductEdge, error) {
	var v []ProductEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductEdgeFields = []string{"cursor"}

type ProductEdge struct {
	Node   Product `json:"node"`
	Cursor string  `json:"cursor"`
}

type ProductCategoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProductCategoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProductCategoryConnectionExec) Edges() *ProductCategoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProductCategoryWhereInput", "ProductCategoryOrderByInput", "ProductCategoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ProductCategory"},
		"node",
		ProductCategoryFields)

	return &ProductCategoryEdgeExecArray{nodes}
}

func (instance *ProductCategoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProductCategory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProductCategoryConnectionExec) Exec(ctx context.Context) (*ProductCategoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ProductCategoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ProductCategoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductCategoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProductCategoryConnectionExecArray) Exec(ctx context.Context) ([]ProductCategoryConnection, error) {
	var v []ProductCategoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductCategoryConnectionFields = []string{}

type ProductCategoryConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []ProductCategoryEdge `json:"edges"`
}

type ProductCategoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProductCategoryEdgeExec) Node() *ProductCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

func (instance ProductCategoryEdgeExec) Exec(ctx context.Context) (*ProductCategoryEdge, error) {
	var v ProductCategoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductCategoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductCategoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductCategoryEdgeExecArray) Exec(ctx context.Context) ([]ProductCategoryEdge, error) {
	var v []ProductCategoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductCategoryEdgeFields = []string{"cursor"}

type ProductCategoryEdge struct {
	Node   ProductCategory `json:"node"`
	Cursor string          `json:"cursor"`
}

type ProductServiceAttributeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProductServiceAttributeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProductServiceAttributeConnectionExec) Edges() *ProductServiceAttributeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProductServiceAttributeWhereInput", "ProductServiceAttributeOrderByInput", "ProductServiceAttributeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ProductServiceAttribute"},
		"node",
		ProductServiceAttributeFields)

	return &ProductServiceAttributeEdgeExecArray{nodes}
}

func (instance *ProductServiceAttributeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProductServiceAttribute"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProductServiceAttributeConnectionExec) Exec(ctx context.Context) (*ProductServiceAttributeConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ProductServiceAttributeConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ProductServiceAttributeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductServiceAttributeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProductServiceAttributeConnectionExecArray) Exec(ctx context.Context) ([]ProductServiceAttributeConnection, error) {
	var v []ProductServiceAttributeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductServiceAttributeConnectionFields = []string{}

type ProductServiceAttributeConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []ProductServiceAttributeEdge `json:"edges"`
}

type ProductServiceAttributeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProductServiceAttributeEdgeExec) Node() *ProductServiceAttributeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductServiceAttribute"},
		"node",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

func (instance ProductServiceAttributeEdgeExec) Exec(ctx context.Context) (*ProductServiceAttributeEdge, error) {
	var v ProductServiceAttributeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductServiceAttributeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductServiceAttributeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductServiceAttributeEdgeExecArray) Exec(ctx context.Context) ([]ProductServiceAttributeEdge, error) {
	var v []ProductServiceAttributeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductServiceAttributeEdgeFields = []string{"cursor"}

type ProductServiceAttributeEdge struct {
	Node   ProductServiceAttribute `json:"node"`
	Cursor string                  `json:"cursor"`
}

type ProductSubCategoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProductSubCategoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProductSubCategoryConnectionExec) Edges() *ProductSubCategoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProductSubCategoryWhereInput", "ProductSubCategoryOrderByInput", "ProductSubCategoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ProductSubCategory"},
		"node",
		ProductSubCategoryFields)

	return &ProductSubCategoryEdgeExecArray{nodes}
}

func (instance *ProductSubCategoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProductSubCategory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProductSubCategoryConnectionExec) Exec(ctx context.Context) (*ProductSubCategoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ProductSubCategoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ProductSubCategoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubCategoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubCategoryConnectionExecArray) Exec(ctx context.Context) ([]ProductSubCategoryConnection, error) {
	var v []ProductSubCategoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductSubCategoryConnectionFields = []string{}

type ProductSubCategoryConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []ProductSubCategoryEdge `json:"edges"`
}

type ProductSubCategoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProductSubCategoryEdgeExec) Node() *ProductSubCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductSubCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

func (instance ProductSubCategoryEdgeExec) Exec(ctx context.Context) (*ProductSubCategoryEdge, error) {
	var v ProductSubCategoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductSubCategoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubCategoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubCategoryEdgeExecArray) Exec(ctx context.Context) ([]ProductSubCategoryEdge, error) {
	var v []ProductSubCategoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductSubCategoryEdgeFields = []string{"cursor"}

type ProductSubCategoryEdge struct {
	Node   ProductSubCategory `json:"node"`
	Cursor string             `json:"cursor"`
}

type ReviewConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewConnectionExec) Edges() *ReviewEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewWhereInput", "ReviewOrderByInput", "ReviewEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Review"},
		"node",
		ReviewFields)

	return &ReviewEdgeExecArray{nodes}
}

func (instance *ReviewConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReview"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewConnectionExec) Exec(ctx context.Context) (*ReviewConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewConnectionExecArray) Exec(ctx context.Context) ([]ReviewConnection, error) {
	var v []ReviewConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewConnectionFields = []string{}

type ReviewConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []ReviewEdge `json:"edges"`
}

type ReviewEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewEdgeExec) Node() *ReviewExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Review"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

func (instance ReviewEdgeExec) Exec(ctx context.Context) (*ReviewEdge, error) {
	var v ReviewEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewEdgeExecArray) Exec(ctx context.Context) ([]ReviewEdge, error) {
	var v []ReviewEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewEdgeFields = []string{"cursor"}

type ReviewEdge struct {
	Node   Review `json:"node"`
	Cursor string `json:"cursor"`
}

type ServiceConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ServiceConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ServiceConnectionExec) Edges() *ServiceEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ServiceWhereInput", "ServiceOrderByInput", "ServiceEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Service"},
		"node",
		ServiceFields)

	return &ServiceEdgeExecArray{nodes}
}

func (instance *ServiceConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateService"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ServiceConnectionExec) Exec(ctx context.Context) (*ServiceConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ServiceConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ServiceConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceConnectionExecArray) Exec(ctx context.Context) ([]ServiceConnection, error) {
	var v []ServiceConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceConnectionFields = []string{}

type ServiceConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []ServiceEdge `json:"edges"`
}

type ServiceEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ServiceEdgeExec) Node() *ServiceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Service"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (instance ServiceEdgeExec) Exec(ctx context.Context) (*ServiceEdge, error) {
	var v ServiceEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceEdgeExecArray) Exec(ctx context.Context) ([]ServiceEdge, error) {
	var v []ServiceEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceEdgeFields = []string{"cursor"}

type ServiceEdge struct {
	Node   Service `json:"node"`
	Cursor string  `json:"cursor"`
}

type ServiceCategoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ServiceCategoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ServiceCategoryConnectionExec) Edges() *ServiceCategoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ServiceCategoryWhereInput", "ServiceCategoryOrderByInput", "ServiceCategoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ServiceCategory"},
		"node",
		ServiceCategoryFields)

	return &ServiceCategoryEdgeExecArray{nodes}
}

func (instance *ServiceCategoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateServiceCategory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ServiceCategoryConnectionExec) Exec(ctx context.Context) (*ServiceCategoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ServiceCategoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ServiceCategoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceCategoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceCategoryConnectionExecArray) Exec(ctx context.Context) ([]ServiceCategoryConnection, error) {
	var v []ServiceCategoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceCategoryConnectionFields = []string{}

type ServiceCategoryConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []ServiceCategoryEdge `json:"edges"`
}

type ServiceCategoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ServiceCategoryEdgeExec) Node() *ServiceCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

func (instance ServiceCategoryEdgeExec) Exec(ctx context.Context) (*ServiceCategoryEdge, error) {
	var v ServiceCategoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceCategoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceCategoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceCategoryEdgeExecArray) Exec(ctx context.Context) ([]ServiceCategoryEdge, error) {
	var v []ServiceCategoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceCategoryEdgeFields = []string{"cursor"}

type ServiceCategoryEdge struct {
	Node   ServiceCategory `json:"node"`
	Cursor string          `json:"cursor"`
}

type ServiceSubCategoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ServiceSubCategoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ServiceSubCategoryConnectionExec) Edges() *ServiceSubCategoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ServiceSubCategoryWhereInput", "ServiceSubCategoryOrderByInput", "ServiceSubCategoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ServiceSubCategory"},
		"node",
		ServiceSubCategoryFields)

	return &ServiceSubCategoryEdgeExecArray{nodes}
}

func (instance *ServiceSubCategoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateServiceSubCategory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ServiceSubCategoryConnectionExec) Exec(ctx context.Context) (*ServiceSubCategoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ServiceSubCategoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ServiceSubCategoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceSubCategoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceSubCategoryConnectionExecArray) Exec(ctx context.Context) ([]ServiceSubCategoryConnection, error) {
	var v []ServiceSubCategoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceSubCategoryConnectionFields = []string{}

type ServiceSubCategoryConnection struct {
	PageInfo PageInfo                 `json:"pageInfo"`
	Edges    []ServiceSubCategoryEdge `json:"edges"`
}

type ServiceSubCategoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ServiceSubCategoryEdgeExec) Node() *ServiceSubCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceSubCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

func (instance ServiceSubCategoryEdgeExec) Exec(ctx context.Context) (*ServiceSubCategoryEdge, error) {
	var v ServiceSubCategoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceSubCategoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceSubCategoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceSubCategoryEdgeExecArray) Exec(ctx context.Context) ([]ServiceSubCategoryEdge, error) {
	var v []ServiceSubCategoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceSubCategoryEdgeFields = []string{"cursor"}

type ServiceSubCategoryEdge struct {
	Node   ServiceSubCategory `json:"node"`
	Cursor string             `json:"cursor"`
}

type SessionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SessionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SessionConnectionExec) Edges() *SessionEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "SessionEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Session"},
		"node",
		SessionFields)

	return &SessionEdgeExecArray{nodes}
}

func (instance *SessionConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSession"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance SessionConnectionExec) Exec(ctx context.Context) (*SessionConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &SessionConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance SessionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionConnectionExecArray) Exec(ctx context.Context) ([]SessionConnection, error) {
	var v []SessionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionConnectionFields = []string{}

type SessionConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []SessionEdge `json:"edges"`
}

type SessionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SessionEdgeExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

func (instance SessionEdgeExec) Exec(ctx context.Context) (*SessionEdge, error) {
	var v SessionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SessionEdgeExecArray) Exec(ctx context.Context) ([]SessionEdge, error) {
	var v []SessionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionEdgeFields = []string{"cursor"}

type SessionEdge struct {
	Node   Session `json:"node"`
	Cursor string  `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type WorkingHoursConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WorkingHoursConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WorkingHoursConnectionExec) Edges() *WorkingHoursEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WorkingHoursWhereInput", "WorkingHoursOrderByInput", "WorkingHoursEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "WorkingHours"},
		"node",
		WorkingHoursFields)

	return &WorkingHoursEdgeExecArray{nodes}
}

func (instance *WorkingHoursConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWorkingHours"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WorkingHoursConnectionExec) Exec(ctx context.Context) (*WorkingHoursConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &WorkingHoursConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance WorkingHoursConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkingHoursConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WorkingHoursConnectionExecArray) Exec(ctx context.Context) ([]WorkingHoursConnection, error) {
	var v []WorkingHoursConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WorkingHoursConnectionFields = []string{}

type WorkingHoursConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []WorkingHoursEdge `json:"edges"`
}

type WorkingHoursEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WorkingHoursEdgeExec) Node() *WorkingHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkingHours"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

func (instance WorkingHoursEdgeExec) Exec(ctx context.Context) (*WorkingHoursEdge, error) {
	var v WorkingHoursEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkingHoursEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkingHoursEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WorkingHoursEdgeExecArray) Exec(ctx context.Context) ([]WorkingHoursEdge, error) {
	var v []WorkingHoursEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WorkingHoursEdgeFields = []string{"cursor"}

type WorkingHoursEdge struct {
	Node   WorkingHours `json:"node"`
	Cursor string       `json:"cursor"`
}

type AliasSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AliasSubscriptionPayloadExec) Node() *AliasExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Alias"},
		"node",
		[]string{"id", "value"})

	return &AliasExec{ret}
}

func (instance *AliasSubscriptionPayloadExec) PreviousValues() *AliasPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AliasPreviousValues"},
		"previousValues",
		[]string{"id", "value"})

	return &AliasPreviousValuesExec{ret}
}

func (instance AliasSubscriptionPayloadExec) Exec(ctx context.Context) (*AliasSubscriptionPayload, error) {
	var v AliasSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AliasSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AliasSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AliasSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AliasSubscriptionPayload, error) {
	var v []AliasSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AliasSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AliasSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Alias       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AliasPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AliasPreviousValuesExec) Exec(ctx context.Context) (*AliasPreviousValues, error) {
	var v AliasPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AliasPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AliasPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AliasPreviousValuesExecArray) Exec(ctx context.Context) ([]AliasPreviousValues, error) {
	var v []AliasPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AliasPreviousValuesFields = []string{"id", "value"}

type AliasPreviousValues struct {
	ID    string `json:"id"`
	Value string `json:"value"`
}

type AppointmentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentSubscriptionPayloadExec) Node() *AppointmentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Appointment"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentExec{ret}
}

func (instance *AppointmentSubscriptionPayloadExec) PreviousValues() *AppointmentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"})

	return &AppointmentPreviousValuesExec{ret}
}

func (instance AppointmentSubscriptionPayloadExec) Exec(ctx context.Context) (*AppointmentSubscriptionPayload, error) {
	var v AppointmentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AppointmentSubscriptionPayload, error) {
	var v []AppointmentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AppointmentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Appointment `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AppointmentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AppointmentPreviousValuesExec) Exec(ctx context.Context) (*AppointmentPreviousValues, error) {
	var v AppointmentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentPreviousValuesExecArray) Exec(ctx context.Context) ([]AppointmentPreviousValues, error) {
	var v []AppointmentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "start", "end", "price", "status", "customerNotified", "customerNotifiedAnHourBefore", "note", "beforeImage", "afterImage"}

type AppointmentPreviousValues struct {
	ID                           string            `json:"id"`
	CreatedAt                    string            `json:"createdAt"`
	UpdatedAt                    string            `json:"updatedAt"`
	Start                        string            `json:"start"`
	End                          string            `json:"end"`
	Price                        int32             `json:"price"`
	Status                       AppointmentStatus `json:"status"`
	CustomerNotified             *bool             `json:"customerNotified,omitempty"`
	CustomerNotifiedAnHourBefore *bool             `json:"customerNotifiedAnHourBefore,omitempty"`
	Note                         *string           `json:"note,omitempty"`
	BeforeImage                  *string           `json:"beforeImage,omitempty"`
	AfterImage                   *string           `json:"afterImage,omitempty"`
}

type AppointmentProductLinkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentProductLinkSubscriptionPayloadExec) Node() *AppointmentProductLinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentProductLink"},
		"node",
		[]string{"id", "count"})

	return &AppointmentProductLinkExec{ret}
}

func (instance *AppointmentProductLinkSubscriptionPayloadExec) PreviousValues() *AppointmentProductLinkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentProductLinkPreviousValues"},
		"previousValues",
		[]string{"id", "count"})

	return &AppointmentProductLinkPreviousValuesExec{ret}
}

func (instance AppointmentProductLinkSubscriptionPayloadExec) Exec(ctx context.Context) (*AppointmentProductLinkSubscriptionPayload, error) {
	var v AppointmentProductLinkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentProductLinkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentProductLinkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentProductLinkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AppointmentProductLinkSubscriptionPayload, error) {
	var v []AppointmentProductLinkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentProductLinkSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AppointmentProductLinkSubscriptionPayload struct {
	Mutation      MutationType            `json:"mutation"`
	Node          *AppointmentProductLink `json:"node,omitempty"`
	UpdatedFields []string                `json:"updatedFields,omitempty"`
}

type AppointmentProductLinkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AppointmentProductLinkPreviousValuesExec) Exec(ctx context.Context) (*AppointmentProductLinkPreviousValues, error) {
	var v AppointmentProductLinkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentProductLinkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentProductLinkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentProductLinkPreviousValuesExecArray) Exec(ctx context.Context) ([]AppointmentProductLinkPreviousValues, error) {
	var v []AppointmentProductLinkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentProductLinkPreviousValuesFields = []string{"id", "count"}

type AppointmentProductLinkPreviousValues struct {
	ID    string `json:"id"`
	Count int32  `json:"count"`
}

type AppointmentServiceLinkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AppointmentServiceLinkSubscriptionPayloadExec) Node() *AppointmentServiceLinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentServiceLink"},
		"node",
		[]string{"id"})

	return &AppointmentServiceLinkExec{ret}
}

func (instance *AppointmentServiceLinkSubscriptionPayloadExec) PreviousValues() *AppointmentServiceLinkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppointmentServiceLinkPreviousValues"},
		"previousValues",
		[]string{"id"})

	return &AppointmentServiceLinkPreviousValuesExec{ret}
}

func (instance AppointmentServiceLinkSubscriptionPayloadExec) Exec(ctx context.Context) (*AppointmentServiceLinkSubscriptionPayload, error) {
	var v AppointmentServiceLinkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentServiceLinkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentServiceLinkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentServiceLinkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AppointmentServiceLinkSubscriptionPayload, error) {
	var v []AppointmentServiceLinkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentServiceLinkSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AppointmentServiceLinkSubscriptionPayload struct {
	Mutation      MutationType            `json:"mutation"`
	Node          *AppointmentServiceLink `json:"node,omitempty"`
	UpdatedFields []string                `json:"updatedFields,omitempty"`
}

type AppointmentServiceLinkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AppointmentServiceLinkPreviousValuesExec) Exec(ctx context.Context) (*AppointmentServiceLinkPreviousValues, error) {
	var v AppointmentServiceLinkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppointmentServiceLinkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppointmentServiceLinkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AppointmentServiceLinkPreviousValuesExecArray) Exec(ctx context.Context) ([]AppointmentServiceLinkPreviousValues, error) {
	var v []AppointmentServiceLinkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppointmentServiceLinkPreviousValuesFields = []string{"id"}

type AppointmentServiceLinkPreviousValues struct {
	ID string `json:"id"`
}

type BranchSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BranchSubscriptionPayloadExec) Node() *BranchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Branch"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchExec{ret}
}

func (instance *BranchSubscriptionPayloadExec) PreviousValues() *BranchPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"})

	return &BranchPreviousValuesExec{ret}
}

func (instance BranchSubscriptionPayloadExec) Exec(ctx context.Context) (*BranchSubscriptionPayload, error) {
	var v BranchSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BranchSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BranchSubscriptionPayload, error) {
	var v []BranchSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BranchSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Branch      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BranchPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BranchPreviousValuesExec) Exec(ctx context.Context) (*BranchPreviousValues, error) {
	var v BranchPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BranchPreviousValuesExecArray) Exec(ctx context.Context) ([]BranchPreviousValues, error) {
	var v []BranchPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "phoneNumber", "address", "images", "websiteUrl", "navigationLink", "sharingRedirectUrl", "imprint", "logo", "appTheme", "facebookLink", "tiktokLink", "instagramLink", "smtpSendHost", "smtpSendPort", "smtpUsername", "smtpPassword", "fromEmail", "mailchimpApiKey", "mailchimpListId"}

type BranchPreviousValues struct {
	ID                 string   `json:"id"`
	CreatedAt          string   `json:"createdAt"`
	UpdatedAt          string   `json:"updatedAt"`
	PhoneNumber        *string  `json:"phoneNumber,omitempty"`
	Address            *string  `json:"address,omitempty"`
	Images             []string `json:"images,omitempty"`
	WebsiteUrl         string   `json:"websiteUrl"`
	NavigationLink     *string  `json:"navigationLink,omitempty"`
	SharingRedirectUrl *string  `json:"sharingRedirectUrl,omitempty"`
	Imprint            string   `json:"imprint"`
	Logo               *string  `json:"logo,omitempty"`
	AppTheme           *string  `json:"appTheme,omitempty"`
	FacebookLink       *string  `json:"facebookLink,omitempty"`
	TiktokLink         *string  `json:"tiktokLink,omitempty"`
	InstagramLink      *string  `json:"instagramLink,omitempty"`
	SmtpSendHost       *string  `json:"smtpSendHost,omitempty"`
	SmtpSendPort       *string  `json:"smtpSendPort,omitempty"`
	SmtpUsername       *string  `json:"smtpUsername,omitempty"`
	SmtpPassword       *string  `json:"smtpPassword,omitempty"`
	FromEmail          *string  `json:"fromEmail,omitempty"`
	MailchimpApiKey    *string  `json:"mailchimpApiKey,omitempty"`
	MailchimpListId    *string  `json:"mailchimpListId,omitempty"`
}

type BranchImageSlotSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BranchImageSlotSubscriptionPayloadExec) Node() *BranchImageSlotExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchImageSlot"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotExec{ret}
}

func (instance *BranchImageSlotSubscriptionPayloadExec) PreviousValues() *BranchImageSlotPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchImageSlotPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"})

	return &BranchImageSlotPreviousValuesExec{ret}
}

func (instance BranchImageSlotSubscriptionPayloadExec) Exec(ctx context.Context) (*BranchImageSlotSubscriptionPayload, error) {
	var v BranchImageSlotSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchImageSlotSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchImageSlotSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BranchImageSlotSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BranchImageSlotSubscriptionPayload, error) {
	var v []BranchImageSlotSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchImageSlotSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BranchImageSlotSubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *BranchImageSlot `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type BranchImageSlotPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BranchImageSlotPreviousValuesExec) Exec(ctx context.Context) (*BranchImageSlotPreviousValues, error) {
	var v BranchImageSlotPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchImageSlotPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchImageSlotPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BranchImageSlotPreviousValuesExecArray) Exec(ctx context.Context) ([]BranchImageSlotPreviousValues, error) {
	var v []BranchImageSlotPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchImageSlotPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "slotNumber", "imageUrl"}

type BranchImageSlotPreviousValues struct {
	ID         string `json:"id"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
	SlotNumber int32  `json:"slotNumber"`
	ImageUrl   string `json:"imageUrl"`
}

type BranchOpeningHourSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BranchOpeningHourSubscriptionPayloadExec) Node() *BranchOpeningHourExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchOpeningHour"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourExec{ret}
}

func (instance *BranchOpeningHourSubscriptionPayloadExec) PreviousValues() *BranchOpeningHourPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BranchOpeningHourPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"})

	return &BranchOpeningHourPreviousValuesExec{ret}
}

func (instance BranchOpeningHourSubscriptionPayloadExec) Exec(ctx context.Context) (*BranchOpeningHourSubscriptionPayload, error) {
	var v BranchOpeningHourSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchOpeningHourSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchOpeningHourSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BranchOpeningHourSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BranchOpeningHourSubscriptionPayload, error) {
	var v []BranchOpeningHourSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchOpeningHourSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BranchOpeningHourSubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *BranchOpeningHour `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type BranchOpeningHourPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BranchOpeningHourPreviousValuesExec) Exec(ctx context.Context) (*BranchOpeningHourPreviousValues, error) {
	var v BranchOpeningHourPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BranchOpeningHourPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BranchOpeningHourPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BranchOpeningHourPreviousValuesExecArray) Exec(ctx context.Context) ([]BranchOpeningHourPreviousValues, error) {
	var v []BranchOpeningHourPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BranchOpeningHourPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "day", "closed", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon"}

type BranchOpeningHourPreviousValues struct {
	ID             string    `json:"id"`
	CreatedAt      string    `json:"createdAt"`
	UpdatedAt      string    `json:"updatedAt"`
	Day            DayOfWeek `json:"day"`
	Closed         bool      `json:"closed"`
	Break          bool      `json:"break"`
	StartForenoon  *string   `json:"startForenoon,omitempty"`
	EndForenoon    *string   `json:"endForenoon,omitempty"`
	StartAfternoon *string   `json:"startAfternoon,omitempty"`
	EndAfternoon   *string   `json:"endAfternoon,omitempty"`
}

type CompanySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CompanySubscriptionPayloadExec) Node() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyExec{ret}
}

func (instance *CompanySubscriptionPayloadExec) PreviousValues() *CompanyPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"})

	return &CompanyPreviousValuesExec{ret}
}

func (instance CompanySubscriptionPayloadExec) Exec(ctx context.Context) (*CompanySubscriptionPayload, error) {
	var v CompanySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CompanySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CompanySubscriptionPayload, error) {
	var v []CompanySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CompanySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Company     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CompanyPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CompanyPreviousValuesExec) Exec(ctx context.Context) (*CompanyPreviousValues, error) {
	var v CompanyPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyPreviousValuesExecArray) Exec(ctx context.Context) ([]CompanyPreviousValues, error) {
	var v []CompanyPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "sharingRedirectUrl", "logo", "appTheme", "pwaIcon", "pwaThemeColor", "pwaBackgroundColor"}

type CompanyPreviousValues struct {
	ID                 string  `json:"id"`
	CreatedAt          string  `json:"createdAt"`
	UpdatedAt          string  `json:"updatedAt"`
	SharingRedirectUrl *string `json:"sharingRedirectUrl,omitempty"`
	Logo               *string `json:"logo,omitempty"`
	AppTheme           *string `json:"appTheme,omitempty"`
	PwaIcon            *string `json:"pwaIcon,omitempty"`
	PwaThemeColor      string  `json:"pwaThemeColor"`
	PwaBackgroundColor string  `json:"pwaBackgroundColor"`
}

type CustomUrlSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CustomUrlSubscriptionPayloadExec) Node() *CustomUrlExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CustomUrl"},
		"node",
		[]string{"id", "value"})

	return &CustomUrlExec{ret}
}

func (instance *CustomUrlSubscriptionPayloadExec) PreviousValues() *CustomUrlPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CustomUrlPreviousValues"},
		"previousValues",
		[]string{"id", "value"})

	return &CustomUrlPreviousValuesExec{ret}
}

func (instance CustomUrlSubscriptionPayloadExec) Exec(ctx context.Context) (*CustomUrlSubscriptionPayload, error) {
	var v CustomUrlSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CustomUrlSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CustomUrlSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CustomUrlSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CustomUrlSubscriptionPayload, error) {
	var v []CustomUrlSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CustomUrlSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CustomUrlSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *CustomUrl   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CustomUrlPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CustomUrlPreviousValuesExec) Exec(ctx context.Context) (*CustomUrlPreviousValues, error) {
	var v CustomUrlPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CustomUrlPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CustomUrlPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CustomUrlPreviousValuesExecArray) Exec(ctx context.Context) ([]CustomUrlPreviousValues, error) {
	var v []CustomUrlPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CustomUrlPreviousValuesFields = []string{"id", "value"}

type CustomUrlPreviousValues struct {
	ID    string `json:"id"`
	Value string `json:"value"`
}

type EmailTemplateSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EmailTemplateSubscriptionPayloadExec) Node() *EmailTemplateExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailTemplate"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplateExec{ret}
}

func (instance *EmailTemplateSubscriptionPayloadExec) PreviousValues() *EmailTemplatePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailTemplatePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &EmailTemplatePreviousValuesExec{ret}
}

func (instance EmailTemplateSubscriptionPayloadExec) Exec(ctx context.Context) (*EmailTemplateSubscriptionPayload, error) {
	var v EmailTemplateSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTemplateSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTemplateSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTemplateSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EmailTemplateSubscriptionPayload, error) {
	var v []EmailTemplateSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var EmailTemplateSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type EmailTemplateSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *EmailTemplate `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type EmailTemplatePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EmailTemplatePreviousValuesExec) Exec(ctx context.Context) (*EmailTemplatePreviousValues, error) {
	var v EmailTemplatePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTemplatePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTemplatePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTemplatePreviousValuesExecArray) Exec(ctx context.Context) ([]EmailTemplatePreviousValues, error) {
	var v []EmailTemplatePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var EmailTemplatePreviousValuesFields = []string{"id", "createdAt", "updatedAt", "name"}

type EmailTemplatePreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type FavoriteSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteSubscriptionPayloadExec) Node() *FavoriteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Favorite"},
		"node",
		[]string{"id"})

	return &FavoriteExec{ret}
}

func (instance *FavoriteSubscriptionPayloadExec) PreviousValues() *FavoritePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FavoritePreviousValues"},
		"previousValues",
		[]string{"id"})

	return &FavoritePreviousValuesExec{ret}
}

func (instance FavoriteSubscriptionPayloadExec) Exec(ctx context.Context) (*FavoriteSubscriptionPayload, error) {
	var v FavoriteSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FavoriteSubscriptionPayload, error) {
	var v []FavoriteSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type FavoriteSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Favorite    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FavoritePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FavoritePreviousValuesExec) Exec(ctx context.Context) (*FavoritePreviousValues, error) {
	var v FavoritePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoritePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoritePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FavoritePreviousValuesExecArray) Exec(ctx context.Context) ([]FavoritePreviousValues, error) {
	var v []FavoritePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoritePreviousValuesFields = []string{"id"}

type FavoritePreviousValues struct {
	ID string `json:"id"`
}

type LocalizedStringSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LocalizedStringSubscriptionPayloadExec) Node() *LocalizedStringExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedString"},
		"node",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringExec{ret}
}

func (instance *LocalizedStringSubscriptionPayloadExec) PreviousValues() *LocalizedStringPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocalizedStringPreviousValues"},
		"previousValues",
		[]string{"id", "de", "en", "tr"})

	return &LocalizedStringPreviousValuesExec{ret}
}

func (instance LocalizedStringSubscriptionPayloadExec) Exec(ctx context.Context) (*LocalizedStringSubscriptionPayload, error) {
	var v LocalizedStringSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocalizedStringSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocalizedStringSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LocalizedStringSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LocalizedStringSubscriptionPayload, error) {
	var v []LocalizedStringSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LocalizedStringSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type LocalizedStringSubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *LocalizedString `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type LocalizedStringPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LocalizedStringPreviousValuesExec) Exec(ctx context.Context) (*LocalizedStringPreviousValues, error) {
	var v LocalizedStringPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocalizedStringPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocalizedStringPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LocalizedStringPreviousValuesExecArray) Exec(ctx context.Context) ([]LocalizedStringPreviousValues, error) {
	var v []LocalizedStringPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LocalizedStringPreviousValuesFields = []string{"id", "de", "en", "tr"}

type LocalizedStringPreviousValues struct {
	ID string  `json:"id"`
	De *string `json:"de,omitempty"`
	En *string `json:"en,omitempty"`
	Tr *string `json:"tr,omitempty"`
}

type NewsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *NewsSubscriptionPayloadExec) Node() *NewsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "News"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsExec{ret}
}

func (instance *NewsSubscriptionPayloadExec) PreviousValues() *NewsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NewsPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "image"})

	return &NewsPreviousValuesExec{ret}
}

func (instance NewsSubscriptionPayloadExec) Exec(ctx context.Context) (*NewsSubscriptionPayload, error) {
	var v NewsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance NewsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]NewsSubscriptionPayload, error) {
	var v []NewsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type NewsSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *News        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type NewsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance NewsPreviousValuesExec) Exec(ctx context.Context) (*NewsPreviousValues, error) {
	var v NewsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance NewsPreviousValuesExecArray) Exec(ctx context.Context) ([]NewsPreviousValues, error) {
	var v []NewsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "image"}

type NewsPreviousValues struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Image     *string `json:"image,omitempty"`
}

type PasswordTokenSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PasswordTokenSubscriptionPayloadExec) Node() *PasswordTokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PasswordToken"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenExec{ret}
}

func (instance *PasswordTokenSubscriptionPayloadExec) PreviousValues() *PasswordTokenPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PasswordTokenPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &PasswordTokenPreviousValuesExec{ret}
}

func (instance PasswordTokenSubscriptionPayloadExec) Exec(ctx context.Context) (*PasswordTokenSubscriptionPayload, error) {
	var v PasswordTokenSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PasswordTokenSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PasswordTokenSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PasswordTokenSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PasswordTokenSubscriptionPayload, error) {
	var v []PasswordTokenSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PasswordTokenSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PasswordTokenSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *PasswordToken `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type PasswordTokenPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PasswordTokenPreviousValuesExec) Exec(ctx context.Context) (*PasswordTokenPreviousValues, error) {
	var v PasswordTokenPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PasswordTokenPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PasswordTokenPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PasswordTokenPreviousValuesExecArray) Exec(ctx context.Context) ([]PasswordTokenPreviousValues, error) {
	var v []PasswordTokenPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PasswordTokenPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "token"}

type PasswordTokenPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Token     string `json:"token"`
}

type ProductSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProductSubscriptionPayloadExec) Node() *ProductExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Product"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductExec{ret}
}

func (instance *ProductSubscriptionPayloadExec) PreviousValues() *ProductPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"})

	return &ProductPreviousValuesExec{ret}
}

func (instance ProductSubscriptionPayloadExec) Exec(ctx context.Context) (*ProductSubscriptionPayload, error) {
	var v ProductSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProductSubscriptionPayload, error) {
	var v []ProductSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ProductSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Product     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ProductPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProductPreviousValuesExec) Exec(ctx context.Context) (*ProductPreviousValues, error) {
	var v ProductPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProductPreviousValuesExecArray) Exec(ctx context.Context) ([]ProductPreviousValues, error) {
	var v []ProductPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "price", "capacity", "image", "deleted", "active"}

type ProductPreviousValues struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Price     int32   `json:"price"`
	Capacity  *string `json:"capacity,omitempty"`
	Image     *string `json:"image,omitempty"`
	Deleted   bool    `json:"deleted"`
	Active    bool    `json:"active"`
}

type ProductCategorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProductCategorySubscriptionPayloadExec) Node() *ProductCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryExec{ret}
}

func (instance *ProductCategorySubscriptionPayloadExec) PreviousValues() *ProductCategoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductCategoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductCategoryPreviousValuesExec{ret}
}

func (instance ProductCategorySubscriptionPayloadExec) Exec(ctx context.Context) (*ProductCategorySubscriptionPayload, error) {
	var v ProductCategorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductCategorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductCategorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProductCategorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProductCategorySubscriptionPayload, error) {
	var v []ProductCategorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductCategorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ProductCategorySubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *ProductCategory `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type ProductCategoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProductCategoryPreviousValuesExec) Exec(ctx context.Context) (*ProductCategoryPreviousValues, error) {
	var v ProductCategoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductCategoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductCategoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProductCategoryPreviousValuesExecArray) Exec(ctx context.Context) ([]ProductCategoryPreviousValues, error) {
	var v []ProductCategoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductCategoryPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "name"}

type ProductCategoryPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ProductServiceAttributeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProductServiceAttributeSubscriptionPayloadExec) Node() *ProductServiceAttributeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductServiceAttribute"},
		"node",
		[]string{"id", "key"})

	return &ProductServiceAttributeExec{ret}
}

func (instance *ProductServiceAttributeSubscriptionPayloadExec) PreviousValues() *ProductServiceAttributePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductServiceAttributePreviousValues"},
		"previousValues",
		[]string{"id", "key"})

	return &ProductServiceAttributePreviousValuesExec{ret}
}

func (instance ProductServiceAttributeSubscriptionPayloadExec) Exec(ctx context.Context) (*ProductServiceAttributeSubscriptionPayload, error) {
	var v ProductServiceAttributeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductServiceAttributeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductServiceAttributeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProductServiceAttributeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProductServiceAttributeSubscriptionPayload, error) {
	var v []ProductServiceAttributeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductServiceAttributeSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ProductServiceAttributeSubscriptionPayload struct {
	Mutation      MutationType             `json:"mutation"`
	Node          *ProductServiceAttribute `json:"node,omitempty"`
	UpdatedFields []string                 `json:"updatedFields,omitempty"`
}

type ProductServiceAttributePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProductServiceAttributePreviousValuesExec) Exec(ctx context.Context) (*ProductServiceAttributePreviousValues, error) {
	var v ProductServiceAttributePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductServiceAttributePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductServiceAttributePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProductServiceAttributePreviousValuesExecArray) Exec(ctx context.Context) ([]ProductServiceAttributePreviousValues, error) {
	var v []ProductServiceAttributePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductServiceAttributePreviousValuesFields = []string{"id", "key"}

type ProductServiceAttributePreviousValues struct {
	ID  string `json:"id"`
	Key string `json:"key"`
}

type ProductSubCategorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProductSubCategorySubscriptionPayloadExec) Node() *ProductSubCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductSubCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryExec{ret}
}

func (instance *ProductSubCategorySubscriptionPayloadExec) PreviousValues() *ProductSubCategoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductSubCategoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ProductSubCategoryPreviousValuesExec{ret}
}

func (instance ProductSubCategorySubscriptionPayloadExec) Exec(ctx context.Context) (*ProductSubCategorySubscriptionPayload, error) {
	var v ProductSubCategorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductSubCategorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubCategorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubCategorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProductSubCategorySubscriptionPayload, error) {
	var v []ProductSubCategorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductSubCategorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ProductSubCategorySubscriptionPayload struct {
	Mutation      MutationType        `json:"mutation"`
	Node          *ProductSubCategory `json:"node,omitempty"`
	UpdatedFields []string            `json:"updatedFields,omitempty"`
}

type ProductSubCategoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProductSubCategoryPreviousValuesExec) Exec(ctx context.Context) (*ProductSubCategoryPreviousValues, error) {
	var v ProductSubCategoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductSubCategoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductSubCategoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProductSubCategoryPreviousValuesExecArray) Exec(ctx context.Context) ([]ProductSubCategoryPreviousValues, error) {
	var v []ProductSubCategoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProductSubCategoryPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "name"}

type ProductSubCategoryPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ReviewSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewSubscriptionPayloadExec) Node() *ReviewExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Review"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewExec{ret}
}

func (instance *ReviewSubscriptionPayloadExec) PreviousValues() *ReviewPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"})

	return &ReviewPreviousValuesExec{ret}
}

func (instance ReviewSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewSubscriptionPayload, error) {
	var v ReviewSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewSubscriptionPayload, error) {
	var v []ReviewSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Review      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ReviewPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewPreviousValuesExec) Exec(ctx context.Context) (*ReviewPreviousValues, error) {
	var v ReviewPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewPreviousValues, error) {
	var v []ReviewPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "type", "stars", "title", "text", "status"}

type ReviewPreviousValues struct {
	ID        string       `json:"id"`
	CreatedAt string       `json:"createdAt"`
	UpdatedAt string       `json:"updatedAt"`
	Type      ReviewType   `json:"type"`
	Stars     float64      `json:"stars"`
	Title     string       `json:"title"`
	Text      string       `json:"text"`
	Status    ReviewStatus `json:"status"`
}

type ServiceSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ServiceSubscriptionPayloadExec) Node() *ServiceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Service"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServiceExec{ret}
}

func (instance *ServiceSubscriptionPayloadExec) PreviousValues() *ServicePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServicePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"})

	return &ServicePreviousValuesExec{ret}
}

func (instance ServiceSubscriptionPayloadExec) Exec(ctx context.Context) (*ServiceSubscriptionPayload, error) {
	var v ServiceSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ServiceSubscriptionPayload, error) {
	var v []ServiceSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ServiceSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Service     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ServicePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ServicePreviousValuesExec) Exec(ctx context.Context) (*ServicePreviousValues, error) {
	var v ServicePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServicePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServicePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ServicePreviousValuesExecArray) Exec(ctx context.Context) ([]ServicePreviousValues, error) {
	var v []ServicePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServicePreviousValuesFields = []string{"id", "createdAt", "updatedAt", "price", "duration", "image", "genderTarget", "deleted", "active"}

type ServicePreviousValues struct {
	ID           string       `json:"id"`
	CreatedAt    string       `json:"createdAt"`
	UpdatedAt    string       `json:"updatedAt"`
	Price        int32        `json:"price"`
	Duration     int32        `json:"duration"`
	Image        *string      `json:"image,omitempty"`
	GenderTarget GenderTarget `json:"genderTarget"`
	Deleted      bool         `json:"deleted"`
	Active       bool         `json:"active"`
}

type ServiceCategorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ServiceCategorySubscriptionPayloadExec) Node() *ServiceCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryExec{ret}
}

func (instance *ServiceCategorySubscriptionPayloadExec) PreviousValues() *ServiceCategoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceCategoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceCategoryPreviousValuesExec{ret}
}

func (instance ServiceCategorySubscriptionPayloadExec) Exec(ctx context.Context) (*ServiceCategorySubscriptionPayload, error) {
	var v ServiceCategorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceCategorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceCategorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceCategorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ServiceCategorySubscriptionPayload, error) {
	var v []ServiceCategorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceCategorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ServiceCategorySubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *ServiceCategory `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type ServiceCategoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ServiceCategoryPreviousValuesExec) Exec(ctx context.Context) (*ServiceCategoryPreviousValues, error) {
	var v ServiceCategoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceCategoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceCategoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceCategoryPreviousValuesExecArray) Exec(ctx context.Context) ([]ServiceCategoryPreviousValues, error) {
	var v []ServiceCategoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceCategoryPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "name"}

type ServiceCategoryPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type ServiceSubCategorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ServiceSubCategorySubscriptionPayloadExec) Node() *ServiceSubCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceSubCategory"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryExec{ret}
}

func (instance *ServiceSubCategorySubscriptionPayloadExec) PreviousValues() *ServiceSubCategoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ServiceSubCategoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name"})

	return &ServiceSubCategoryPreviousValuesExec{ret}
}

func (instance ServiceSubCategorySubscriptionPayloadExec) Exec(ctx context.Context) (*ServiceSubCategorySubscriptionPayload, error) {
	var v ServiceSubCategorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceSubCategorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceSubCategorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceSubCategorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ServiceSubCategorySubscriptionPayload, error) {
	var v []ServiceSubCategorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceSubCategorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ServiceSubCategorySubscriptionPayload struct {
	Mutation      MutationType        `json:"mutation"`
	Node          *ServiceSubCategory `json:"node,omitempty"`
	UpdatedFields []string            `json:"updatedFields,omitempty"`
}

type ServiceSubCategoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ServiceSubCategoryPreviousValuesExec) Exec(ctx context.Context) (*ServiceSubCategoryPreviousValues, error) {
	var v ServiceSubCategoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ServiceSubCategoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ServiceSubCategoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ServiceSubCategoryPreviousValuesExecArray) Exec(ctx context.Context) ([]ServiceSubCategoryPreviousValues, error) {
	var v []ServiceSubCategoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ServiceSubCategoryPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "name"}

type ServiceSubCategoryPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Name      string `json:"name"`
}

type SessionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SessionSubscriptionPayloadExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionExec{ret}
}

func (instance *SessionSubscriptionPayloadExec) PreviousValues() *SessionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SessionPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "token"})

	return &SessionPreviousValuesExec{ret}
}

func (instance SessionSubscriptionPayloadExec) Exec(ctx context.Context) (*SessionSubscriptionPayload, error) {
	var v SessionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SessionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SessionSubscriptionPayload, error) {
	var v []SessionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type SessionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Session     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SessionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExec) Exec(ctx context.Context) (*SessionPreviousValues, error) {
	var v SessionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExecArray) Exec(ctx context.Context) ([]SessionPreviousValues, error) {
	var v []SessionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "token"}

type SessionPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Token     string `json:"token"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "type", "email", "passwordHash", "firstName", "lastName", "gender", "zipCode", "street", "city", "birthday", "birthdate", "phoneNumber", "image", "note", "allowReviewSharing", "notificationToken", "language", "deleted", "activated", "activateToken"}

type UserPreviousValues struct {
	ID                 string   `json:"id"`
	CreatedAt          string   `json:"createdAt"`
	UpdatedAt          string   `json:"updatedAt"`
	Type               UserType `json:"type"`
	Email              string   `json:"email"`
	PasswordHash       string   `json:"passwordHash"`
	FirstName          string   `json:"firstName"`
	LastName           string   `json:"lastName"`
	Gender             Gender   `json:"gender"`
	ZipCode            *string  `json:"zipCode,omitempty"`
	Street             *string  `json:"street,omitempty"`
	City               *string  `json:"city,omitempty"`
	Birthday           *string  `json:"birthday,omitempty"`
	Birthdate          *string  `json:"birthdate,omitempty"`
	PhoneNumber        *string  `json:"phoneNumber,omitempty"`
	Image              *string  `json:"image,omitempty"`
	Note               *string  `json:"note,omitempty"`
	AllowReviewSharing bool     `json:"allowReviewSharing"`
	NotificationToken  *string  `json:"notificationToken,omitempty"`
	Language           *string  `json:"language,omitempty"`
	Deleted            bool     `json:"deleted"`
	Activated          bool     `json:"activated"`
	ActivateToken      *string  `json:"activateToken,omitempty"`
}

type WorkingHoursSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WorkingHoursSubscriptionPayloadExec) Node() *WorkingHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkingHours"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursExec{ret}
}

func (instance *WorkingHoursSubscriptionPayloadExec) PreviousValues() *WorkingHoursPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WorkingHoursPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"})

	return &WorkingHoursPreviousValuesExec{ret}
}

func (instance WorkingHoursSubscriptionPayloadExec) Exec(ctx context.Context) (*WorkingHoursSubscriptionPayload, error) {
	var v WorkingHoursSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkingHoursSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkingHoursSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WorkingHoursSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WorkingHoursSubscriptionPayload, error) {
	var v []WorkingHoursSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WorkingHoursSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type WorkingHoursSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *WorkingHours `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type WorkingHoursPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WorkingHoursPreviousValuesExec) Exec(ctx context.Context) (*WorkingHoursPreviousValues, error) {
	var v WorkingHoursPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WorkingHoursPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WorkingHoursPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WorkingHoursPreviousValuesExecArray) Exec(ctx context.Context) ([]WorkingHoursPreviousValues, error) {
	var v []WorkingHoursPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WorkingHoursPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "day", "notWorking", "break", "startForenoon", "endForenoon", "startAfternoon", "endAfternoon", "status"}

type WorkingHoursPreviousValues struct {
	ID             string             `json:"id"`
	CreatedAt      string             `json:"createdAt"`
	UpdatedAt      string             `json:"updatedAt"`
	Day            DayOfWeek          `json:"day"`
	NotWorking     bool               `json:"notWorking"`
	Break          bool               `json:"break"`
	StartForenoon  *string            `json:"startForenoon,omitempty"`
	EndForenoon    *string            `json:"endForenoon,omitempty"`
	StartAfternoon *string            `json:"startAfternoon,omitempty"`
	EndAfternoon   *string            `json:"endAfternoon,omitempty"`
	Status         AvailabilityStatus `json:"status"`
}
